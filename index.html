<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media QC Tool</title>
    <!-- Meta tags for video mode, content will be set by JS -->
    <meta name="video-filename" content="">
    
    <style>
        /* --- COMBINED AND NORMALIZED CSS --- */
        :root { 
            --bg-color: #2e2e2e; --panel-bg: rgba(40, 40, 40, 0.8); --border-color: rgba(255, 255, 255, 0.2); --text-color: #f0f0f0; --text-color-light: #999; --highlight-color: #00aaff; --input-bg: rgba(0,0,0,0.3); --list-item-bg: rgba(0,0,0,0.2); --list-item-reply-bg: rgba(0,0,0,0.3); --checkbox-border: #555; --icon-btn-color: #999; --icon-btn-hover-color: #fff; --workspace-bg: #202020; --video-slot-bg: #000;
        }
        body.theme-light {
            --bg-color: #f0f2f5; --panel-bg: #ffffff; --border-color: #dee2e6; --text-color: #212529; --text-color-light: #6c757d; --input-bg: #ffffff; --list-item-bg: #ffffff; --list-item-reply-bg: #f1f3f5; --checkbox-border: #adb5bd; --icon-btn-color: #6c757d; --icon-btn-hover-color: #212529; --workspace-bg: #e9ecef; --video-slot-bg: #ffffff;
        }
        body, html { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: var(--workspace-bg); color: var(--text-color); overflow: hidden; height: 100vh; width: 100vw; }
        .hidden { display: none !important; }
        .glass-panel { background: var(--panel-bg); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border: 1px solid var(--border-color); box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2); transition: transform 0.4s ease, opacity 0.4s ease; }
        body.theme-light .glass-panel { backdrop-filter: none; -webkit-backdrop-filter: none; box-shadow: 0 2px 10px rgba(0,0,0,0.07); }
        #app-container { display: flex; height: 100%; width: 100%; }
        #main-content { flex-grow: 1; position: relative; height: 100%; display: flex; flex-direction: column; }
        
        #drop-zone { position: absolute; inset: 20px; border: 2px dashed rgba(173, 181, 189, 0.5); border-radius: 20px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 1.2em; color: var(--text-color-light); z-index: 100; transition: all 0.3s; pointer-events: auto; }
        #drop-zone p { background: var(--panel-bg); padding: 25px 35px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); border: 1px solid var(--border-color); line-height: 1.6; }
        #drop-zone.hidden { pointer-events: none; opacity: 0; }
        body.dragging #drop-zone { border-color: var(--highlight-color); background-color: rgba(0, 170, 255, 0.1); }
        #video-load-section { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-bottom: 20px; width: 80%; max-width: 500px; background: var(--panel-bg); padding: 25px 35px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); border: 1px solid var(--border-color);}
        #video-path-input { width: 100%; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-color); padding: 12px; box-sizing: border-box; text-align: center; font-size: 0.9em; }
        #load-video-btn { width: 100%; margin-top: 10px; padding: 12px; border: none; border-radius: 10px; background-color: var(--highlight-color); color: #fff; font-size: 1em; font-weight: bold; cursor: pointer; transition: background-color 0.3s ease; }
        #load-video-btn:hover { background-color: #0088cc; }
        #drop-zone .separator-text { font-weight: bold; color: var(--text-color-light); margin: 20px 0; }
        #image-load-section p { margin: 0; }

        #video-mode-container { width: 100%; height: 100%; position: relative; }
        #video-grid { display: grid; grid-template-columns: 1fr; width: 100%; height: 100%; }
        body.ref-video-loaded #video-grid { grid-template-columns: 1fr 1fr; }
        body.ref-video-loaded #video-slot-ref { border-right: 1px solid var(--border-color); }
        .video-slot { position: relative; background-color: var(--video-slot-bg); overflow: hidden; display: flex; justify-content: center; align-items: center; box-sizing: border-box; transition: background-color 0.3s; }
        .video-slot video { max-width: 100%; max-height: 100%; }
        body.theme-light .video-slot video { box-shadow: 0 4px 12px rgba(0,0,0,0.1); border-radius: 4px; }
        .video-filename { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; font-size: 0.8em; z-index: 11; color: #fff; }
        #canvas-main, #canvas-interaction { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; cursor: default; pointer-events: none; }
        #canvas-interaction { z-index: 15; pointer-events: auto; }
        #video-drop-zone { position: absolute; inset: 20px; border: 2px dashed rgba(173, 181, 189, 0.5); border-radius: 20px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 1em; color: var(--text-color-light); z-index: 100; transition: all 0.3s; pointer-events: none; opacity: 0;}
        body.dragging #video-drop-zone { opacity: 1; pointer-events: auto; border-color: var(--highlight-color); background-color: rgba(0, 170, 255, 0.1); }
        body.ref-video-loaded #video-drop-zone { width: 50%; right: 10px; left: auto; }
        
        #image-mode-container { flex-grow: 1; background-color: var(--workspace-bg); cursor: grab; overflow: hidden; position: relative; }
        #image-mode-container.panning { cursor: grabbing; }
        body.spacebar-down, body.spacebar-down .artboard, body.spacebar-down .interaction-canvas { cursor: grab !important; }
        body.spacebar-down.panning, body.spacebar-down.panning .artboard, body.spacebar-down.panning .interaction-canvas { cursor: grabbing !important; }
        #workspace { position: absolute; transform-origin: 0 0; }
        .artboard { position: absolute; background-color: var(--panel-bg); border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); padding-top: 30px; border: 2px solid transparent; overflow: hidden; }
        .artboard.dragging { z-index: 10; box-shadow: 0 8px 25px rgba(0,0,0,0.3); }
        .artboard.selected { border-color: var(--highlight-color); }
        .artboard-header { position: absolute; top: 0; left: 0; width: 100%; height: 30px; background-color: rgba(0,0,0,0.3); display: flex; justify-content: space-between; align-items: center; padding: 0 5px 0 10px; box-sizing: border-box; font-size: 12px; color: var(--text-color); cursor: grab; }
        .artboard-header:active { cursor: grabbing; }
        .artboard-header-tools { display: flex; align-items: center; }
        .artboard-title-container { flex: 1 1 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 5px; display: flex; align-items: baseline; }
        .artboard-title { text-overflow: ellipsis; overflow: hidden; }
        .artboard-info { color: var(--text-color-light); font-size: 0.9em; padding-left: 8px; }
        .grid-toggle-btn, .artboard-close-btn { background: none; border: none; color: var(--text-color-light); cursor: pointer; font-size: 1.2em; line-height: 1; padding: 0 5px; transition: color 0.2s, background-color 0.2s; flex-shrink: 0; border-radius: 4px; }
        .grid-toggle-btn.active { color: var(--highlight-color); background-color: rgba(0,0,0,0.3); }
        .grid-toggle-btn:hover, .artboard-close-btn:hover { color: #fff; background-color: rgba(255,255,255,0.1); }
        .artboard-close-btn { font-size: 1.4em; }
        .artboard-content { position: relative; width: 100%; height: 100%; }
        .artboard-content.transparent-grid { background-image: linear-gradient(45deg, #444 25%, transparent 25%), linear-gradient(-45deg, #444 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #444 75%), linear-gradient(-45deg, transparent 75%, #444 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px; }
        body.theme-light .artboard-content.transparent-grid { background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); }
        .artboard img { display: block; width: 100%; height: 100%; user-select: none; -webkit-user-drag: none; }
        .artboard canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .artboard canvas.interaction-canvas { pointer-events: auto; }
        .artboard-resizer { position: absolute; right: 2px; bottom: 2px; width: 16px; height: 16px; cursor: se-resize; z-index: 5; color: rgba(255,255,255,0.5); }
        .artboard-resizer:hover { color: white; }

        #bottom-controls-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 20; }
        #bottom-controls { display: flex; gap: 10px; align-items: flex-end; }
        #tools-panel, #ref-video-panel, #timeline-panel, #help-panel { padding: 8px; border-radius: 12px; display: flex; align-items: center; }
        #tools-panel { padding: 8px 10px; gap: 4px; }
        #timeline-panel { position: relative; gap: 10px; flex-grow: 1; width: 650px; }
        #help-panel { padding: 0; background: none; border: none; }
        .playback-controls { display: flex; align-items: center; gap: 4px; }
        .tool-btn { width: 28px; height: 28px; border-radius: 8px; border: none; background: transparent; color: var(--text-color-light); cursor: pointer; display: flex; justify-content: center; align-items: center; transition: all 0.2s; padding: 0; }
        .tool-btn:hover { color: var(--text-color); background-color: rgba(255,255,255,0.1); }
        body.theme-light .tool-btn:hover { background-color: rgba(0,0,0,0.05); }
        .tool-btn.active { color: #fff; background-color: var(--highlight-color); transform: scale(1.1); }
        body.theme-light .tool-btn.active { color: #fff; }
        .tool-btn svg { width: 18px; height: 18px; fill: currentColor; }
        #load-ref-video-btn svg { width: 20px; height: 20px; }
        .divider { width: 1px; height: 20px; background: var(--border-color); margin: 0 5px; }
        #color-picker { position: relative; }
        #active-color-btn { width: 20px; height: 20px; border-radius: 50%; cursor: pointer; border: 2px solid var(--text-color); }
        #color-palette-popup { position: absolute; bottom: 170%; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; padding: 8px; border-radius: 10px; background: var(--bg-color); border: 1px solid var(--border-color); z-index: 25; }
        .color-btn { width: 20px; height: 20px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: all 0.2s; }
        .color-btn:hover { transform: scale(1.2); }
        #play-pause-btn, #mute-btn, #snapshot-btn { background: none; border: none; color: var(--text-color); cursor: pointer; padding: 5px; display: flex; align-items: center; }
        #play-pause-btn svg, #mute-btn svg, #snapshot-btn svg { width: 20px; height: 20px; fill: currentColor; }
        #help-btn { background: var(--panel-bg); border: 1px solid var(--border-color); color: var(--text-color); cursor: pointer; display: flex; align-items: center; justify-content: center; height: 38px; padding: 0 12px; border-radius: 8px; font-weight: bold; font-size: 1.2em; }
        #time-display { cursor: pointer; padding: 2px 5px; font-variant-numeric: tabular-nums; }
        #time-display input { width: 50px; background: var(--input-bg); border: 1px solid var(--highlight-color); color: var(--text-color); font-family: inherit; text-align: center; }
        #timeline-wrapper { position: relative; flex-grow: 1; display: flex; align-items: center; }
        #timeline-bg, #timeline-diff, #timeline-markers { position: absolute; left: 0; top: 50%; transform: translateY(-50%); height: 5px; border-radius: 5px; pointer-events: none; }
        #timeline-bg { width: 100%; background: rgba(255, 255, 255, 0.3); }
        body.theme-light #timeline-bg { background: rgba(0,0,0,0.1); }
        #timeline-diff { background: rgba(255, 82, 82, 0.7); width: 0; }
        #timeline-markers { width: 100%; height: 10px; z-index: 2;}
        .timeline-marker { position: absolute; width: 2px; height: 10px; background-color: #ff9800; top: 50%; transform: translate(-50%, -50%); border-radius: 1px;}
        #timeline-slider { position: relative; z-index: 1; flex-grow: 1; -webkit-appearance: none; appearance: none; width: 100%; height: 5px; background: transparent !important; border-radius: 5px; outline: none; }
        #timeline-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 15px; height: 15px; background: var(--text-color); cursor: pointer; border-radius: 50%; }
        #speed-controls { display: flex; background: rgba(0,0,0,0.2); border-radius: 8px; }
        body.theme-light #speed-controls { background: rgba(0,0,0,0.05); }
        .speed-btn { background: none; border: none; color: var(--text-color-light); padding: 6px 12px; cursor: pointer; }
        .speed-btn.active { color: #fff; background: var(--highlight-color); border-radius: 8px; }
        body.theme-light .speed-btn.active { color: #fff; }
        #volume-popup { position: absolute; bottom: 120%; left: 45px; padding: 4px; display: flex; gap: 2px; }
        .volume-btn { background: none; border: 1px solid transparent; color: var(--text-color-light); padding: 4px 8px; cursor: pointer; border-radius: 5px; font-size: 0.8em; }
        .volume-btn:hover { background: rgba(255,255,255,0.1); color: var(--text-color); }
        body.theme-light .volume-btn:hover { background-color: rgba(0,0,0,0.05); }
        .volume-btn.active { background: var(--highlight-color); color: #fff; }

        #right-panel { flex: 0 0 340px; margin: 10px; margin-left: 0; display: flex; flex-direction: column; z-index: 20; border-radius: 15px; overflow: hidden; background: var(--workspace-bg); border: 1px solid var(--border-color); flex-shrink: 0; box-shadow: 0 2px 10px rgba(0,0,0,0.07); }
        #list-header { padding: 10px; border-bottom: 1px solid var(--border-color); }
        #search-input { width: 100%; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-color); padding: 8px; box-sizing: border-box; }
        #list-container { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        #annotation-list { list-style: none; padding: 10px; margin: 0; overflow-y: auto; flex-grow: 1; }
        #save-btn { display: block; width: calc(100% - 20px); margin: 10px; padding: 12px; border: none; border-radius: 10px; background-color: var(--highlight-color); color: #fff; font-size: 1em; font-weight: bold; cursor: pointer; flex-shrink: 0; transition: background-color 0.3s ease, color 0.3s ease; }
        #save-btn.unsaved { background-color: #ffc107; color: #000; }
        #annotation-list li { padding: 10px 12px; border-radius: 8px; margin-bottom: 8px; position: relative; background-color: var(--list-item-bg); transition: all 0.2s; cursor: pointer; border: 1px solid var(--border-color); }
        #annotation-list li.selected { background-color: rgba(0, 170, 255, 0.15); box-shadow: 0 0 0 2px var(--highlight-color) inset; border-color: var(--highlight-color);}
        #annotation-list li.completed { opacity: 0.6; }
        #annotation-list li.completed .content, #annotation-list li.completed .annotation-image { text-decoration: line-through; }
        #annotation-list li .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        #annotation-list li .time { font-size: 0.7em; color: var(--text-color-light); }
        #annotation-list li .content { margin: 0; font-size: 0.9em; white-space: pre-wrap; min-height: 1em; word-break: break-word; }
        #annotation-list li .annotation-image { max-width: 100%; border-radius: 4px; margin-top: 5px; display: block; }
        #annotation-list li.reply-item { margin-left: 20px; transform: scale(0.98); }
        #annotation-list .group-header { font-weight: bold; font-size: 0.9em; color: var(--text-color); background-color: var(--list-item-reply-bg); padding: 5px 10px; margin: 15px 0 5px 0; border-radius: 5px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        #annotation-list .group-header:first-child { margin-top: 0; }
        #annotation-list .group-header > span:first-child { font-size: 0.8em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-grow: 1; padding-right: 5px; }
        .collapse-toggle { transition: transform 0.2s; display: inline-block; }
        .group-header.collapsed .collapse-toggle { transform: rotate(-90deg); }
        .header-tools { display: flex; align-items: center; gap: 2px; } 
        .icon-btn { background: transparent; border: none; color: var(--icon-btn-color); cursor: pointer; opacity: 0.7; transition: all 0.2s; display: flex; justify-content: center; align-items: center; width: 20px; height: 20px; padding: 0; }
        .icon-btn:hover { opacity: 1; color: var(--icon-btn-hover-color); }
        .icon-btn svg { width: 12px; height: 12px; fill: currentColor; }
        .complete-checkbox { transform: scale(0.75); }
        #annotation-list li textarea { width: calc(100% - 6px); background: transparent; border: 1px solid var(--highlight-color); border-radius: 4px; color: var(--text-color); font-family: inherit; font-size: 1em; resize: none; overflow-y: hidden; box-sizing: border-box; }
        .complete-checkbox { appearance: none; width: 16px; height: 16px; border: 2px solid var(--checkbox-border); border-radius: 50%; cursor: pointer; transition: all 0.2s; }
        .complete-checkbox:checked { background-color: #28a745; border-color: #28a745; }
        .complete-checkbox:checked::after { content: '\2713'; display: block; text-align: center; color: #fff; font-weight: bold; font-size: 11px; line-height: 13px; }
        #panel-resizer { width: 5px; cursor: col-resize; flex-shrink: 0; background-color: transparent; transition: background-color 0.2s ease; align-self: stretch; margin: 10px 0; }
        #panel-resizer:hover { background-color: var(--highlight-color); }

        #help-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 200; display: flex; justify-content: center; align-items: center; }
        body.theme-light #help-modal { background: rgba(0,0,0,0.4); }
        #help-modal .modal-content { position: relative; padding: 20px 30px; width: 500px; border-radius: 15px; max-height: 80vh; overflow-y: auto; }
        #help-modal .shortcuts-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        #help-modal ul { list-style: none; padding-left: 0; margin-top: 5px; }
        #help-modal li { margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 0.9em; }
        #help-modal h3 { margin-top: 0; }
        #help-modal h4 { margin-top: 15px; margin-bottom: 5px; color: var(--text-color-light); border-bottom: 1px solid var(--border-color); padding-bottom: 5px; font-size: 1em; }
        #help-modal strong { color: var(--highlight-color); }
        #modal-close-btn { position: absolute; top: 10px; right: 15px; background: none; border: none; color: var(--text-color); font-size: 28px; cursor: pointer; }
        #help-modal hr { border-color: var(--border-color); }
        #change-user-btn, #theme-selector { background: var(--input-bg); border: 1px solid var(--border-color); color: var(--text-color); border-radius: 5px; padding: 2px 6px; margin-left: 10px; cursor: pointer; }
        #theme-selector {-webkit-appearance: none; appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23f0f0f0'%3E%3Cpath d='M6 9L.5 3h11z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 6px center; padding-right: 20px;}
        body.theme-light #theme-selector { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%231a1a1a'%3E%3Cpath d='M6 9L.5 3h11z'/%3E%3C/svg%3E");}
        #theme-selector option { background: var(--panel-bg); color: var(--text-color); }

        /* NEW: Video Path Modal Styles */
        #video-path-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 300; display: flex; justify-content: center; align-items: center; }
        #video-path-modal .modal-content { padding: 25px 30px; width: 600px; text-align: center; }
        #video-path-modal p { margin: 0 0 15px 0; line-height: 1.5; }
        #video-path-modal p strong { color: var(--highlight-color); word-break: break-all; }
        #video-path-modal input { width: 100%; margin-bottom: 15px; }
        #video-path-modal #filename-warning { color: #E53935; font-weight: bold; margin-top: 10px; }

    </style>
</head>
<body class="theme-dark">
    <input type="file" id="file-input" accept="image/*,video/*" style="display: none;" multiple>
    
    <div id="app-container">
        <div id="main-content">

            <div id="drop-zone">
                <div id="video-load-section">
                    <input type="text" id="video-path-input" placeholder="Dán đường dẫn đầy đủ của video (VD: Z:\phim\video.mp4)">
                    <button id="load-video-btn">Bắt đầu QC Video</button>
                </div>
                <div class="separator-text">HOẶC</div>
                <div id="image-load-section">
                    <p>Kéo & thả Hình ảnh vào đây<br>Hoặc bấm đúp để chọn file để bắt đầu QC Hình ảnh</p>
                </div>
            </div>

            <div id="video-mode-container" class="hidden">
                <div id="video-grid">
                    <div class="video-slot hidden" id="video-slot-ref">
                        <video id="video-ref" playsinline></video>
                        <div id="ref-video-filename" class="video-filename hidden"></div>
                    </div>
                    <div class="video-slot" id="video-slot-main">
                        <video id="video-main" playsinline></video>
                        <div id="main-video-filename" class="video-filename hidden"></div>
                        <canvas id="canvas-main"></canvas>
                        <canvas id="canvas-interaction"></canvas>
                    </div>
                </div>
                 <div id="video-drop-zone"><p>Thả ảnh vào đây để thêm như comment</p></div>
            </div>

            <div id="image-mode-container" class="hidden">
                <div id="workspace"></div>
            </div>
            
            <div id="bottom-controls-container" class="hidden">
                <div id="bottom-controls">
                    <div id="ref-video-panel" class="glass-panel hidden">
                        <button id="load-ref-video-btn" class="tool-btn" title="Tải/Đóng video tham chiếu">
                            <svg id="ref-video-add-icon" viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                            <svg id="ref-video-remove-icon" class="hidden" viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
                        </button>
                    </div>
        
                    <div id="tools-panel" class="glass-panel">
                        <button class="tool-btn" data-tool="comment" title="Comment (Q)"><svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 14v-2h12v2H6zm0-3v-2h12v2H6zm0-3v-2h12v2H6z"/></svg></button>
                        <button class="tool-btn" data-tool="rect" title="Square (W)"><svg viewBox="0 0 24 24"><path d="M3 3v18h18V3H3zm16 16H5V5h14v14z"/></svg></button>
                        <button class="tool-btn" data-tool="circle" title="Circle (E)"><svg viewBox="0 0 24 24"><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg></button>
                        <button class="tool-btn" data-tool="line" title="Line (R)"><svg viewBox="0 0 24 24"><path d="M21 11H3v2h18v-2z"/></svg></button>
                        <button class="tool-btn" data-tool="arrow" title="Arrow (T)"><svg viewBox="0 0 24 24"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8-8-8z"/></svg></button>
                        <div class="divider"></div>
                        <div id="color-picker">
                            <button id="active-color-btn" class="color-btn"></button>
                            <div id="color-palette-popup" class="hidden">
                                <button class="color-btn" data-color="#FFFFFF" style="background-color: #FFFFFF;"></button>
                                <button class="color-btn" data-color="#2D2D2D" style="background-color: #2D2D2D;"></button>
                                <button class="color-btn" data-color="#E53935" style="background-color: #E53935;"></button>
                                <button class="color-btn" data-color="#1E88E5" style="background-color: #1E88E5;"></button>
                                <button class="color-btn" data-color="#43A047" style="background-color: #43A047;"></button>
                                <button class="color-btn" data-color="#FDD835" style="background-color: #FDD835;"></button>
                                <button class="color-btn" data-color="#BDBDBD" style="background-color: #BDBDBD;"></button>
                            </div>
                        </div>
                    </div>
        
                    <div id="timeline-panel" class="glass-panel hidden">
                        <div class="playback-controls">
                            <button id="play-pause-btn" title="Play/Pause (Spacebar)"><svg id="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg><svg id="pause-icon" class="hidden" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg></button>
                            <button id="mute-btn" title="Mute/Unmute (Nhấn giữ để chỉnh âm lượng)"><svg id="unmute-icon" class="hidden" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg><svg id="mute-icon" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L7 9H3v6h4l5 5v-8.27l-5.73-5.73z"/></svg></button>
                        </div>
                        <div id="volume-popup" class="glass-panel hidden">
                            <button class="volume-btn" data-volume="0">0%</button>
                            <button class="volume-btn" data-volume="0.25">25%</button>
                            <button class="volume-btn" data-volume="0.5">50%</button>
                            <button class="volume-btn" data-volume="0.75">75%</button>
                            <button class="volume-btn" data-volume="1">100%</button>
                        </div>
                        <span id="time-display" title="Click to edit time">00:00</span>
                        <div id="timeline-wrapper">
                            <div id="timeline-bg"></div>
                            <div id="timeline-diff"></div>
                            <div id="timeline-markers"></div>
                            <input type="range" id="timeline-slider" value="0" step="0.01">
                        </div>
                        <div id="speed-controls"><button class="speed-btn" data-speed="1">1x</button><button class="speed-btn" data-speed="2">2x</button><button class="speed-btn" data-speed="3">3x</button></div>
                        <button id="snapshot-btn" title="Save Frame as PNG"><svg viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg></button>
                    </div>
        
                    <div id="help-panel" class="glass-panel">
                        <button id="help-btn" title="Help & Shortcuts">?</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="panel-resizer"></div>

        <div id="right-panel" class="hidden">
            <div id="list-header">
                <input type="search" id="search-input" placeholder="Tìm kiếm...">
            </div>
            <div id="list-container"><ul id="annotation-list"></ul><button id="save-btn">Lưu file HTML</button></div>
        </div>
    </div>

    <div id="help-modal" class="hidden">
        <div class="modal-content glass-panel">
            <button id="modal-close-btn">&times;</button>
            <h3>Phím tắt & Trợ giúp</h3>
            <div class="shortcuts-grid">
                <div id="general-shortcuts">
                    <h4>Chung</h4>
                    <ul>
                        <li><strong>Ctrl + D</strong><span>Mở / Thêm file</span></li>
                        <li><strong>Ctrl + S</strong><span>Lưu file</span></li>
                        <li><strong>Ctrl + Shift + S</strong><span>Lưu thành file mới</span></li>
                        <li><strong>Ctrl + C / V</strong><span>Copy / Dán</span></li>
                        <li><strong>Ctrl + Z / Shift+Z</strong><span>Undo / Redo Xóa</span></li>
                         <li><strong>Delete</strong><span>Xóa mục đã chọn</span></li>
                        <li><strong>Ctrl / Shift + Click</strong><span>Chọn nhiều</span></li>
                        <li><strong>Ctrl + A</strong><span>Chọn toàn bộ</span></li>
                        <li><strong>Ctrl + F</strong><span>Tìm kiếm</span></li>
                         <li><strong>Q, W, E, R, T</strong><span>Chọn công cụ</span></li>
                    </ul>
                </div>
                <div id="video-shortcuts" class="hidden">
                    <h4>Video Mode</h4>
                    <ul>
                        <li><strong>Spacebar</strong><span>Play / Pause</span></li>
                        <li><strong>← / →</strong><span>Từng frame</span></li>
                        <li><strong>Shift + ← / →</strong><span>Từng giây</span></li>
                        <li><strong>Lăn chuột</strong><span>Tiến / lùi frame</span></li>
                        <li><strong>↑ / ↓</strong><span>Về đầu / cuối video</span></li>
                    </ul>
                </div>
                <div id="image-shortcuts" class="hidden">
                    <h4>Image Mode</h4>
                    <ul>
                        <li><strong>Space+Kéo / Chuột giữa</strong><span>Di chuyển (Pan)</span></li>
                        <li><strong>Ctrl + Lăn chuột</strong><span>Phóng to / Thu nhỏ</span></li>
                        <li><strong>Ctrl + 0</strong><span>Reset góc nhìn</span></li>
                        <li><strong>Ctrl + Alt + 0</strong><span>Vừa tất cả Artboard</span></li>
                        <li><strong>Ctrl + G</strong><span>Sắp xếp Artboard</span></li>
                        <li><strong>Alt + Kéo</strong><span>Sao chép nhanh</span></li>
                    </ul>
                </div>
            </div>
            <hr>
            <p><strong>User:</strong> <span id="current-user-display"></span> <button id="change-user-btn">[Sửa]</button></p>
            <p><strong>Chế độ:</strong> 
                <select id="theme-selector">
                    <option value="system">Tự động (System)</option>
                    <option value="light">Sáng (Light)</option>
                    <option value="dark">Tối (Dark)</option>
                </select>
            </p>
            <p><strong>Contact:</strong> tri.vu.trong@inbold.com</p>
        </div>
    </div>
    
    <!-- NEW: Modal for when video file is not found -->
    <div id="video-path-modal" class="hidden">
        <div class="modal-content glass-panel">
            <h3>Không tìm thấy file Video</h3>
            <p>Không thể tải video từ vị trí đã lưu:<br><strong><span id="original-video-path-display"></span></strong></p>
            <p>Vui lòng cung cấp đường dẫn mới đến file video.</p>
            <input type="text" id="new-video-path-input" class="video-path-input" placeholder="Dán đường dẫn mới vào đây (VD: D:\folder\video.mp4)">
            <button id="load-new-path-btn" class="load-video-btn">Tải Video</button>
            <p id="filename-warning" class="hidden"></p>
        </div>
    </div>

    <!-- Embedded data will be placed here on save -->
    <script id="app-data" type="application/json"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const app = {
                body: document.body, fileInput: document.getElementById('file-input'),
                dropZone: document.getElementById('drop-zone'),
                mainContent: document.getElementById('main-content'),
                videoModeContainer: document.getElementById('video-mode-container'),
                imageModeContainer: document.getElementById('image-mode-container'),
                bottomControlsContainer: document.getElementById('bottom-controls-container'),
                rightPanel: document.getElementById('right-panel'),
                annotationList: document.getElementById('annotation-list'), searchInput: document.getElementById('search-input'), 
                listContainer: document.getElementById('list-container'), saveBtn: document.getElementById('save-btn'),
                videoMain: document.getElementById('video-main'), videoRef: document.getElementById('video-ref'), 
                videoGrid: document.getElementById('video-grid'), videoRefSlot: document.getElementById('video-slot-ref'),
                canvasMain: document.getElementById('canvas-main'), canvasInteraction: document.getElementById('canvas-interaction'),
                timelinePanel: document.getElementById('timeline-panel'), timelineSlider: document.getElementById('timeline-slider'), 
                timeDisplay: document.getElementById('time-display'),
                refVideoPanel: document.getElementById('ref-video-panel'), refVideoAddIcon: document.getElementById('ref-video-add-icon'),
                refVideoRemoveIcon: document.getElementById('ref-video-remove-icon'),
                mainVideoFilename: document.getElementById('main-video-filename'), refVideoFilename: document.getElementById('ref-video-filename'),
                videoDropZone: document.getElementById('video-drop-zone'),
                workspaceContainer: document.getElementById('image-mode-container'),
                workspace: document.getElementById('workspace'),
                get ctxMain() { return this.canvasMain.getContext('2d'); },
                get ctxInteraction() { return this.canvasInteraction.getContext('2d'); },
            };

            let state = {};
            const imageCache = new Map();

            function resetState() {
                state = {
                    mode: 'none',
                    annotations: [], currentTool: null, activeColor: '#E53935',
                    selectedIndices: [], lastClickedIndex: -1,
                    undoStack: [], redoStack: [],
                    currentFileHandle: null, hasUnsavedChanges: false, currentUser: null,
                    videoPath: null, 
                    clipboard: [],
                    interaction: { mode: 'none', target: null, startPos: { x: 0, y: 0 }, lastMousePos: { x: 0, y: 0 } },
                    isAddingFiles: false,
                    frameDuration: 1 / 30, isMuted: true, isLoadingRefVideo: false,
                    artboards: [],
                    view: { scale: 1, offsetX: 0, offsetY: 0, minScale: 0.1, maxScale: 10 },
                    layout: { nextX: 50, nextY: 50, rowMaxHeight: 0, margin: 50, maxRowWidth: 4000 },
                    spacebarPressed: false,
                };
            }

            function init() {
                resetState();
                promptForUser(); 
                initTheme();
                autoLoadData();

                app.mainContent.addEventListener('dblclick', (e) => { 
                    if (e.target.closest('#image-load-section') || e.target === app.workspaceContainer) {
                        state.isAddingFiles = (state.mode !== 'none');
                        app.fileInput.setAttribute('accept', 'image/*');
                        app.fileInput.click();
                    } 
                });
                
                document.getElementById('load-video-btn').addEventListener('click', loadVideoFromPath);
                document.getElementById('video-path-input').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') { e.preventDefault(); loadVideoFromPath(); }
                });

                window.addEventListener('dragover', e => { e.preventDefault(); document.body.classList.add('dragging'); });
                window.addEventListener('dragleave', e => { if (e.relatedTarget === null) document.body.classList.remove('dragging'); });
                window.addEventListener('drop', handleDrop);
                app.fileInput.addEventListener('change', processFileInput);
                window.addEventListener('paste', handlePaste);
                window.addEventListener('keydown', onKeyDown);
                window.addEventListener('keyup', onKeyUp);
                window.addEventListener('mouseup', onWindowMouseUp);
                window.addEventListener('mousemove', onWindowMouseMove);

                document.querySelectorAll('.tool-btn').forEach(b => b.addEventListener('click', () => selectTool(b.dataset.tool)));
                document.getElementById('active-color-btn').addEventListener('click', (e) => { e.stopPropagation(); toggleColorPalette(); });
                document.querySelectorAll('#color-palette-popup .color-btn').forEach(b => b.addEventListener('click', (e) => { e.stopPropagation(); selectColor(b); }));
                selectColor(document.querySelector('#color-palette-popup .color-btn[data-color="#E53935"]'));
                app.saveBtn.addEventListener('click', saveState);
                app.searchInput.addEventListener('input', () => updateAnnotationList());
                app.listContainer.addEventListener('click', (e) => { if (e.target === app.listContainer || e.target === app.annotationList) { state.selectedIndices = []; state.lastClickedIndex = -1; updateListSelection(); } });
                document.getElementById('panel-resizer').addEventListener('mousedown', initPanelResize);
                
                document.getElementById('help-btn').addEventListener('click', () => {
                    document.getElementById('general-shortcuts').classList.remove('hidden');
                    document.getElementById('video-shortcuts').classList.toggle('hidden', state.mode !== 'video');
                    document.getElementById('image-shortcuts').classList.toggle('hidden', state.mode !== 'image');
                    document.getElementById('help-modal').classList.remove('hidden');
                });
                document.getElementById('modal-close-btn').addEventListener('click', () => document.getElementById('help-modal').classList.add('hidden'));
                document.getElementById('change-user-btn').addEventListener('click', changeUser);
                 window.addEventListener('click', (e) => {
                     if (!e.target.closest('#color-picker')) document.getElementById('color-palette-popup').classList.add('hidden');
                     if (state.mode === 'video' && !e.target.closest('#mute-btn')) document.getElementById('volume-popup').classList.add('hidden');
                });
                
                document.getElementById('load-ref-video-btn').addEventListener('click', () => { if (app.body.classList.contains('ref-video-loaded')) { video_removeRefVideo(); } else { state.isLoadingRefVideo = true; state.isAddingFiles = true; app.fileInput.setAttribute('accept', 'video/*'); app.fileInput.click(); } });
                document.getElementById('play-pause-btn').addEventListener('click', video_togglePlayPause);
                video_initMuteButton();
                document.querySelectorAll('.volume-btn').forEach(btn => btn.addEventListener('click', e => { video_setVolume(parseFloat(e.target.dataset.volume)); document.getElementById('volume-popup').classList.add('hidden'); }));
                document.querySelectorAll('.speed-btn').forEach(btn => btn.addEventListener('click', () => video_setPlaybackSpeed(parseFloat(btn.dataset.speed))));
                document.getElementById('snapshot-btn').addEventListener('click', video_saveFrame);
                app.timeDisplay.addEventListener('click', video_makeTimeEditable);
                app.timelineSlider.addEventListener('input', () => { video_seekTo(parseFloat(app.timelineSlider.value)); video_updateTimeline(); });
                app.canvasInteraction.addEventListener('mousedown', video_onCanvasMouseDown);
                app.canvasInteraction.addEventListener('dblclick', video_onCanvasDblClick);
                app.canvasInteraction.addEventListener('wheel', video_onCanvasWheel, { passive: false });

                app.workspaceContainer.addEventListener('mousedown', image_onWorkspaceMouseDown);
                app.workspaceContainer.addEventListener('wheel', image_onWorkspaceWheel, { passive: false });
                
                updateSaveButtonState();
            }

            function loadVideoFromPath() {
                const pathInput = document.getElementById('video-path-input');
                const videoPath = pathInput.value.trim();
                if (!videoPath) {
                    alert('Vui lòng nhập đường dẫn đến file video.');
                    return;
                }
                resetState();
                promptForUser();
                switchToVideoMode(videoPath);
            }

            function switchToVideoMode(videoPath) {
                state.mode = 'video';
                state.videoPath = videoPath;

                app.dropZone.classList.add('hidden');
                app.imageModeContainer.classList.add('hidden');
                app.videoModeContainer.classList.remove('hidden');
                app.bottomControlsContainer.classList.remove('hidden');
                app.rightPanel.classList.remove('hidden');
                app.timelinePanel.classList.remove('hidden');
                app.refVideoPanel.classList.remove('hidden');

                const videoName = videoPath.split(/[\\/]/).pop();
                const loadablePath = 'file:///' + videoPath.replace(/\\/g, '/');
                video_loadMainVideo(loadablePath, videoName);
            }

            function switchToImageMode(imageFiles) {
                state.mode = 'image';
                app.dropZone.classList.add('hidden');
                app.videoModeContainer.classList.add('hidden');
                app.imageModeContainer.classList.remove('hidden');
                app.bottomControlsContainer.classList.remove('hidden');
                app.rightPanel.classList.remove('hidden');
                app.timelinePanel.classList.add('hidden');
                app.refVideoPanel.classList.add('hidden');
                
                image_handleFiles(imageFiles);
                image_updateWorkspaceTransform();
            }

            // --- UPDATED AUTO-LOAD LOGIC ---
            async function autoLoadData() {
                const dataScript = document.getElementById('app-data');
                const videoFilenameMeta = document.querySelector('meta[name="video-filename"]');
                const dataJson = dataScript ? dataScript.textContent.trim() : null;
                const savedFileUri = videoFilenameMeta ? videoFilenameMeta.getAttribute('content') : null;

                if (!dataJson) return; // No data, do nothing

                try {
                    const loadedData = JSON.parse(dataJson);
                    
                    if (loadedData.artboards) { // It's an image QC file
                        switchToImageMode([]);
                        state.annotations = loadedData.annotations || [];
                        const artboardPromises = (loadedData.artboards || []).map(boardData => {
                            return new Promise((resolve) => {
                                const img = new Image();
                                img.onload = () => { state.artboards.push({ ...boardData, imageObject: img }); resolve(); };
                                img.onerror = resolve; // Continue even if one image fails
                                img.src = boardData.imageData;
                            });
                        });
                        await Promise.all(artboardPromises);
                        if(loadedData.layout) state.layout = loadedData.layout;
                        image_renderWorkspace();
                    } else { // It's a video QC file
                        if (!savedFileUri) throw new Error("Video filename missing from meta tag.");
                        
                        // Prepare for video mode
                        state.mode = 'video';
                        app.dropZone.classList.add('hidden');
                        app.imageModeContainer.classList.add('hidden');
                        app.videoModeContainer.classList.remove('hidden');
                        app.bottomControlsContainer.classList.remove('hidden');
                        app.rightPanel.classList.remove('hidden');
                        app.timelinePanel.classList.remove('hidden');
                        app.refVideoPanel.classList.remove('hidden');

                        const originalFilename = savedFileUri.split('/').pop();
                        const originalSystemPath = savedFileUri.replace(/^file:\/\/\//i, '').replace(/\//g, '\\');
                        state.videoPath = originalSystemPath; // Set initial path

                        const completeVideoSetup = (loadedPath, displayName) => {
                            video_loadMainVideo(loadedPath, displayName);
                            app.videoMain.addEventListener('loadedmetadata', async () => {
                                await video_processLoadedAnnotations(loadedData);
                                state.annotations = loadedData;
                                updateAnnotationList();
                                video_redrawAllCanvases();
                            }, { once: true });
                        };

                        const tryLoadVideo = (path) => {
                            return new Promise((resolve, reject) => {
                                const tempVideo = document.createElement('video');
                                tempVideo.oncanplay = () => {
                                    tempVideo.oncanplay = null;
                                    tempVideo.onerror = null;
                                    resolve(path);
                                };
                                tempVideo.onerror = () => {
                                    tempVideo.oncanplay = null;
                                    tempVideo.onerror = null;
                                    reject(new Error(`Failed to load video from ${path}`));
                                };
                                tempVideo.src = path;
                            });
                        };

                        // Start loading cascade
                        tryLoadVideo(originalFilename) // 1. Try relative path
                            .then(loadedPath => {
                                console.log("Successfully loaded video from relative path.");
                                state.videoPath = originalFilename; // Update state to reflect it's now relative
                                completeVideoSetup(loadedPath, originalFilename);
                            })
                            .catch(() => { // 2. Try absolute path
                                console.log("Relative path failed, trying absolute path...");
                                return tryLoadVideo(savedFileUri);
                            })
                            .then(loadedPath => {
                                if(loadedPath){ // This check is needed because the first then() doesn't return anything
                                    console.log("Successfully loaded video from absolute path.");
                                    completeVideoSetup(loadedPath, originalFilename);
                                }
                            })
                            .catch(() => { // 3. Both failed, ask user
                                console.log("Absolute path failed, asking user for new path.");
                                showVideoPathModal(originalSystemPath, originalFilename, completeVideoSetup);
                            });
                    }

                    updateAnnotationList();
                    updateSaveButtonState();
                } catch (err) {
                    console.error("Error auto-loading embedded data:", err);
                    alert('Lỗi khi tải dữ liệu có sẵn trong file.');
                }
            }

            function showVideoPathModal(originalSystemPath, originalFilename, callback) {
                const modal = document.getElementById('video-path-modal');
                const pathDisplay = document.getElementById('original-video-path-display');
                const pathInput = document.getElementById('new-video-path-input');
                const loadBtn = document.getElementById('load-new-path-btn');
                
                pathDisplay.textContent = originalSystemPath;
                modal.classList.remove('hidden');

                const onButtonClick = () => {
                    const newPath = pathInput.value.trim();
                    if (!newPath) return;

                    const newFilename = newPath.split(/[\\/]/).pop();
                    
                    if (newFilename.toLowerCase() !== originalFilename.toLowerCase()) {
                        const proceed = confirm(`CẢNH BÁO:\nTên file mới (${newFilename}) khác với tên file gốc (${originalFilename}).\n\nBạn có chắc chắn muốn tiếp tục không?`);
                        if (!proceed) return;
                    }
                    
                    const newFileUri = 'file:///' + newPath.replace(/\\/g, '/');
                    state.videoPath = newPath; // Update state with the new, correct path
                    modal.classList.add('hidden');
                    loadBtn.removeEventListener('click', onButtonClick); // Clean up listener
                    callback(newFileUri, newFilename);
                };

                loadBtn.addEventListener('click', onButtonClick);
            }


            // --- GLOBAL EVENT HANDLERS ---
            function processFileInput(e) {
                app.fileInput.setAttribute('accept', 'image/*,video/*');

                if (!e.target.files.length) return;
                const files = Array.from(e.target.files);
                
                if (state.isAddingFiles) {
                    if (state.mode === 'image') {
                        const imageFiles = files.filter(f => f.type.startsWith('image/'));
                        if(imageFiles.length > 0) image_handleFiles(imageFiles);
                    } else if (state.mode === 'video' && state.isLoadingRefVideo) {
                        const videoFile = files.find(f => f.type.startsWith('video/'));
                        if(videoFile) video_loadRefVideo(URL.createObjectURL(videoFile), videoFile.name);
                    }
                } else {
                    handleFiles(files);
                }

                state.isAddingFiles = false;
                state.isLoadingRefVideo = false;
                e.target.value = '';
            }

            async function handleDrop(e) {
                e.preventDefault();
                document.body.classList.remove('dragging');
                if (!e.dataTransfer.files.length) return;
                const files = Array.from(e.dataTransfer.files);
                
                if (state.mode === 'video') {
                    const imageFile = files.find(f => f.type.startsWith('image/'));
                     if (imageFile) {
                        state.interaction.lastMousePos = video_getMousePos(e);
                        const img = await video_createImageFromBlob(imageFile);
                        video_placeImageAnnotation(img);
                    }
                } else if (state.mode === 'image') {
                    const imageFiles = files.filter(f => f.type.startsWith('image/'));
                    if(imageFiles.length > 0) image_handleFiles(imageFiles);
                }
                else {
                    handleFiles(files);
                }
            }
            
            function handleFiles(files) {
                if (state.mode !== 'none') return; 

                const imageFiles = files.filter(f => f.type.startsWith('image/'));

                if (imageFiles.length > 0) {
                    resetState();
                    promptForUser();
                    switchToImageMode(imageFiles);
                }
            }
            
            async function handlePaste(e) {
                const activeEl = document.activeElement;
                if (activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'INPUT') return;
                
                if (state.clipboard.length > 0) {
                    e.preventDefault();
                    if(state.mode === 'video') video_pasteAnnotationsFromInternalClipboard();
                    else if(state.mode === 'image') image_pasteAnnotations();
                    return;
                }
                
                const items = e.clipboardData.items;
                const imageItem = Array.from(items).find(item => item.type.startsWith('image/'));
                
                if (imageItem) {
                    e.preventDefault();
                    const blob = imageItem.getAsFile();
                    if (state.mode === 'video') {
                        const img = await video_createImageFromBlob(blob);
                        state.interaction.lastMousePos = { x: 0.5, y: 0.5 };
                        video_placeImageAnnotation(img);
                    } else {
                         if (state.mode === 'none') switchToImageMode([]);
                         image_handleFiles([blob]);
                    }
                    return;
                }

                if (state.mode === 'video') {
                     const textItem = Array.from(items).find(item => item.type === 'text/plain');
                     if (textItem) {
                        e.preventDefault();
                        textItem.getAsString(text => {
                            if (text.trim().length > 0) {
                                const ann = { type: 'comment', time: app.videoMain.currentTime, data: { x: 0.5, y: 0.5 }, color: state.activeColor, text, completed: false };
                                video_addAnnotation(ann, false); 
                            }
                        });
                    }
                }
            }

            function onKeyUp(e) {
                if (e.key === ' ' && state.mode === 'image') {
                    e.preventDefault();
                    state.spacebarPressed = false;
                    app.body.classList.remove('spacebar-down', 'panning');
                }
            }

            function onKeyDown(e) {
                const activeEl = document.activeElement;
                if (['TEXTAREA', 'INPUT'].includes(activeEl.tagName) && activeEl.id !== 'search-input' && activeEl.id !== 'video-path-input') return;

                if (e.key === ' ' && state.mode === 'image' && !state.spacebarPressed) {
                    e.preventDefault();
                    state.spacebarPressed = true;
                    app.body.classList.add('spacebar-down');
                }
                
                if (e.ctrlKey) {
                    switch (e.key.toLowerCase()) {
                        case 's': e.preventDefault(); e.shiftKey ? saveStateAs() : saveState(); return;
                        case 'z': e.preventDefault(); e.shiftKey ? redoDelete() : undoDelete(); return;
                        case 'f': e.preventDefault(); app.searchInput.focus(); app.searchInput.select(); return;
                        case 'a': e.preventDefault(); state.selectedIndices = state.annotations.map((_, i) => i); updateListSelection(); return;
                        case 'd': e.preventDefault(); state.isAddingFiles = (state.mode !== 'none'); app.fileInput.click(); return;
                        case 'c': 
                            if (state.selectedIndices.length > 0) {
                                e.preventDefault();
                                if(state.mode === 'video') video_copyAnnotationsToInternalClipboard();
                                if(state.mode === 'image') image_copySelectedAnnotations();
                            }
                            return;
                    }
                }
                if (e.key === 'Delete') { e.preventDefault(); deleteAnnotationsByIndices(state.selectedIndices); }
                if ('qwerty'.includes(e.key.toLowerCase())) { const toolMap = {q:'comment', w:'rect', e:'circle', r:'line', t:'arrow'}; selectTool(toolMap[e.key]); }
                
                if (state.mode === 'video') {
                    video_onKeyDown(e);
                } else if (state.mode === 'image') {
                    image_onKeyDown(e);
                }
            }
            
            function onWindowMouseMove(e) {
                if(state.mode === 'video') {
                    video_onCanvasMouseMove(e);
                } else if (state.mode === 'image') {
                    image_onWindowMouseMove(e);
                }
            }
            
            function onWindowMouseUp(e) {
                 if(state.mode === 'video') {
                    video_onCanvasMouseUp(e);
                } else if (state.mode === 'image') {
                    image_onWindowMouseUp(e);
                }
            }


            function promptForUser() {
                let user = localStorage.getItem('qcToolUser');
                if (!user || user.trim() === '') {
                    user = prompt('Vui lòng nhập tên của bạn (tối đa 16 ký tự):', user || '');
                    if (user) user = user.substring(0, 16);
                    else user = "Anonymous";
                }
                state.currentUser = user.trim();
                localStorage.setItem('qcToolUser', state.currentUser);
                updateUserDisplay();
            }

            function changeUser() { let user = prompt('Nhập tên mới (tối đa 16 ký tự):', state.currentUser); if (user && user.trim() !== '') { state.currentUser = user.trim().substring(0, 16); localStorage.setItem('qcToolUser', state.currentUser); updateUserDisplay(); } }
            function updateUserDisplay() { document.getElementById('current-user-display').textContent = state.currentUser; }
            function applyTheme(theme) { app.body.classList.remove('theme-light', 'theme-dark'); if (theme === 'light') app.body.classList.add('theme-light'); else if (theme === 'dark') app.body.classList.add('theme-dark'); else { if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) app.body.classList.add('theme-light'); else app.body.classList.add('theme-dark'); } }
            function setTheme(theme) { applyTheme(theme); localStorage.setItem('qcToolTheme', theme); document.getElementById('theme-selector').value = theme; }
            function initTheme() { const savedTheme = localStorage.getItem('qcToolTheme') || 'system'; setTheme(savedTheme); window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', () => { const currentSetting = localStorage.getItem('qcToolTheme') || 'system'; if (currentSetting === 'system') applyTheme('system'); }); document.getElementById('theme-selector').addEventListener('change', e => setTheme(e.target.value)); }
            function initPanelResize(e) { e.preventDefault(); const startX = e.clientX; const startWidth = app.rightPanel.offsetWidth; const doResize = (e) => { const newWidth = startWidth - (e.clientX - startX); if (newWidth > 250 && newWidth < 800) { app.rightPanel.style.flexBasis = newWidth + 'px'; } }; const stopResize = () => { window.removeEventListener('mousemove', doResize); window.removeEventListener('mouseup', stopResize); }; window.addEventListener('mousemove', doResize); window.addEventListener('mouseup', stopResize); }
            
            const selectTool = tool => { 
                state.currentTool = state.currentTool === tool ? null : tool; 
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.toggle('active', b.dataset.tool === state.currentTool)); 
                const cursor = state.currentTool ? 'default' : 'default';
                if (state.mode === 'video') {
                    app.canvasInteraction.style.cursor = cursor;
                } else if (state.mode === 'image') { 
                    document.querySelectorAll('.interaction-canvas').forEach(c => c.style.cursor = cursor);
                }
            };
            const selectColor = btn => { state.activeColor = btn.dataset.color; document.getElementById('active-color-btn').style.backgroundColor = state.activeColor; document.getElementById('color-palette-popup').classList.add('hidden'); };
            const toggleColorPalette = () => document.getElementById('color-palette-popup').classList.toggle('hidden');

            function markAsChanged() { if (!state.hasUnsavedChanges) { state.hasUnsavedChanges = true; updateSaveButtonState(); } }

            function updateSaveButtonState() {
                const count = state.annotations.length;
                const countText = count > 0 ? ` (${count} cmt)` : '';
                if (state.hasUnsavedChanges) {
                    app.saveBtn.textContent = `Chưa lưu${countText}`;
                    app.saveBtn.classList.add('unsaved');
                } else {
                    app.saveBtn.classList.remove('unsaved');
                    app.saveBtn.textContent = state.currentFileHandle ? `Đã lưu${countText}` : `Lưu file HTML${countText}`;
                }
            }

            async function generateAnnotatedHTML() {
                let dataToSave;
                if (state.mode === 'video') {
                    dataToSave = await video_prepareAnnotationsForSave();
                } else if (state.mode === 'image') {
                    dataToSave = image_prepareDataForSave();
                } else {
                    return null;
                }
                
                const dataStr = JSON.stringify(dataToSave, null, 2);
                const docClone = document.cloneNode(true);
                docClone.getElementById('app-data').textContent = '\n' + dataStr + '\n';

                if (state.mode === 'video') {
                    const videoMeta = docClone.querySelector('meta[name="video-filename"]');
                    if (videoMeta && state.videoPath) {
                        // Check if the path is relative (doesn't contain slashes). If so, don't convert.
                        const isRelative = !state.videoPath.includes('/') && !state.videoPath.includes('\\');
                        const fileUri = isRelative ? state.videoPath : 'file:///' + state.videoPath.replace(/\\/g, '/');
                        videoMeta.setAttribute('content', fileUri);
                    }
                }
                return `<!DOCTYPE html>\n` + docClone.documentElement.outerHTML;
            }

            async function saveState() {
                if (state.mode === 'none') return;
                if (!state.currentFileHandle) { await saveStateAs(); return; }
                const htmlContent = await generateAnnotatedHTML();
                if(!htmlContent) return;
                try {
                    const writable = await state.currentFileHandle.createWritable();
                    await writable.write(htmlContent);
                    await writable.close();
                    state.hasUnsavedChanges = false;
                    updateSaveButtonState();
                } catch (err) { console.error('Error saving:', err); alert("Lưu file thất bại. Vui lòng thử 'Lưu thành file mới'."); await saveStateAs(); }
            }

            async function saveStateAs() {
                if (state.mode === 'none') return;
                const htmlContent = await generateAnnotatedHTML();
                if(!htmlContent) return;
                const fallbackSave = (data) => {
                    const defaultName = state.mode === 'video' 
                        ? (app.mainVideoFilename.textContent || 'video').split('.').slice(0, -1).join('.') || 'video_qc'
                        : 'Image_QC';
                    const blob = new Blob([data], { type: 'text/html;charset=utf-8' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = `${defaultName}.html`;
                    a.click();
                    URL.revokeObjectURL(a.href);
                    state.hasUnsavedChanges = false;
                    updateSaveButtonState();
                };
                if ('showSaveFilePicker' in window) {
                    try {
                        const defaultName = state.mode === 'video' 
                            ? (app.mainVideoFilename.textContent || 'video').split('.').slice(0, -1).join('.') || 'video_qc'
                            : 'Image_QC';
                        const fileHandle = await window.showSaveFilePicker({ suggestedName: `${defaultName}.html`, types: [{ description: 'HTML QC File', accept: { 'text/html': ['.html'] } }] });
                        const writable = await fileHandle.createWritable();
                        await writable.write(htmlContent);
                        await writable.close();
                        state.currentFileHandle = fileHandle;
                        state.hasUnsavedChanges = false;
                        updateSaveButtonState();
                    } catch (err) { if (err.name !== 'AbortError') { console.error('Error saving file:', err); fallbackSave(htmlContent); } }
                } else {
                    fallbackSave(htmlContent);
                }
            }
            
            function deleteAnnotationsByIndices(indicesToDelete) {
                if (state.mode === 'none' || !indicesToDelete || indicesToDelete.length === 0) return;

                const idsToDelete = new Set();
                const queue = indicesToDelete.map(index => state.annotations[index]?.id).filter(id => id);
                queue.forEach(id => idsToDelete.add(id));
                
                let currentQueue = [...queue];
                while(currentQueue.length > 0) {
                    const parentId = currentQueue.shift();
                    const children = state.annotations.filter(ann => ann.parentId === parentId);
                    children.forEach(child => {
                        if (!idsToDelete.has(child.id)) {
                            idsToDelete.add(child.id);
                            currentQueue.push(child.id);
                        }
                    });
                }
                
                const deletedItems = state.annotations.map((annotation, originalIndex) => ({ annotation, originalIndex })).filter(item => idsToDelete.has(item.annotation.id)).sort((a,b) => a.originalIndex - b.originalIndex);
                if (deletedItems.length === 0) return;
                
                state.undoStack.push(deletedItems);
                state.redoStack = [];
                state.annotations = state.annotations.filter(ann => !idsToDelete.has(ann.id));
                state.selectedIndices = [];
                state.lastClickedIndex = -1;
                
                markAsChanged();
                updateAnnotationList(); 
                updateSaveButtonState();
                if(state.mode === 'video') video_redrawAllCanvases();
                else if (state.mode === 'image') image_redrawAllAnnotations();
            }

            function undoDelete() {
                if (state.undoStack.length === 0) return;
                const itemsToRestore = state.undoStack.pop();
                state.redoStack.push(itemsToRestore);
                itemsToRestore.forEach(item => state.annotations.splice(item.originalIndex, 0, item.annotation));
                markAsChanged();
                updateAnnotationList(); 
                updateSaveButtonState();
                if(state.mode === 'video') video_redrawAllCanvases();
                else if (state.mode === 'image') image_redrawAllAnnotations();
            }

            function redoDelete() {
                if (state.redoStack.length === 0) return;
                const itemsToDeleteFromRedo = state.redoStack.pop();
                state.undoStack.push(itemsToDeleteFromRedo);
                const idsToDelete = new Set(itemsToDeleteFromRedo.map(item => item.annotation.id));
                state.annotations = state.annotations.filter(ann => !idsToDelete.has(ann.id));
                markAsChanged();
                updateAnnotationList(); 
                updateSaveButtonState();
                if(state.mode === 'video') video_redrawAllCanvases();
                else if (state.mode === 'image') image_redrawAllAnnotations();
            }

            function updateListSelection() {
                const selectedIds = new Set(state.selectedIndices.map(i => state.annotations[i]?.id));
                app.annotationList.querySelectorAll('li:not(.group-header)').forEach(item => {
                    item.classList.toggle('selected', selectedIds.has(item.dataset.id));
                });
                if(state.mode === 'video') video_redrawAllCanvases();
                else if (state.mode === 'image') image_redrawAllAnnotations();
            }
            
            function makeListItemEditable(li, index) {
                const ann = state.annotations[index];
                if(state.mode === 'video' && ann.type === 'image') return; 

                let contentEl = li.querySelector('.content');
                if (!contentEl) { contentEl = document.createElement('p'); contentEl.className = 'content'; li.appendChild(contentEl); }
                if (contentEl.querySelector('textarea')) return;

                const oldText = ann.text || '';
                contentEl.innerHTML = `<textarea rows="1">${oldText}</textarea>`;
                const textarea = contentEl.querySelector('textarea');
                const autoSize = () => { textarea.style.height = 'auto'; textarea.style.height = `${textarea.scrollHeight}px`; };
                textarea.addEventListener('input', autoSize);
                setTimeout(() => { textarea.focus(); textarea.select(); autoSize(); }, 0);
                const save = () => { 
                    const newText = textarea.value;
                    if (newText !== oldText) { ann.text = newText; markAsChanged(); }
                    const currentSelectedIndexes = [...state.selectedIndices];
                    updateAnnotationList();
                    state.selectedIndices = currentSelectedIndexes;
                    updateListSelection();
                    if(state.mode === 'video') video_redrawAllCanvases();
                    else if(state.mode === 'image') image_redrawAllAnnotations();
                };
                textarea.addEventListener('blur', save);
                textarea.addEventListener('keydown', e => { if (e.key === 'Escape') { e.stopPropagation(); textarea.removeEventListener('blur', save); updateAnnotationList();} if (e.ctrlKey && e.key === 'Enter') { e.stopPropagation(); textarea.blur(); } });
            }
            
            function updateAnnotationList() {
                if (state.mode === 'video') {
                    video_updateAnnotationList();
                } else if (state.mode === 'image') {
                    image_updateAnnotationList();
                }
            }

            function video_onKeyDown(e) {
                if (e.key === ' ') {
                    if (document.activeElement.id !== 'search-input') {
                        e.preventDefault();
                        video_togglePlayPause();
                    }
                    return;
                }
                let handled = true;
                switch(e.key) {
                    case 'ArrowLeft': e.shiftKey ? video_seekSeconds(-1) : video_seekFrames(-1); break;
                    case 'ArrowRight': e.shiftKey ? video_seekSeconds(1) : video_seekFrames(1); break;
                    case 'ArrowUp': video_seekTo(0); break;
                    case 'ArrowDown': video_seekTo(app.timelineSlider.max); break;
                    default: handled = false;
                }
                if (handled) e.preventDefault();
            }
            
            function video_loadMainVideo(src, name) {
                app.videoMain.src = src; 
                app.videoMain.muted = state.isMuted;
                app.mainVideoFilename.textContent = name;
                app.mainVideoFilename.classList.remove('hidden');
                app.videoMain.addEventListener('loadedmetadata', () => {
                    const track = app.videoMain.getVideoPlaybackQuality ? app.videoMain.getVideoPlaybackQuality() : {};
                    const frameRate = (track.totalVideoFrames / app.videoMain.duration) || 30;
                    state.frameDuration = 1 / frameRate;
                    video_updateTimelineDurations();
                    new ResizeObserver(video_redrawAllCanvases).observe(app.videoMain.parentElement);
                    video_redrawAllCanvases();
                    video_updateTimelineMarkers();
                }, { once: true });
                app.videoMain.addEventListener('timeupdate', video_updateTimeline);
                app.videoMain.addEventListener('play', () => { video_setPlayButtonState(true); if (app.videoRef.src) app.videoRef.play(); });
                app.videoMain.addEventListener('pause', () => { video_setPlayButtonState(false); if (app.videoRef.src) app.videoRef.pause(); });
            }
            
            async function video_prepareAnnotationsForSave() { if (!app.videoMain.videoWidth) return []; const annotationsToSave = JSON.parse(JSON.stringify(state.annotations)); for (let i = 0; i < state.annotations.length; i++) { const ann = state.annotations[i]; if (ann.type === 'image' && ann.data.imageObject) { const base64 = await video_getBase64FromImage(ann.data.imageObject); const { p1, p2 } = ann.data; const width = Math.abs(p2.x - p1.x) * app.videoMain.videoWidth; const height = Math.abs(p2.y - p1.y) * app.videoMain.videoHeight; const x = (p1.x + p2.x) / 2 * app.videoMain.videoWidth; const y = (p1.y + p2.y) / 2 * app.videoMain.videoHeight; annotationsToSave[i].data = { base64, x, y, width, height }; } } return annotationsToSave; }
            const video_togglePlayPause = () => app.videoMain.src && (app.videoMain.paused ? app.videoMain.play() : app.videoMain.pause());
            const video_setPlayButtonState = isPlaying => { document.getElementById('play-icon').classList.toggle('hidden', isPlaying); document.getElementById('pause-icon').classList.toggle('hidden', !isPlaying); };
            let video_longPressTimer; let video_isLongPress = false;
            function video_initMuteButton() { const muteBtn = document.getElementById('mute-btn'); muteBtn.addEventListener('mousedown', () => { video_isLongPress = false; video_longPressTimer = setTimeout(() => { video_isLongPress = true; document.getElementById('volume-popup').classList.remove('hidden'); }, 1000); }); muteBtn.addEventListener('mouseup', () => { clearTimeout(video_longPressTimer); }); muteBtn.addEventListener('click', () => { if (!video_isLongPress) { video_toggleMute(); } }); }
            const video_updateMuteIcon = () => { const isEffectivelyMuted = state.isMuted || app.videoMain.volume === 0; document.getElementById('mute-icon').classList.toggle('hidden', !isEffectivelyMuted); document.getElementById('unmute-icon').classList.toggle('hidden', isEffectivelyMuted); };
            const video_toggleMute = () => { state.isMuted = !state.isMuted; if (state.isMuted) { app.videoMain.muted = true; } else { app.videoMain.muted = false; if (app.videoMain.volume === 0) { app.videoMain.volume = 0.75; } } video_updateMuteIcon(); };
            function video_setVolume(level) { app.videoMain.volume = level; state.isMuted = level === 0; app.videoMain.muted = state.isMuted; video_updateMuteIcon(); document.querySelectorAll('.volume-btn').forEach(btn => { btn.classList.toggle('active', parseFloat(btn.dataset.volume) === level); }); }
            const video_setPlaybackSpeed = speed => { app.videoMain.playbackRate = speed; if(app.videoRef.src) app.videoRef.playbackRate = speed; document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed)); };
            const video_seekTo = time => { if (app.videoMain.src) { const newTime = Math.max(0, Math.min(app.timelineSlider.max, time)); app.videoMain.currentTime = newTime; if (app.videoRef.src) app.videoRef.currentTime = newTime; video_redrawAllCanvases(); }};
            const video_seekFrames = count => video_seekTo(app.videoMain.currentTime + count * state.frameDuration);
            const video_seekSeconds = count => video_seekTo(app.videoMain.currentTime + count);
            const video_updateTimeline = () => { if(!app.timelineSlider.matches(':active')) app.timelineSlider.value = app.videoMain.currentTime; app.timeDisplay.textContent = video_formatTime(app.videoMain.currentTime); video_redrawAllCanvases(); };
            function video_onCanvasMouseDown(e) { state.interaction.startPos = video_getMousePos(e); const hit = video_getHitAnnotation(state.interaction.startPos); if (hit.handle) { state.interaction.mode = 'resizing'; state.interaction.target = { index: hit.index, handle: hit.handle }; } else if (hit.index !== -1) { state.interaction.mode = 'dragging'; if (!state.selectedIndices.includes(hit.index)) { state.selectedIndices = [hit.index]; state.lastClickedIndex = hit.index; updateListSelection(); } video_redrawAllCanvases(); } else if (state.currentTool) { app.videoMain.pause(); if (state.currentTool === 'comment') { video_addAnnotation({ type: 'comment', time: app.videoMain.currentTime, data: { x: state.interaction.startPos.x, y: state.interaction.startPos.y }, color: state.activeColor, text: '', completed: false }, true); } else { state.interaction.mode = 'drawing'; } } else { state.selectedIndices = []; state.lastClickedIndex = -1; updateListSelection(); video_redrawAllCanvases(); } }
            function video_onCanvasMouseMove(e) { if (state.interaction.mode === 'none') return; const currentPos = video_getMousePos(e); state.interaction.lastMousePos = currentPos; const { ctxInteraction: ctx, canvasInteraction: canvas } = app; ctx.clearRect(0, 0, canvas.width, canvas.height); switch (state.interaction.mode) { case 'drawing': video_drawShape(ctx, {type: state.currentTool, data: {p1: state.interaction.startPos, p2: currentPos}, color: state.activeColor}, true, true); break; case 'dragging': const dx = currentPos.x - state.interaction.startPos.x; const dy = currentPos.y - state.interaction.startPos.y; state.selectedIndices.forEach(idx => video_moveAnnotation(idx, dx, dy)); state.interaction.startPos = currentPos; video_redrawAllCanvases(); markAsChanged(); break; case 'resizing': video_resizeAnnotation(state.interaction.target.index, state.interaction.target.handle, currentPos); video_redrawAllCanvases(); markAsChanged(); break; default: const hit = video_getHitAnnotation(currentPos); app.canvasInteraction.style.cursor = hit.cursor || 'default'; break; } }
            function video_onCanvasMouseUp(e) { if(['panning', 'draggingArtboard', 'resizingArtboard'].includes(state.interaction.mode)) return; app.ctxInteraction.clearRect(0, 0, app.canvasInteraction.width, app.canvasInteraction.height); if (state.interaction.mode === 'drawing') { const endPos = video_getMousePos(e); if (Math.hypot(endPos.x - state.interaction.startPos.x, endPos.y - state.interaction.startPos.y) * app.videoMain.videoWidth > 5) { video_addAnnotation({ type: state.currentTool, time: app.videoMain.currentTime, data: { p1: state.interaction.startPos, p2: endPos }, color: state.activeColor, text: '', completed: false }, true); } } state.interaction.mode = 'none'; app.canvasInteraction.style.cursor = video_getHitAnnotation(video_getMousePos(e)).cursor || 'default'; video_redrawAllCanvases(); }
            function video_onCanvasDblClick(e) { const hit = video_getHitAnnotation(video_getMousePos(e)); if (hit.index !== -1) { const li = app.annotationList.querySelector(`li[data-id='${state.annotations[hit.index].id}']`); if (li) makeListItemEditable(li, hit.index); } }
            function video_onCanvasWheel(e) { e.preventDefault(); video_seekFrames(e.deltaY > 0 ? 1 : -1); }
            function video_copyAnnotationsToInternalClipboard() { if (state.selectedIndices.length === 0) { state.clipboard = []; return; } const allAnnotationsMap = new Map(state.annotations.map(ann => [ann.id, ann])); const idsToCopy = new Set(); const queue = state.selectedIndices.map(index => state.annotations[index].id); queue.forEach(id => idsToCopy.add(id)); let head = 0; while (head < queue.length) { const parentId = queue[head++]; state.annotations.forEach(ann => { if (ann.parentId === parentId && !idsToCopy.has(ann.id)) { idsToCopy.add(ann.id); queue.push(ann.id); } }); } state.clipboard = Array.from(idsToCopy).map(id => allAnnotationsMap.get(id)).map(ann => JSON.parse(JSON.stringify(ann))); }
            function video_pasteAnnotationsFromInternalClipboard() { if (state.clipboard.length === 0) return; const idMap = new Map(); const newAnnotations = []; const currentTime = app.videoMain.currentTime; state.clipboard.forEach(oldAnn => { const newAnn = JSON.parse(JSON.stringify(oldAnn)); const newId = crypto.randomUUID(); idMap.set(oldAnn.id, newId); newAnn.id = newId; newAnn.time = currentTime; newAnn.user = state.currentUser; newAnn.completed = false; newAnnotations.push(newAnn); }); const newIdSet = new Set(idMap.values()); newAnnotations.forEach(newAnn => { if (newAnn.parentId && idMap.has(newAnn.parentId)) { newAnn.parentId = idMap.get(newAnn.parentId); } else { newAnn.parentId = null; } }); state.annotations.push(...newAnnotations); state.annotations.sort((a, b) => a.time - b.time); state.selectedIndices = state.annotations.map((ann, index) => ({ ann, index })).filter(item => newIdSet.has(item.ann.id)).map(item => item.index); state.lastClickedIndex = state.selectedIndices.length > 0 ? state.selectedIndices[state.selectedIndices.length - 1] : -1; markAsChanged(); updateAnnotationList(); video_redrawAllCanvases(); if (state.lastClickedIndex !== -1) { const lastNewId = state.annotations[state.lastClickedIndex].id; const li = app.annotationList.querySelector(`li[data-id='${lastNewId}']`); if (li) li.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } }
            function video_addAnnotation(ann, startEditing = false) { if (['rect', 'circle', 'line', 'arrow'].includes(ann.type) && !ann.text) { ann.text = ''; } ann.user = state.currentUser; ann.id = crypto.randomUUID(); ann.parentId = ann.parentId || null; state.annotations.push(ann); state.annotations.sort((a,b) => a.time - b.time); state.undoStack = []; state.redoStack = []; const newIndex = state.annotations.findIndex(a => a === ann); state.selectedIndices = [newIndex]; state.lastClickedIndex = newIndex; markAsChanged(); updateAnnotationList(); updateSaveButtonState(); video_redrawAllCanvases(); if (startEditing) { const li = app.annotationList.querySelector(`li[data-id='${ann.id}']`); if (li) { li.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); makeListItemEditable(li, newIndex); } } }
            function video_updateAnnotationList() { const listScrollTop = app.annotationList.scrollTop; app.annotationList.innerHTML = ''; const searchTerm = app.searchInput.value.toLowerCase(); let annotationsToDisplay = state.annotations; if (searchTerm) { const annotationMap = new Map(state.annotations.map(ann => [ann.id, ann])); const matchingAnnotations = state.annotations.filter(ann => { const typeDisplay = ann.parentId ? 'reply' : (ann.type === 'comment' ? 'cmt' : ann.type); return (ann.text || '').toLowerCase().includes(searchTerm) || (ann.user || '').toLowerCase().includes(searchTerm) || typeDisplay.toLowerCase().includes(searchTerm); }); const idsToRender = new Set(); matchingAnnotations.forEach(ann => { let current = ann; while(current) { if (idsToRender.has(current.id)) break; idsToRender.add(current.id); current = current.parentId ? annotationMap.get(current.parentId) : null; } const queue = [ann.id]; while (queue.length > 0) { const parentId = queue.shift(); state.annotations.forEach(child => { if (child.parentId === parentId && !idsToRender.has(child.id)) { idsToRender.add(child.id); queue.push(child.id); } }); } }); annotationsToDisplay = state.annotations.filter(ann => idsToRender.has(ann.id)); } const renderAnnotation = (ann, index) => { const li = document.createElement('li'); li.dataset.id = ann.id; li.dataset.index = index; li.classList.toggle('selected', state.selectedIndices.includes(index)); li.classList.toggle('completed', ann.completed); li.classList.toggle('reply-item', !!ann.parentId); let contentHtml = ''; if (ann.type === 'image') { const img = ann.data.imageObject || imageCache.get(ann.data.base64); if(img) contentHtml += `<img src="${img.src}" class="annotation-image" alt="Annotation Image">`; } if (ann.text) { contentHtml += `<p class="content">${ann.text.replace(/\n/g, '<br>')}</p>`; } const title = ann.type === 'image' ? 'image' : 'text'; let headerToolsHtml = ` <button class="icon-btn" title="Xóa"> <svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg> </button> <button class="icon-btn" title="Copy ${title}"> <svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg> </button> <button class="icon-btn" title="Trả lời"> <svg viewBox="0 0 24 24"><path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/></svg> </button> <input type="checkbox" class="complete-checkbox" ${ann.completed ? 'checked' : ''}>`; const typeDisplay = ann.parentId ? 'reply' : (ann.type === 'comment' ? 'cmt' : ann.type); const userDisplay = ann.user ? ` - <strong>${ann.user}</strong>` : ''; li.innerHTML = ` <div class="header"> <span class="time">${index + 1} - ${video_formatTime(ann.time)}${userDisplay} - ${typeDisplay}</span> <div class="header-tools">${headerToolsHtml}</div> </div> ${contentHtml}`; li.addEventListener('click', e => { if (e.target.closest('.icon-btn')) return; const clickedIndex = parseInt(li.dataset.index, 10); if (e.shiftKey && state.lastClickedIndex !== -1) { const start = Math.min(state.lastClickedIndex, clickedIndex); const end = Math.max(state.lastClickedIndex, clickedIndex); state.selectedIndices = Array.from({length: end - start + 1}, (_, i) => start + i); } else if (e.ctrlKey) { const idxInSelection = state.selectedIndices.indexOf(clickedIndex); if (idxInSelection > -1) { state.selectedIndices.splice(idxInSelection, 1); } else { state.selectedIndices.push(clickedIndex); } } else { state.selectedIndices = [clickedIndex]; } state.lastClickedIndex = clickedIndex; video_seekTo(ann.time); updateListSelection(); }); li.addEventListener('dblclick', () => makeListItemEditable(li, index)); li.querySelector('.complete-checkbox').addEventListener('click', e => { e.stopPropagation(); ann.completed = e.target.checked; li.classList.toggle('completed', ann.completed); markAsChanged(); video_redrawAllCanvases(); }); const [deleteBtn, copyBtn, replyBtn] = li.querySelectorAll('.icon-btn'); deleteBtn.addEventListener('click', e => { e.stopPropagation(); deleteAnnotationsByIndices([index]); }); copyBtn.addEventListener('click', e => { e.stopPropagation(); const showFeedback = (target, success) => { const originalContent = target.innerHTML; target.innerHTML = success ? '✓' : '✗'; setTimeout(() => { target.innerHTML = originalContent; }, 1500); }; if (ann.type === 'image') { video_copyImageToClipboard(ann).then(() => showFeedback(e.currentTarget, true)).catch(err => { console.error('Failed to copy image: ', err); showFeedback(e.currentTarget, false); }); } else { navigator.clipboard.writeText(ann.text || '').then(() => showFeedback(e.currentTarget, true)).catch(err => { console.error('Failed to copy text: ', err); showFeedback(e.currentTarget, false); }); } }); replyBtn.addEventListener('click', e => { e.stopPropagation(); video_addAnnotation({ type: 'comment', time: ann.time, data: { x: ann.data.x, y: ann.data.y }, color: state.activeColor, text: '', completed: false, parentId: ann.id }, true); }); return li; }; const annotationTree = annotationsToDisplay.filter(ann => !ann.parentId); const replyMap = new Map(); annotationsToDisplay.filter(ann => ann.parentId).forEach(reply => { if (!replyMap.has(reply.parentId)) replyMap.set(reply.parentId, []); replyMap.get(reply.parentId).push(reply); }); const renderThread = (ann) => { const index = state.annotations.indexOf(ann); const li = renderAnnotation(ann, index); app.annotationList.appendChild(li); const children = replyMap.get(ann.id) || []; children.sort((a,b) => a.time - b.time).forEach(renderThread); }; annotationTree.forEach(renderThread); app.annotationList.scrollTop = listScrollTop; video_updateTimelineMarkers(); }
            function video_updateTimelineMarkers() { const markerContainer = document.getElementById('timeline-markers'); const duration = app.timelineSlider.max; markerContainer.innerHTML = ''; if (!duration || duration <= 0) return; const uniqueTimes = [...new Set(state.annotations.map(ann => ann.time))]; uniqueTimes.forEach(time => { const marker = document.createElement('div'); marker.className = 'timeline-marker'; marker.style.left = `${(time / duration) * 100}%`; markerContainer.appendChild(marker); }); }
            function video_redrawAllCanvases() { const { ctxMain: ctx, canvasMain: canvas, videoMain: video } = app; if (!video.videoWidth) return; const parentRect = canvas.parentElement.getBoundingClientRect(); [app.canvasMain, app.canvasInteraction].forEach(c => { if (c.width !== parentRect.width || c.height !== parentRect.height) { c.width = parentRect.width; c.height = parentRect.height; } }); ctx.clearRect(0, 0, canvas.width, canvas.height); state.annotations.forEach((ann, index) => { if (Math.abs(ann.time - video.currentTime) < state.frameDuration * 2) { if (ann.type === 'comment' && ann.parentId) return; video_drawShape(ctx, ann, state.selectedIndices.includes(index)); } }); if (state.selectedIndices.length === 1) { const ann = state.annotations[state.selectedIndices[0]]; if (ann && ann.type !== 'comment' && !ann.parentId && Math.abs(ann.time - video.currentTime) < state.frameDuration * 2) { video_drawHandles(ctx, ann); } } }
            function video_getHitAnnotation(pos) { let found = { index: -1, handle: null, cursor: null }; const video = app.videoMain; if (!video.videoWidth) return found; const videoRect = video_getVideoRect(app.canvasInteraction, video); if (videoRect.width === 0) return found; for (let i = state.annotations.length - 1; i >= 0; i--) { const ann = state.annotations[i]; if (Math.abs(video.currentTime - ann.time) > state.frameDuration * 2) continue; if (ann.type === 'comment' && ann.parentId) continue; if (state.selectedIndices.includes(i) && ann.type !== 'comment') { const handle = video_getHitHandle(pos, ann); if(handle) { return { index: i, handle: handle.name, cursor: handle.cursor }; } } let hit = false; if (ann.type === 'comment') { const iconSize = 24; const anchorOffsetX = 2; const anchorOffsetY = 22; const widthNorm = iconSize / videoRect.width; const heightNorm = iconSize / videoRect.height; const anchorOffsetXNorm = anchorOffsetX / videoRect.width; const anchorOffsetYNorm = anchorOffsetY / videoRect.height; const topLeftXNorm = ann.data.x - anchorOffsetXNorm; const topLeftYNorm = ann.data.y - anchorOffsetYNorm; hit = (pos.x >= topLeftXNorm && pos.x <= topLeftXNorm + widthNorm && pos.y >= topLeftYNorm && pos.y <= topLeftYNorm + heightNorm); } else { const padding = 10 / video.videoWidth; const { p1, p2 } = ann.data; const bb = { x: Math.min(p1.x, p2.x) - padding, y: Math.min(p1.y, p2.y) - padding, w: Math.abs(p1.x - p2.x) + 2 * padding, h: Math.abs(p1.y - p2.y) + 2 * padding }; hit = (pos.x > bb.x && pos.x < bb.x + bb.w && pos.y > bb.y && pos.y < bb.y + bb.h); } if(hit) { return { index: i, handle: null, cursor: 'move' }; } } return found; }
            function video_drawShape(ctx, ann, isSelected, isPreview = false) { if (!ctx || !app.videoMain.videoWidth) return; ctx.save(); const videoRect = video_getVideoRect(ctx.canvas, app.videoMain); ctx.translate(videoRect.x, videoRect.y); const { type, data, color } = ann; ctx.strokeStyle = color; ctx.lineWidth = isSelected ? 4 : 2; if(isPreview) { ctx.setLineDash([6, 3]); ctx.lineWidth = 3; } const denorm = (p) => ({ x: p.x * videoRect.width, y: p.y * videoRect.height }); ctx.beginPath(); switch (type) { case 'comment': { const pos = denorm(data); const size = 24; ctx.fillStyle = color; const path = new Path2D("M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"); ctx.save(); ctx.translate(pos.x, pos.y); ctx.scale(size / 24, size / 24); ctx.translate(-2, -22); ctx.fill(path); ctx.restore(); if (isSelected) { ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.beginPath(); ctx.arc(pos.x, pos.y, 12, 0, 2 * Math.PI); ctx.fill(); } break; } case 'image': const img = ann.data.imageObject || imageCache.get(ann.data.base64); if (img && img.complete && img.naturalHeight !== 0) { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); ctx.drawImage(img, p1_abs.x, p1_abs.y, p2_abs.x - p1_abs.x, p2_abs.y - p1_abs.y); if (isSelected) { ctx.strokeStyle = '#00aaff'; ctx.strokeRect(p1_abs.x, p1_abs.y, p2_abs.x - p1_abs.x, p2_abs.y - p1_abs.y); } } break; case 'rect': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); ctx.rect(p1_abs.x, p1_abs.y, p2_abs.x - p1_abs.x, p2_abs.y - p1_abs.y); break; } case 'circle': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); ctx.ellipse(p1_abs.x + (p2_abs.x-p1_abs.x)/2, p1_abs.y + (p2_abs.y-p1_abs.y)/2, Math.abs((p2_abs.x-p1_abs.x)/2), Math.abs((p2_abs.y-p1_abs.y)/2), 0, 0, 2 * Math.PI); break; } case 'line': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); ctx.moveTo(p1_abs.x, p1_abs.y); ctx.lineTo(p2_abs.x, p2_abs.y); break; } case 'arrow': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); const h = 15, dx = p2_abs.x - p1_abs.x, dy = p2_abs.y - p1_abs.y, a = Math.atan2(dy, dx); ctx.moveTo(p1_abs.x, p1_abs.y); ctx.lineTo(p2_abs.x, p2_abs.y); ctx.lineTo(p2_abs.x - h * Math.cos(a - Math.PI / 6), p2_abs.y - h * Math.sin(a - Math.PI / 6)); ctx.moveTo(p2_abs.x, p2_abs.y); ctx.lineTo(p2_abs.x - h * Math.cos(a + Math.PI / 6), p2_abs.y - h * Math.sin(a + Math.PI / 6)); break; } } if (type !== 'comment' && type !== 'image') ctx.stroke(); ctx.restore(); }
            function video_drawHandles(ctx, ann) { if (!app.videoMain.videoWidth) return; ctx.save(); const videoRect = video_getVideoRect(ctx.canvas, app.videoMain); ctx.translate(videoRect.x, videoRect.y); const handles = video_getHandlesFor(ann); ctx.fillStyle = 'white'; const handleSize = 10; handles.forEach(h => { const x_abs = h.x * videoRect.width; const y_abs = h.y * videoRect.height; ctx.fillRect(x_abs - handleSize/2, y_abs - handleSize/2, handleSize, handleSize) }); ctx.restore(); }
            const video_getHandlesFor = (ann) => { const { p1, p2 } = ann.data; if (ann.type === 'line' || ann.type === 'arrow') return [{name: 'p1', x: p1.x, y: p1.y, cursor: 'pointer'}, {name: 'p2', x: p2.x, y: p2.y, cursor: 'pointer'}]; const minX = Math.min(p1.x, p2.x), minY = Math.min(p1.y, p2.y); const maxX = Math.max(p1.x, p2.x), maxY = Math.max(p1.y, p2.y); return [ {name: 'tl', x: minX, y: minY, cursor: 'nwse-resize'}, {name: 'tr', x: maxX, y: minY, cursor: 'nesw-resize'}, {name: 'bl', x: minX, y: maxY, cursor: 'nesw-resize'}, {name: 'br', x: maxX, y: maxY, cursor: 'nwse-resize'} ]; };
            const video_getHitHandle = (pos, ann) => { const handleSize = 16 / app.videoMain.videoWidth; return video_getHandlesFor(ann).find(h => pos.x > h.x - handleSize/2 && pos.x < h.x + handleSize/2 && pos.y > h.y - handleSize/2 && pos.y < h.y + handleSize/2) || null; }
            function video_moveAnnotation(index, dx, dy) { const ann = state.annotations[index]; if (ann.type === 'comment') { ann.data.x += dx; ann.data.y += dy; } else { ann.data.p1.x += dx; ann.data.p1.y += dy; ann.data.p2.x += dx; ann.data.p2.y += dy; } }
            function video_resizeAnnotation(index, handle, pos) { const ann = state.annotations[index]; if (ann.type === 'image' && ann.data.imageObject) { const ratio = ann.data.imageObject.naturalWidth / ann.data.imageObject.naturalHeight; if (!ratio) return; const videoRatio = app.videoMain.videoWidth / app.videoMain.videoHeight; const { p1, p2 } = ann.data; const minX = Math.min(p1.x, p2.x), minY = Math.min(p1.y, p2.y); const maxX = Math.max(p1.x, p2.x), maxY = Math.max(p1.y, p2.y); let newP1, newP2; let newWidth, newHeight; switch (handle) { case 'br': newWidth = Math.max(0.01, pos.x - minX); newHeight = (newWidth * videoRatio) / ratio; newP1 = { x: minX, y: minY }; newP2 = { x: minX + newWidth, y: minY + newHeight }; break; case 'tl': newWidth = Math.max(0.01, maxX - pos.x); newHeight = (newWidth * videoRatio) / ratio; newP2 = { x: maxX, y: maxY }; newP1 = { x: maxX - newWidth, y: maxY - newHeight }; break; case 'tr': newWidth = Math.max(0.01, pos.x - minX); newHeight = (newWidth * videoRatio) / ratio; newP1 = { x: minX, y: maxY - newHeight }; newP2 = { x: minX + newWidth, y: maxY }; break; case 'bl': newWidth = Math.max(0.01, maxX - pos.x); newHeight = (newWidth * videoRatio) / ratio; newP1 = { x: maxX - newWidth, y: minY }; newP2 = { x: maxX, y: minY + newHeight }; break; default: return; } ann.data.p1 = newP1; ann.data.p2 = newP2; } else { const { p1, p2 } = ann.data; const minX = Math.min(p1.x, p2.x), minY = Math.min(p1.y, p2.y), maxX = Math.max(p1.x, p2.x), maxY = Math.max(p1.y, p2.y); switch (handle) { case 'p1': ann.data.p1 = pos; break; case 'p2': ann.data.p2 = pos; break; case 'tl': ann.data.p1 = pos; ann.data.p2 = {x: maxX, y: maxY}; break; case 'br': ann.data.p1 = {x: minX, y: minY}; ann.data.p2 = pos; break; case 'tr': ann.data.p1 = {x: minX, y: pos.y}; ann.data.p2 = {x: pos.x, y: maxY}; break; case 'bl': ann.data.p1 = {x: pos.x, y: minY}; ann.data.p2 = {x: maxX, y: pos.y}; break; } } }
            function video_saveFrame() { if (!app.videoMain.src) return; const tempCanvas = document.createElement('canvas'); tempCanvas.width = app.videoMain.videoWidth; tempCanvas.height = app.videoMain.videoHeight; tempCanvas.getContext('2d').drawImage(app.videoMain, 0, 0, tempCanvas.width, tempCanvas.height); const a = document.createElement('a'); a.href = tempCanvas.toDataURL('image/png'); a.download = `frame_${video_formatTime(app.videoMain.currentTime, true).replace(/:/g, '-')}.png`; a.click(); }
            const video_formatTime = (secs, forFilename = false) => { const s = Math.floor(secs % 60); const m = Math.floor((secs / 60) % 60); const d = forFilename ? '-' : ':'; return `${String(m).padStart(2,'0')}${d}${String(s).padStart(2,'0')}`; };
            const video_getMousePos = (e) => { if (!app.videoMain.videoWidth) return { x: 0, y: 0 }; const canvasRect = app.canvasInteraction.getBoundingClientRect(); const screenX = e.clientX - canvasRect.left; const screenY = e.clientY - canvasRect.top; const videoRect = video_getVideoRect(app.canvasInteraction, app.videoMain); if (videoRect.width === 0) return { x: 0, y: 0 }; const videoLocalX = screenX - videoRect.x; const videoLocalY = screenY - videoRect.y; return { x: Math.max(0, Math.min(1, videoLocalX / videoRect.width)), y: Math.max(0, Math.min(1, videoLocalY / videoRect.height)) }; };
            function video_getVideoRect(canvas, video) { if (!video.videoWidth) return { x: 0, y: 0, width: 0, height: 0 }; const videoRatio = video.videoWidth / video.videoHeight; const canvasRatio = canvas.width / canvas.height; let width, height; if (videoRatio > canvasRatio) { width = canvas.width; height = canvas.width / videoRatio; } else { height = canvas.height; width = canvas.height * videoRatio; } return { x: (canvas.width - width) / 2, y: (canvas.height - height) / 2, width, height }; }
            function video_makeTimeEditable() { const originalTime = app.timeDisplay.textContent; app.timeDisplay.innerHTML = `<input type="text" value="${originalTime}">`; const input = app.timeDisplay.querySelector('input'); input.focus(); input.select(); const save = () => { const rawValue = input.value.replace(/[^0-9]/g, ''); if (rawValue) { let minutes = 0; let seconds = 0; if (rawValue.length <= 2) { seconds = parseInt(rawValue, 10); } else { minutes = parseInt(rawValue.slice(0, -2), 10); seconds = parseInt(rawValue.slice(-2), 10); } const totalSeconds = (minutes * 60) + seconds; video_seekTo(totalSeconds); } app.timeDisplay.textContent = video_formatTime(app.videoMain.currentTime); }; input.addEventListener('blur', save); input.addEventListener('keydown', e => { if (e.key === 'Enter') input.blur(); }); }
            async function video_getBase64FromImage(img) { return new Promise(resolve => { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = img.naturalWidth; canvas.height = img.naturalHeight; ctx.drawImage(img, 0, 0); resolve(canvas.toDataURL('image/jpeg', 0.7)); }); }
            async function video_processLoadedAnnotations(annotations) { const imageAnnotations = annotations.filter(ann => ann.type === 'image' && ann.data.base64); const promises = imageAnnotations.map(ann => { return new Promise((resolve) => { const img = new Image(); img.onload = () => { imageCache.set(ann.data.base64, img); ann.data.imageObject = img; if (ann.data.x && app.videoMain.videoWidth) { const { x, y, width, height } = ann.data; ann.data.p1 = { x: (x - width / 2) / app.videoMain.videoWidth, y: (y - height / 2) / app.videoMain.videoHeight }; ann.data.p2 = { x: (x + width / 2) / app.videoMain.videoWidth, y: (y + height / 2) / app.videoMain.videoHeight }; } resolve(); }; img.onerror = () => { resolve(); }; img.src = ann.data.base64; }); }); await Promise.all(promises); }
            function video_createImageFromBlob(blob) { return new Promise((resolve, reject) => { const url = URL.createObjectURL(blob); const img = new Image(); img.onload = () => { resolve(img); }; img.onerror = (err) => { URL.revokeObjectURL(url); reject(err); }; img.src = url; }); }
            function video_placeImageAnnotation(img) { if (!app.videoMain.videoWidth) return; const MAX_SIZE_PX = 250; let { naturalWidth: width, naturalHeight: height } = img; const videoRect = video_getVideoRect(app.canvasInteraction, app.videoMain); const scale = Math.min(videoRect.width / app.videoMain.videoWidth, videoRect.height / app.videoMain.videoHeight); let scaledWidth = width * scale; let scaledHeight = height * scale; if (scaledWidth > scaledHeight) { if (scaledWidth > MAX_SIZE_PX) { scaledHeight *= MAX_SIZE_PX / scaledWidth; scaledWidth = MAX_SIZE_PX; } } else { if (scaledHeight > MAX_SIZE_PX) { scaledWidth *= MAX_SIZE_PX / scaledHeight; scaledHeight = MAX_SIZE_PX; } } const finalWidthRatio = (scaledWidth / scale) / app.videoMain.videoWidth; const finalHeightRatio = (scaledHeight / scale) / app.videoMain.videoHeight; const centerPos = state.interaction.lastMousePos.x !== 0 || state.interaction.lastMousePos.y !== 0 ? state.interaction.lastMousePos : { x: 0.5, y: 0.5}; const ann = { type: 'image', time: app.videoMain.currentTime, data: { imageObject: img, p1: { x: centerPos.x - finalWidthRatio / 2, y: centerPos.y - finalHeightRatio / 2 }, p2: { x: centerPos.x + finalWidthRatio / 2, y: centerPos.y + finalHeightRatio / 2 } }, completed: false }; video_addAnnotation(ann); }
            function video_loadRefVideo(src, name) { app.videoRef.src = src; app.videoRef.muted = true; app.body.classList.add('ref-video-loaded'); app.videoRefSlot.classList.remove('hidden'); app.refVideoFilename.textContent = name; app.refVideoFilename.classList.remove('hidden'); app.refVideoAddIcon.classList.add('hidden'); app.refVideoRemoveIcon.classList.remove('hidden'); app.videoRef.addEventListener('loadedmetadata', () => { video_seekTo(app.videoMain.currentTime); video_updateTimelineDurations(); }, { once: true }); video_redrawAllCanvases(); }
            function video_removeRefVideo() { app.videoRef.src = ''; app.body.classList.remove('ref-video-loaded'); app.videoRefSlot.classList.add('hidden'); app.refVideoFilename.classList.add('hidden'); app.refVideoAddIcon.classList.remove('hidden'); app.refVideoRemoveIcon.classList.add('hidden'); video_updateTimelineDurations(); video_redrawAllCanvases(); }
            function video_updateTimelineDurations() { const mainDuration = app.videoMain.duration || 0; const refDuration = app.videoRef.duration || 0; const diffEl = document.getElementById('timeline-diff'); if (!isFinite(mainDuration) || refDuration <= 0 || !isFinite(refDuration)) { app.timelineSlider.max = mainDuration || 100; diffEl.style.width = '0%'; return; } const maxDuration = Math.max(mainDuration, refDuration); const minDuration = Math.min(mainDuration, refDuration); app.timelineSlider.max = maxDuration; if (maxDuration > minDuration) { const diffPercent = ((maxDuration - minDuration) / maxDuration) * 100; const startPercent = (minDuration / maxDuration) * 100; diffEl.style.width = `${diffPercent}%`; diffEl.style.left = `${startPercent}%`; } else { diffEl.style.width = '0%'; } }
            async function video_copyImageToClipboard(annotation) { const img = annotation.data.imageObject; if (!img || !('write' in navigator.clipboard)) { throw new Error("Image object not found or Clipboard API not supported."); } const blob = await new Promise(resolve => { const canvas = document.createElement('canvas'); canvas.width = img.naturalWidth; canvas.height = img.naturalHeight; const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0); canvas.toBlob(blob => resolve(blob), 'image/png'); }); if (!blob) throw new Error("Failed to convert image to blob."); await navigator.clipboard.write([ new ClipboardItem({ [blob.type]: blob }) ]); }

            function image_onKeyDown(e) {
                if (e.key === ' ' || e.ctrlKey) {
                    if (e.ctrlKey) {
                        switch (e.key.toLowerCase()) {
                            case 'g': e.preventDefault(); image_rearrangeArtboards(); return;
                            case '0': if (e.altKey) { e.preventDefault(); image_fitAllArtboardsToView(); } else { e.preventDefault(); state.view = { ...state.view, scale: 1, offsetX: 0, offsetY: 0 }; image_updateWorkspaceTransform(); } return;
                            case '=': case '+': e.preventDefault(); image_zoomAtPoint(1.2, app.workspaceContainer.offsetWidth / 2, app.workspaceContainer.offsetHeight / 2); return;
                            case '-': e.preventDefault(); image_zoomAtPoint(1/1.2, app.workspaceContainer.offsetWidth / 2, app.workspaceContainer.offsetHeight / 2); return;
                        }
                    }
                    return;
                }
            }
            
            function image_handleFiles(files) { const imageFiles = files.filter(f => f.type.startsWith('image/')); if (imageFiles.length > 0) { app.dropZone.classList.add('hidden'); imageFiles.forEach(file => { const reader = new FileReader(); reader.onload = e => image_addArtboard(file.name, e.target.result); reader.readAsDataURL(file); }); } }
            function image_addArtboard(name, imageData) { const img = new Image(); img.onload = () => { const { margin, maxRowWidth } = state.layout; if (state.layout.nextX + img.naturalWidth > maxRowWidth && state.artboards.length > 0) { state.layout.nextY += state.layout.rowMaxHeight + margin; state.layout.nextX = margin; state.layout.rowMaxHeight = 0; } const artboard = { id: crypto.randomUUID(), name, imageObject: img, imageData, x: state.layout.nextX, y: state.layout.nextY, width: img.naturalWidth, height: img.naturalHeight, originalWidth: img.naturalWidth, originalHeight: img.naturalHeight, scale: 1, hasTransparency: /\.(png|webp)$/i.test(name) || imageData.startsWith('data:image/png') || imageData.startsWith('data:image/webp'), showGrid: false }; state.artboards.push(artboard); state.layout.nextX += artboard.width + margin; state.layout.rowMaxHeight = Math.max(state.layout.rowMaxHeight, artboard.height); image_renderWorkspace(); markAsChanged(); updateAnnotationList(); }; img.src = imageData; }
            function image_rearrangeArtboards() { if (state.artboards.length === 0) return; const { margin, maxRowWidth } = state.layout; state.layout.nextX = margin; state.layout.nextY = margin; state.layout.rowMaxHeight = 0; state.artboards.sort((a,b) => a.y - b.y || a.x - b.x).forEach(board => { if (state.layout.nextX + board.width > maxRowWidth && state.layout.nextX > margin) { state.layout.nextY += state.layout.rowMaxHeight + margin; state.layout.nextX = margin; state.layout.rowMaxHeight = 0; } board.x = state.layout.nextX; board.y = state.layout.nextY; state.layout.nextX += board.width + margin; state.layout.rowMaxHeight = Math.max(state.layout.rowMaxHeight, board.height); }); image_renderWorkspace(); markAsChanged(); }
            function image_renderWorkspace() { app.workspace.innerHTML = ''; const gridToggleSVG = `<svg viewBox="0 0 16 16" fill="currentColor" width="16" height="16"><path d="M0 0h8v8H0zM8 8h8v8H8z"/></svg>`; const resizerSVG2 = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.0002 12.0001L12.0002 10.0001" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M6.00009 16.0001L16.0001 6.00009" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M14.0002 12.0001L12.0002 14.0001" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>`; state.artboards.forEach(artboard => { const artboardEl = document.createElement('div'); artboardEl.className = 'artboard'; artboardEl.dataset.id = artboard.id; artboardEl.style.left = `${artboard.x}px`; artboardEl.style.top = `${artboard.y}px`; artboardEl.style.width = `${artboard.width}px`; artboardEl.style.height = `${artboard.height}px`; const scaleDisplay = artboard.scale !== 1 ? `<span class="artboard-info">(${Math.round(artboard.scale * 100)}%)</span>` : ''; const dimensionsDisplay = `<span class="artboard-info">(${artboard.originalWidth}x${artboard.originalHeight})</span>`; const tools = `<div class="artboard-header-tools">${artboard.hasTransparency ? `<button class="grid-toggle-btn ${artboard.showGrid ? 'active' : ''}" title="Bật/tắt lưới trong suốt">${gridToggleSVG}</button>` : ''}<button class="artboard-close-btn" title="Xóa Artboard">&times;</button></div>`; artboardEl.innerHTML = `<div class="artboard-header"><div class="artboard-title-container" title="${artboard.name} ${artboard.originalWidth}x${artboard.originalHeight}"><span class="artboard-title">${artboard.name}</span>${dimensionsDisplay}${scaleDisplay}</div>${tools}</div><div class="artboard-content ${artboard.showGrid ? 'transparent-grid' : ''}"><img src="${artboard.imageData}" alt="${artboard.name}"><canvas class="display-canvas"></canvas><canvas class="interaction-canvas"></canvas></div><div class="artboard-resizer" title="Resize (Double-click to reset)">${resizerSVG2}</div>`; artboardEl.querySelector('.artboard-header').addEventListener('mousedown', e => image_onArtboardHeaderMouseDown(e, artboard.id)); artboardEl.querySelector('.artboard-close-btn').addEventListener('click', () => image_removeArtboard(artboard.id)); artboardEl.querySelector('.artboard-resizer').addEventListener('mousedown', e => image_onArtboardResizeMouseDown(e, artboard.id)); artboardEl.querySelector('.artboard-resizer').addEventListener('dblclick', e => { e.stopPropagation(); image_resetArtboardScale(artboard.id); }); if (artboard.hasTransparency) { artboardEl.querySelector('.grid-toggle-btn').addEventListener('click', e => { e.stopPropagation(); artboard.showGrid = !artboard.showGrid; artboardEl.querySelector('.artboard-content').classList.toggle('transparent-grid', artboard.showGrid); e.currentTarget.classList.toggle('active', artboard.showGrid); markAsChanged(); }); } const interactionCanvas = artboardEl.querySelector('.interaction-canvas'); interactionCanvas.addEventListener('mousedown', e => image_onCanvasMouseDown(e, artboard.id)); interactionCanvas.addEventListener('dblclick', e => image_onCanvasDblClick(e, artboard.id)); app.workspace.appendChild(artboardEl); }); image_redrawAllAnnotations(); }
            function image_redrawArtboard(artboardId){ const artboard = state.artboards.find(b => b.id === artboardId); if(!artboard) return; const artboardEl = app.workspace.querySelector(`.artboard[data-id="${artboardId}"]`); if(!artboardEl) return; artboardEl.style.width = `${artboard.width}px`; artboardEl.style.height = `${artboard.height}px`; const scaleDisplay = artboard.scale !== 1 ? `<span class="artboard-info">(${Math.round(artboard.scale * 100)}%)</span>` : ''; const dimensionsDisplay = `<span class="artboard-info">(${artboard.originalWidth}x${artboard.originalHeight})</span>`; const titleContainer = artboardEl.querySelector('.artboard-title-container'); titleContainer.innerHTML = `<span class="artboard-title">${artboard.name}</span>${dimensionsDisplay}${scaleDisplay}`; image_redrawAllAnnotations(); }
            function image_removeArtboard(artboardId) { const commentsOnArtboard = state.annotations.filter(a => a.artboardId === artboardId); if (commentsOnArtboard.length > 0 && !confirm(`Bạn có chắc muốn xóa artboard này và tất cả ${commentsOnArtboard.length} comment trên đó không?`)) { return; } state.annotations = state.annotations.filter(ann => ann.artboardId !== artboardId); state.artboards = state.artboards.filter(board => board.id !== artboardId); image_renderWorkspace(); updateAnnotationList(); markAsChanged(); }
            function image_redrawAllAnnotations() { state.artboards.forEach(artboard => { const artboardEl = app.workspace.querySelector(`.artboard[data-id="${artboard.id}"]`); if (!artboardEl) return; const displayCanvas = artboardEl.querySelector('.display-canvas'); const ctx = displayCanvas.getContext('2d'); displayCanvas.width = artboard.width; displayCanvas.height = artboard.height; artboardEl.querySelector('.interaction-canvas').width = artboard.width; artboardEl.querySelector('.interaction-canvas').height = artboard.height; ctx.clearRect(0, 0, displayCanvas.width, displayCanvas.height); const selectedIds = new Set(state.selectedIndices.map(i => state.annotations[i]?.id)); state.annotations.forEach((ann, index) => { if (ann.artboardId === artboard.id) { const isSelected = state.selectedIndices.includes(index); image_drawShape(ctx, ann, artboard, isSelected); if (isSelected && ann.type !== 'comment' && ann.type !== 'reply') image_drawHandles(ctx, ann, artboard); } }); }); }
            function image_prepareDataForSave() { return { artboards: state.artboards.map(({ id, name, imageData, x, y, width, height, originalWidth, originalHeight, scale, hasTransparency, showGrid }) => ({ id, name, imageData, x, y, width, height, originalWidth, originalHeight, scale, hasTransparency, showGrid })), annotations: state.annotations, layout: state.layout, }; }
            function image_updateWorkspaceTransform() { const { offsetX, offsetY, scale } = state.view; app.workspace.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`; }
            function image_onWorkspaceMouseDown(e) { if (state.spacebarPressed || e.button === 1) { image_startPanning(e); return; } if (e.target.closest('.artboard')) return; if (e.button === 0) { e.preventDefault(); image_startPanning(e); } else { state.selectedIndices = []; updateListSelection(); } }
            function image_onWindowMouseMove(e) { switch(state.interaction.mode) { case 'panning': state.view.offsetX = e.clientX - state.interaction.startPos.x; state.view.offsetY = e.clientY - state.interaction.startPos.y; image_updateWorkspaceTransform(); break; case 'draggingArtboard': image_onArtboardDrag(e); break; case 'resizingArtboard': image_onArtboardResize(e); break; default: image_onCanvasMouseMove(e); break; } }
            function image_onWindowMouseUp(e) { if(['panning', 'draggingArtboard', 'resizingArtboard'].includes(state.interaction.mode)) { if (state.interaction.mode === 'panning') { app.workspaceContainer.classList.remove('panning'); app.body.classList.remove('panning'); } else if (state.interaction.mode === 'draggingArtboard' || state.interaction.mode === 'resizingArtboard') { document.querySelector(`.artboard[data-id="${state.interaction.target.artboardId}"]`)?.classList.remove('dragging'); } state.interaction.mode = 'none'; state.interaction.target = null; } else { image_onCanvasMouseUp(e); state.interaction.mode = 'none'; state.interaction.target = null; }}
            function image_onWorkspaceWheel(e) { e.preventDefault(); const rect = app.workspaceContainer.getBoundingClientRect(); image_zoomAtPoint(e.deltaY < 0 ? 1.1 : 1/1.1, e.clientX - rect.left, e.clientY - rect.top); }
            function image_zoomAtPoint(factor, x, y) { const oldScale = state.view.scale; const newScale = Math.max(state.view.minScale, Math.min(state.view.maxScale, oldScale * factor)); state.view.scale = newScale; state.view.offsetX = x - (x - state.view.offsetX) * (newScale / oldScale); state.view.offsetY = y - (y - state.view.offsetY) * (newScale / oldScale); image_updateWorkspaceTransform(); }
            function image_fitAllArtboardsToView() { if (state.artboards.length === 0) return; const PADDING = 50; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; state.artboards.forEach(b => { minX = Math.min(minX, b.x); minY = Math.min(minY, b.y); maxX = Math.max(maxX, b.x + b.width); maxY = Math.max(maxY, b.y + b.height); }); const totalWidth = maxX - minX; const totalHeight = maxY - minY; if (totalWidth === 0 || totalHeight === 0) return; const container = app.workspaceContainer; const scaleX = (container.offsetWidth - 2 * PADDING) / totalWidth; const scaleY = (container.offsetHeight - 2 * PADDING) / totalHeight; const newScale = Math.min(scaleX, scaleY, 1); state.view.scale = newScale; state.view.offsetX = (container.offsetWidth - totalWidth * newScale) / 2 - minX * newScale; state.view.offsetY = (container.offsetHeight - totalHeight * newScale) / 2 - minY * newScale; image_updateWorkspaceTransform(); }
            function image_onArtboardHeaderMouseDown(e, artboardId) { if (state.spacebarPressed || e.button === 1) { image_startPanning(e); return; } if (e.button !== 0) return; e.stopPropagation(); const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return; const workspaceMousePos = image_getWorkspaceMousePos(e); state.interaction = { mode: 'draggingArtboard', target: { artboardId }, startPos: workspaceMousePos, startOffset: { x: workspaceMousePos.x - artboard.x, y: workspaceMousePos.y - artboard.y } }; e.currentTarget.parentElement.classList.add('dragging'); }
            function image_onArtboardDrag(e) { if (state.interaction.mode !== 'draggingArtboard') return; const { artboardId } = state.interaction.target; const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return; const workspaceMousePos = image_getWorkspaceMousePos(e); artboard.x = workspaceMousePos.x - state.interaction.startOffset.x; artboard.y = workspaceMousePos.y - state.interaction.startOffset.y; const artboardEl = document.querySelector(`.artboard[data-id="${artboardId}"]`); artboardEl.style.left = `${artboard.x}px`; artboardEl.style.top = `${artboard.y}px`; markAsChanged(); }
            function image_onArtboardResizeMouseDown(e, artboardId) { e.stopPropagation(); const artboard = state.artboards.find(b => b.id === artboardId); if(!artboard) return; state.interaction = { mode: 'resizingArtboard', target: { artboardId }, startPos: { x: e.clientX, y: e.clientY }, startWidth: artboard.width, startHeight: artboard.height }; document.querySelector(`.artboard[data-id="${artboardId}"]`).classList.add('dragging'); }
            function image_onArtboardResize(e) { if (state.interaction.mode !== 'resizingArtboard') return; const { artboardId } = state.interaction.target; const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return; const dx = e.clientX - state.interaction.startPos.x; const newWidth = state.interaction.startWidth + (dx / state.view.scale); const aspectRatio = artboard.originalWidth / artboard.originalHeight; artboard.width = Math.max(50, newWidth); artboard.height = artboard.width / aspectRatio; artboard.scale = artboard.width / artboard.originalWidth; image_redrawArtboard(artboardId); markAsChanged(); }
            function image_resetArtboardScale(artboardId) { const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return; artboard.scale = 1; artboard.width = artboard.originalWidth; artboard.height = artboard.originalHeight; image_redrawArtboard(artboardId); markAsChanged(); }
            function image_getWorkspaceMousePos(e) { const rect = app.workspaceContainer.getBoundingClientRect(); return { x: (e.clientX - rect.left - state.view.offsetX) / state.view.scale, y: (e.clientY - rect.top - state.view.offsetY) / state.view.scale }; }
            function image_getMousePosOnArtboard(e, artboard) { const canvasEl = app.workspace.querySelector(`.artboard[data-id="${artboard.id}"] .interaction-canvas`); if (!canvasEl) return {x: 0, y: 0}; const rect = canvasEl.getBoundingClientRect(); return { x: (e.clientX - rect.left) / rect.width, y: (e.clientY - rect.top) / rect.height }; }
            function image_findArtboardAtWorkspacePos(pos) { return state.artboards.slice().reverse().find(b => pos.x >= b.x && pos.x <= b.x + b.width && pos.y >= b.y && pos.y <= b.y + b.height) || null; }
            function image_startPanning(e) { e.preventDefault(); e.stopPropagation(); state.interaction.mode = 'panning'; app.workspaceContainer.classList.add('panning'); if(state.spacebarPressed) app.body.classList.add('panning'); state.interaction.startPos = { x: e.clientX - state.view.offsetX, y: e.clientY - state.view.offsetY }; }
            function image_onCanvasMouseDown(e, artboardId) { if (state.spacebarPressed || e.button === 1) { image_startPanning(e); return; } if (state.interaction.mode !== 'none') return; e.stopPropagation(); const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return; const pos = image_getMousePosOnArtboard(e, artboard); state.interaction.startPos = pos; const hit = image_getHitAnnotation(pos, artboardId); if (hit.handle) { state.interaction.mode = 'resizing'; state.interaction.target = { index: hit.index, handle: hit.handle, artboardId }; } else if (hit.index !== -1) { if (!state.selectedIndices.includes(hit.index)) { state.selectedIndices = [hit.index]; updateListSelection(); } if (e.altKey) { image_copySelectedAnnotations(); image_pasteAnnotations(); } state.interaction.mode = 'dragging'; state.interaction.target = { artboardId }; } else if (state.currentTool) { if (state.currentTool === 'comment') { image_addAnnotation({ type: 'comment', artboardId, data: pos, color: state.activeColor, text: '', completed: false }, true); } else { state.interaction.mode = 'drawing'; state.interaction.target = { artboardId }; } } else { state.selectedIndices = []; updateListSelection(); } }
            function image_onCanvasMouseUp(e) { if (state.interaction.mode === 'none' || ['panning', 'draggingArtboard', 'resizingArtboard'].includes(state.interaction.mode)) return; const { artboardId } = state.interaction.target; if (!artboardId) return; const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return; const { ctxInteraction } = image_getArtboardCanvases(artboardId); if (ctxInteraction) ctxInteraction.clearRect(0, 0, artboard.width, artboard.height); if (state.interaction.mode === 'drawing') { const endPos = image_getMousePosOnArtboard(e, artboard); const p1_abs = { x: state.interaction.startPos.x * artboard.width, y: state.interaction.startPos.y * artboard.height }; const p2_abs = { x: endPos.x * artboard.width, y: endPos.y * artboard.height }; if (Math.hypot(p2_abs.x - p1_abs.x, p2_abs.y - p1_abs.y) > 5) { image_addAnnotation({ type: state.currentTool, artboardId, data: { p1: state.interaction.startPos, p2: endPos }, color: state.activeColor, text: '', completed: false }, true); } } else if (state.interaction.mode === 'dragging') { const workspacePos = image_getWorkspaceMousePos(e); const targetArtboard = image_findArtboardAtWorkspacePos(workspacePos); if (targetArtboard && targetArtboard.id !== artboardId) { state.selectedIndices.forEach(index => { const ann = state.annotations[index]; const oldArtboard = state.artboards.find(b => b.id === ann.artboardId); const newPos = image_getMousePosOnArtboard(e, targetArtboard); ann.artboardId = targetArtboard.id; if (ann.type === 'comment' || ann.type === 'reply') { ann.data = newPos; } else { const absWidth = Math.abs(ann.data.p1.x - ann.data.p2.x) * oldArtboard.width; const absHeight = Math.abs(ann.data.p1.y - ann.data.p2.y) * oldArtboard.height; let newAbsWidth = absWidth; let newAbsHeight = absHeight; if (newAbsWidth > targetArtboard.width || newAbsHeight > targetArtboard.height) { const scale = Math.min(targetArtboard.width / newAbsWidth, targetArtboard.height / newAbsHeight); newAbsWidth *= scale; newAbsHeight *= scale; } ann.data.p1 = { x: newPos.x, y: newPos.y }; ann.data.p2 = { x: newPos.x + (newAbsWidth / targetArtboard.width), y: newPos.y + (newAbsHeight / targetArtboard.height) }; } }); updateAnnotationList(); } image_redrawAllAnnotations(); } }
            function image_onCanvasDblClick(e, artboardId) { e.stopPropagation(); const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return; const pos = image_getMousePosOnArtboard(e, artboard); const hit = image_getHitAnnotation(pos, artboardId); if (hit.index !== -1) { const li = app.annotationList.querySelector(`li[data-id='${state.annotations[hit.index].id}']`); if (li) makeListItemEditable(li, index); } }
            function image_addAnnotation(ann, startEditing = false) { if (['rect', 'circle', 'line', 'arrow', 'reply'].includes(ann.type) && !ann.text) ann.text = ''; ann.user = state.currentUser; ann.id = crypto.randomUUID(); ann.parentId = ann.parentId || null; state.annotations.push(ann); state.undoStack = []; state.redoStack = []; const newIndex = state.annotations.length - 1; state.selectedIndices = [newIndex]; state.lastClickedIndex = newIndex; markAsChanged(); updateAnnotationList(); image_redrawAllAnnotations(); if (startEditing) { const li = app.annotationList.querySelector(`li[data-id='${ann.id}']`); if (li) { li.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); makeListItemEditable(li, newIndex); } } }
            function image_updateAnnotationList() { const listScrollTop = app.annotationList.scrollTop; app.annotationList.innerHTML = ''; const searchTerm = app.searchInput.value.toLowerCase(); const filteredAnnotations = searchTerm ? state.annotations.filter(ann => (ann.text || '').toLowerCase().includes(searchTerm) || (ann.user || '').toLowerCase().includes(searchTerm)) : state.annotations; const grouped = filteredAnnotations.reduce((acc, ann) => { const key = ann.artboardId || 'workspace'; if (!acc[key]) acc[key] = []; acc[key].push(ann); return acc; }, {}); const artboardNameMap = new Map(state.artboards.map(b => [b.id, b.name])); const renderGroup = (groupId, groupName) => { const groupAnnotations = grouped[groupId]; if (!groupAnnotations || groupAnnotations.length === 0) return; const header = document.createElement('li'); header.className = 'group-header'; header.innerHTML = `<span>${groupName}</span><span class="collapse-toggle">▼</span>`; app.annotationList.appendChild(header); const annotationMap = new Map(groupAnnotations.map(ann => [ann.id, ann])); const annotationItems = []; const renderThread = (ann, depth) => { const originalIndex = state.annotations.findIndex(a => a.id === ann.id); if (originalIndex > -1) { const item = image_createAnnotationListItem(ann, originalIndex); if(depth > 0) item.style.marginLeft = `${depth * 20}px`; annotationItems.push(item); app.annotationList.appendChild(item); const children = groupAnnotations.filter(child => child.parentId === ann.id); children.forEach(child => renderThread(child, depth + 1)); } }; groupAnnotations.filter(a => !a.parentId || !annotationMap.has(a.parentId)).forEach(ann => renderThread(ann, 0)); header.addEventListener('click', () => { header.classList.toggle('collapsed'); annotationItems.forEach(item => item.classList.toggle('hidden')); }); }; state.artboards.forEach(board => renderGroup(board.id, board.name)); renderGroup('workspace', 'Chưa gán'); app.annotationList.scrollTop = listScrollTop; }
            function image_createAnnotationListItem(ann, index) { const li = document.createElement('li'); li.dataset.id = ann.id; li.dataset.index = index; li.classList.toggle('selected', state.selectedIndices.includes(index)); li.classList.toggle('completed', ann.completed); li.classList.toggle('reply-item', !!ann.parentId); const contentHtml = ann.text ? `<p class="content">${ann.text.replace(/\n/g, '<br>')}</p>` : ''; const headerToolsHtml = `<button class="icon-btn" title="Xóa"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button><button class="icon-btn" title="Sao chép Text"><svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button><button class="icon-btn" title="Trả lời"><svg viewBox="0 0 24 24"><path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/></svg></button><input type="checkbox" class="complete-checkbox" ${ann.completed ? 'checked' : ''}>`; const typeDisplay = ann.type === 'reply' ? 'reply' : (ann.type === 'comment' ? 'cmt' : ann.type); const userDisplay = ann.user ? ` - <strong>${ann.user}</strong>` : ''; li.innerHTML = `<div class="header"><span class="time">${index + 1}${userDisplay} - ${typeDisplay}</span><div class="header-tools">${headerToolsHtml}</div></div>${contentHtml}`; li.addEventListener('click', e => { if (e.target.closest('.icon-btn')) return; const clickedIndex = parseInt(li.dataset.index, 10); if (e.shiftKey && state.lastClickedIndex !== -1) { const start = Math.min(state.lastClickedIndex, clickedIndex), end = Math.max(state.lastClickedIndex, clickedIndex); state.selectedIndices = Array.from({length: end - start + 1}, (_, i) => start + i); } else if (e.ctrlKey) { const idxInSelection = state.selectedIndices.indexOf(clickedIndex); if (idxInSelection > -1) state.selectedIndices.splice(idxInSelection, 1); else state.selectedIndices.push(clickedIndex); } else { state.selectedIndices = [clickedIndex]; } state.lastClickedIndex = clickedIndex; updateListSelection(); }); li.addEventListener('dblclick', () => makeListItemEditable(li, index)); li.querySelector('.complete-checkbox').addEventListener('click', e => { e.stopPropagation(); ann.completed = e.target.checked; li.classList.toggle('completed', ann.completed); markAsChanged(); image_redrawAllAnnotations(); }); li.querySelector('.icon-btn[title="Xóa"]').addEventListener('click', e => { e.stopPropagation(); deleteAnnotationsByIndices([index]); }); li.querySelector('.icon-btn[title="Sao chép Text"]').addEventListener('click', e => { e.stopPropagation(); if (ann.text) { navigator.clipboard.writeText(ann.text); } }); li.querySelector('.icon-btn[title="Trả lời"]').addEventListener('click', e => { e.stopPropagation(); image_addAnnotation({ type: 'reply', artboardId: ann.artboardId, text: '', completed: false, parentId: ann.id }, true); }); return li; }
            function image_copySelectedAnnotations() { if (state.selectedIndices.length === 0) return; const allIdsToCopy = new Set(); const queue = state.selectedIndices.map(index => state.annotations[index].id); queue.forEach(id => allIdsToCopy.add(id)); const traversalQueue = [...queue]; while (traversalQueue.length > 0) { const parentId = traversalQueue.shift(); const children = state.annotations.filter(ann => ann.parentId === parentId); for (const child of children) { if (!allIdsToCopy.has(child.id)) { allIdsToCopy.add(child.id); traversalQueue.push(child.id); } } } state.clipboard = state.annotations.filter(ann => allIdsToCopy.has(ann.id)).map(ann => JSON.parse(JSON.stringify(ann))); }
            function image_pasteAnnotations() { if (state.clipboard.length === 0) return; const oldIdToNewIdMap = new Map(); const newAnnotations = []; const newIndices = []; state.clipboard.forEach(clipboardAnn => { const newAnn = JSON.parse(JSON.stringify(clipboardAnn)); const newId = crypto.randomUUID(); oldIdToNewIdMap.set(clipboardAnn.id, newId); newAnn.id = newId; newAnnotations.push(newAnn); }); newAnnotations.forEach(newAnn => { if (newAnn.parentId && oldIdToNewIdMap.has(newAnn.parentId)) { newAnn.parentId = oldIdToNewIdMap.get(newAnn.parentId); } else { newAnn.parentId = null; } }); const startingIndex = state.annotations.length; state.annotations.push(...newAnnotations); for (let i = 0; i < newAnnotations.length; i++) { newIndices.push(startingIndex + i); } state.selectedIndices = newIndices; state.lastClickedIndex = newIndices.length > 0 ? newIndices[newIndices.length - 1] : -1; markAsChanged(); updateAnnotationList(); image_redrawAllAnnotations(); const lastNewItem = app.annotationList.querySelector(`li[data-id='${newAnnotations[newAnnotations.length - 1].id}']`); if (lastNewItem) { lastNewItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } }
            const image_getArtboardCanvases = (artboardId) => { const el = app.workspace.querySelector(`.artboard[data-id="${artboardId}"]`); if (!el) return {}; return { displayCanvas: el.querySelector('.display-canvas'), interactionCanvas: el.querySelector('.interaction-canvas'), ctxDisplay: el.querySelector('.display-canvas').getContext('2d'), ctxInteraction: el.querySelector('.interaction-canvas').getContext('2d') }; };
            function image_onCanvasMouseMove(e) { if (state.interaction.mode === 'none' || ['panning', 'draggingArtboard', 'resizingArtboard'].includes(state.interaction.mode)) return; const { artboardId } = state.interaction.target; if (!artboardId) return; const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return; const currentPos = image_getMousePosOnArtboard(e, artboard); const { ctxInteraction } = image_getArtboardCanvases(artboardId); if (!ctxInteraction) return; ctxInteraction.clearRect(0, 0, artboard.width, artboard.height); switch (state.interaction.mode) { case 'drawing': image_drawShape(ctxInteraction, { type: state.currentTool, data: { p1: state.interaction.startPos, p2: currentPos }, color: state.activeColor }, artboard, false, true); break; case 'dragging': const dx = currentPos.x - state.interaction.startPos.x; const dy = currentPos.y - state.interaction.startPos.y; state.selectedIndices.forEach(idx => image_moveAnnotation(idx, dx, dy)); state.interaction.startPos = currentPos; image_redrawAllAnnotations(); markAsChanged(); break; case 'resizing': image_resizeAnnotation(state.interaction.target.index, state.interaction.target.handle, currentPos); image_redrawAllAnnotations(); markAsChanged(); break; } }
            function image_moveAnnotation(index, dx, dy) { const ann = state.annotations[index]; if (ann.type === 'comment' || ann.type === 'reply') { ann.data.x += dx; ann.data.y += dy; } else { ann.data.p1.x += dx; ann.data.p1.y += dy; ann.data.p2.x += dx; ann.data.p2.y += dy; } }
            function image_resizeAnnotation(index, handle, pos) { const ann = state.annotations[index]; const { p1, p2 } = ann.data; if (handle === 'p1') { ann.data.p1 = pos; return; } if (handle === 'p2') { ann.data.p2 = pos; return; } const minX = Math.min(p1.x, p2.x); const minY = Math.min(p1.y, p2.y); const maxX = Math.max(p1.x, p2.x); const maxY = Math.max(p1.y, p2.y); let anchor = { x: 0, y: 0 }; if (handle.includes('t')) { anchor.y = maxY; } else { anchor.y = minY; } if (handle.includes('l')) { anchor.x = maxX; } else { anchor.x = minX; } ann.data.p1 = anchor; ann.data.p2 = pos; }
            function image_getHitAnnotation(pos, artboardId) { let found = { index: -1, handle: null, cursor: 'default' }; const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return found; for (let i = state.annotations.length - 1; i >= 0; i--) { const ann = state.annotations[i]; if (ann.artboardId !== artboardId) continue; if (state.selectedIndices.includes(i) && ann.type !== 'comment' && ann.type !== 'reply') { const handle = image_getHitHandle(pos, ann); if (handle) { return { index: i, handle: handle.name, cursor: handle.cursor }; } } let hit = false; if (ann.type === 'comment') { const iconSizePx = 24, offsetX = -2, offsetY = -22; const normWidth = iconSizePx / artboard.width, normHeight = iconSizePx / artboard.height; const normOffsetX = offsetX / artboard.width, normOffsetY = offsetY / artboard.height; const iconLeft = ann.data.x + normOffsetX, iconTop = ann.data.y + normOffsetY; hit = (pos.x >= iconLeft && pos.x <= iconLeft + normWidth && pos.y >= iconTop && pos.y <= iconTop + normHeight); } else if (ann.type !== 'reply') { const { p1, p2 } = ann.data; const padding = 10 / Math.min(artboard.width, artboard.height); const minX = Math.min(p1.x, p2.x) - padding; const minY = Math.min(p1.y, p2.y) - padding; const maxX = Math.max(p1.x, p2.x) + padding; const maxY = Math.max(p1.y, p2.y) + padding; hit = (pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY); } if (hit) { return { index: i, handle: null, cursor: 'move' }; } } return found; }
            const image_getHandlesFor = (ann) => { const { p1, p2 } = ann.data; if (ann.type === 'line' || ann.type === 'arrow') return [ { name: 'p1', x: p1.x, y: p1.y, cursor: 'pointer' }, { name: 'p2', x: p2.x, y: p2.y, cursor: 'pointer' } ]; const minX = Math.min(p1.x, p2.x), minY = Math.min(p1.y, p2.y); const maxX = Math.max(p1.x, p2.x), maxY = Math.max(p1.y, p2.y); return [ { name: 'tl', x: minX, y: minY, cursor: 'nwse-resize' }, { name: 'tr', x: maxX, y: minY, cursor: 'nesw-resize' }, { name: 'bl', x: minX, y: maxY, cursor: 'nesw-resize' }, { name: 'br', x: maxX, y: maxY, cursor: 'nwse-resize' } ]; };
            const image_getHitHandle = (pos, ann) => { const artboard = state.artboards.find(b => b.id === ann.artboardId); if (!artboard) return null; const handleSizePx = 16; const handleRadiusX = (handleSizePx / artboard.width) / 2; const handleRadiusY = (handleSizePx / artboard.height) / 2; return image_getHandlesFor(ann).find(h => pos.x > h.x - handleRadiusX && pos.x < h.x + handleRadiusX && pos.y > h.y - handleRadiusY && pos.y < h.y + handleRadiusY) || null; }
            function image_drawShape(ctx, ann, artboard, isSelected, isPreview = false) { ctx.save(); const { type, data, color } = ann; ctx.strokeStyle = color; ctx.lineWidth = isSelected ? 4 : 2; if(isPreview) { ctx.setLineDash([6, 3]); ctx.lineWidth = 3; } const denorm = (p) => ({ x: p.x * artboard.width, y: p.y * artboard.height }); ctx.beginPath(); switch (type) { case 'comment': { const pos = denorm(data); const size = 24; ctx.fillStyle = color; const path = new Path2D("M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"); ctx.save(); ctx.translate(pos.x, pos.y); ctx.scale(size / 24, size / 24); ctx.translate(-2, -22); ctx.fill(path); ctx.restore(); if (isSelected) { ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.beginPath(); ctx.arc(pos.x, pos.y, 12, 0, 2 * Math.PI); ctx.fill(); } break; } case 'rect': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); ctx.rect(p1_abs.x, p1_abs.y, p2_abs.x - p1_abs.x, p2_abs.y - p1_abs.y); break; } case 'circle': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); ctx.ellipse(p1_abs.x + (p2_abs.x-p1_abs.x)/2, p1_abs.y + (p2_abs.y-p1_abs.y)/2, Math.abs((p2_abs.x-p1_abs.x)/2), Math.abs((p2_abs.y-p1_abs.y)/2), 0, 0, 2 * Math.PI); break; } case 'line': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); ctx.moveTo(p1_abs.x, p1_abs.y); ctx.lineTo(p2_abs.x, p2_abs.y); break; } case 'arrow': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); const h = 15, dx = p2_abs.x - p1_abs.x, dy = p2_abs.y - p1_abs.y, a = Math.atan2(dy, dx); ctx.moveTo(p1_abs.x, p1_abs.y); ctx.lineTo(p2_abs.x, p2_abs.y); ctx.lineTo(p2_abs.x - h * Math.cos(a - Math.PI / 6), p2_abs.y - h * Math.sin(a - Math.PI / 6)); ctx.moveTo(p2_abs.x, p2_abs.y); ctx.lineTo(p2_abs.x - h * Math.cos(a + Math.PI / 6), p2_abs.y - h * Math.sin(a + Math.PI / 6)); break; } case 'reply': break; } if (type !== 'comment' && type !== 'reply') ctx.stroke(); ctx.restore(); }
            function image_drawHandles(ctx, ann, artboard) { if (ann.type === 'reply') return; ctx.save(); const handles = image_getHandlesFor(ann); ctx.fillStyle = 'white'; ctx.strokeStyle = '#333'; ctx.lineWidth = 1; const handleSize = 10; handles.forEach(h => { const x_abs = h.x * artboard.width; const y_abs = h.y * artboard.height; ctx.fillRect(x_abs - handleSize/2, y_abs - handleSize/2, handleSize, handleSize); ctx.strokeRect(x_abs - handleSize/2, y_abs - handleSize/2, handleSize, handleSize); }); ctx.restore(); }

            init();
        });
    </script>
</body>
</html>