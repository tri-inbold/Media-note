<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media QC v22.5</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
	<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <style>
        /* --- COMBINED AND NORMALIZED CSS --- */
        :root { 
            --bg-color: #2e2e2e; --panel-bg: rgba(40, 40, 40, 0.8); --border-color: rgba(255, 255, 255, 0.2); --text-color: #f0f0f0; --text-color-light: #999; --highlight-color: #00aaff; --input-bg: rgba(0,0,0,0.3); --list-item-bg: rgba(0,0,0,0.2); --list-item-reply-bg: rgba(0,0,0,0.3); --checkbox-border: #555; --icon-btn-color: #999; --icon-btn-hover-color: #fff; --workspace-bg: #202020; --video-slot-bg: #000; --artboard-header-color: rgb(0,0,0,0.5); --button-controler-color: white;
        }
        body.theme-light {
            --bg-color: #f0f2f5; --panel-bg: #ffffff; --border-color: #dee2e6; --text-color: #212529; --text-color-light: #6c757d; --input-bg: #ffffff; --list-item-bg: #ffffff; --list-item-reply-bg: #f1f3f5; --checkbox-border: #adb5bd; --icon-btn-color: #6c757d; --icon-btn-hover-color: #212529; --workspace-bg: #f9fcff; --video-slot-bg: #ffffff; --artboard-header-color: white; --button-controler-color: black;
        }
        body, html { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: var(--workspace-bg); color: var(--text-color); overflow: hidden; height: 100vh; width: 100vw; }
        .hidden { display: none !important; }
        .glass-panel { background: var(--panel-bg); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border: 1px solid var(--border-color);}
        body.theme-light .glass-panel { backdrop-filter: none; -webkit-backdrop-filter: none; box-shadow: 0 2px 10px rgba(0,0,0,0.07); }
        
        #app-container { display: flex; flex-direction: row; height: 100%; width: 100%; }
        #main-content { flex-grow: 1; position: relative; height: 100%; display: flex; flex-direction: column; }
        
        #drop-zone { position: absolute; inset: 20px; border: 2px dashed rgba(173, 181, 189, 0.5); border-radius: 20px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 1.2em; color: var(--text-color-light); z-index: 100; transition: all 0.3s; pointer-events: auto; }
        #drop-zone p { background: var(--panel-bg); padding: 25px 35px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); border: 1px solid var(--border-color); line-height: 1.6; }
        #drop-zone.hidden { pointer-events: none; opacity: 0; }
        body.dragging #drop-zone { border-color: var(--highlight-color); background-color: rgba(0, 170, 255, 0.1); }
        
        #workspace-container { flex-grow: 1; background-color: var(--workspace-bg); cursor: default; overflow: hidden; position: relative; }
        #workspace-container.panning { cursor: grabbing; }
        #workspace-container.hand-tool { cursor: grab; }
        body.spacebar-down, body.spacebar-down .artboard, body.spacebar-down .interaction-canvas { cursor: grab !important; }
        body.spacebar-down.panning, body.spacebar-down.panning .artboard, body.spacebar-down.panning .interaction-canvas { cursor: grabbing !important; }
        #workspace { position: absolute; transform-origin: 0 0; }
        
        .artboard { position: absolute; background-color: var(--panel-bg); border-radius: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); border: 0px solid transparent; overflow: hidden; transition: border-color 0.2s; display: flex; flex-direction: column;}
        .artboard.dragging { z-index: 10; box-shadow: 0 8px 25px rgba(0,0,0,0.3); }
        .artboard.selected { border-color: 1px var(--highlight-color); }
        .artboard.video-missing { border-color: 1px solid orange !important; }
        .artboard.video-missing::after { content: 'Missing Video > Drop to Relink'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.5); color: #fff; padding: 8px 10px; border-radius: 8px; font-size: 14px; pointer-events: none; z-index: 100; }
        .artboard-header { position: relative; width: 100%; height: 30px; background-color: var(--artboard-header-color); display: flex; justify-content: space-between; align-items: center; padding: 0 5px 0 10px; box-sizing: border-box; font-size: 12px; color: var(--text-color); cursor: grab; flex-shrink: 0; }
        .artboard-header:active { cursor: grabbing; }
        .artboard-header-tools { display: flex; align-items: center; }
        .artboard-title-container { flex: 1 1 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 5px; display: flex; align-items: baseline; pointer-events: none; min-width: 0; -webkit-user-select: none; -moz-user-select: none;-ms-user-select: none; user-select: none;}
        .artboard-header-tools button { pointer-events: auto; }
        .artboard-title { text-overflow: ellipsis; overflow: hidden; }
        .artboard-info { color: var(--text-color-light); font-size: 0.9em; padding-left: 8px; }
        .header-icon-btn, .artboard-close-btn { background: none; border: none; color: var(--text-color-light); cursor: pointer; font-size: 1.2em; line-height: 1; padding: 0 5px; transition: color 0.2s, background-color 0.2s; flex-shrink: 0; border-radius: 4px; display:flex; align-items:center; justify-content:center; width:22px; height:22px; }
        .header-icon-btn svg { width: 14px; height: 14px; fill: currentColor; }
        .header-icon-btn:hover, .artboard-close-btn:hover { color: var(--icon-btn-hover-color); background-color: var(--bg-color); }
        .artboard-close-btn { font-size: 1.4em; }
        .artboard-content { position: relative; width: 100%; flex-grow: 1; }
        .artboard-content.transparent-guide { background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px; }
        body.theme-dark .artboard-content.transparent-guide { background-image: linear-gradient(45deg, #444 25%, transparent 25%), linear-gradient(-45deg, #444 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #444 75%), linear-gradient(-45deg, transparent 75%, #444 75%); }
        .artboard img, .artboard video, .artboard iframe { display: block; width: 100%; height: 100%; user-select: none; -webkit-user-drag: none; object-fit: contain; background-color: transparent; position: absolute; top:0; left:0; border: none;}
        .artboard video, .artboard .frame-backup { z-index: 1; }
        .artboard canvas.guide-canvas { z-index: 2; pointer-events: auto; }
        .artboard canvas.display-canvas { z-index: 3; }
        .artboard canvas.interaction-canvas { pointer-events: auto; z-index: 4; }
        .artboard canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;}
        .artboard-resizer { position: absolute; right: 2px; bottom: 2px; width: 16px; height: 16px; cursor: se-resize; z-index: 5; color: rgba(255,255,255,0.5); }
        .artboard-resizer:hover { color: white; }
        .artboard-video-controls { position: relative; width: 100%; background: var(--artboard-header-color); display: flex; align-items: center; padding: 4px 8px; box-sizing: border-box; height: 32px; z-index: 5; flex-shrink: 0; }
        .artboard-video-controls button { background:none; border:none; color: var(--button-controler-color); cursor:pointer; width: 26px; height: 26px; display: flex; align-items: center; justify-content: center; padding:0; font-size: 1em;}
        .artboard-video-controls button svg { width: 18px; height: 18px; fill: currentColor; }
        .vid-timeline-wrapper { position: relative; flex-grow: 1; height: 100%; display: flex; align-items: center;}
        .vid-timeline-bg { position: absolute; left: 0; top: 50%; transform: translateY(-50%); width: 100%; height: 4px; background: rgba(255,255,255,0.3); border-radius: 4px;}
        .vid-timeline-markers { position: absolute; left: 0; top: 0; width: 100%; height: 100%; pointer-events: none;}
        .vid-duration { width: auto; padding: 2px 0 2px 8px; user-select: none; }
		.artboard-video-controls .vid-timeline { flex-grow:1; -webkit-appearance: none; appearance: none; height: 100%; background: transparent; cursor: pointer; position: relative; z-index: 2;}
        .artboard-video-controls .vid-timeline::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 10px; height: 10px; background: var(--button-controler-color); border-radius: 50%; margin-top: -3px; }
		.artboard-video-controls .vid-timeline::-webkit-slider-thumb:hover { transform: scale(1.2); }
		.artboard-video-controls .vid-timeline::-webkit-slider-runnable-track { height: 4px; background: color-mix(in srgb, var(--button-controler-color) 5%, transparent); border-radius: 2px; }
        .time-input { background: transparent; border: none; color: var(--button-controler-color); font-size:13px; margin: 0px 2px 0px 0px; font-variant-numeric: tabular-nums; text-align: center; padding: 2px; width: 60px; border-radius: 3px; }
        .time-input:focus { background: transparent; outline: 1px solid var(--highlight-color); }
        #time-display { width: 80px; font-size: 1em; color: var(--text-color); }
        #time-display:focus { color: var(--text-color); }

        #toolbar-container { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); z-index: 30; }
        #movable-controls { display: flex; gap: 10px; align-items: center; }
        #tools-panel, #help-panel { padding: 6px; border-radius: 8px; display: flex; align-items: center; }
        #tools-panel { padding: 6px 6px 6px 4px; gap: 2px; border: 1px solid var(--border-color); }
        #help-panel { padding: 0; background: none; border: none; display: flex; align-items: center; gap: 8px;}
		#help-panel.simple-mode { display: none; }
        #help-btn { background: var(--panel-bg); border: 1px solid var(--border-color); color: var(--text-color-light); cursor: pointer; display: flex; align-items: center; justify-content: center; padding-top: 2px; height: 24px; width: 24px; border-radius: 50%; font-weight: bold; font-size: 1em; }
        .playback-controls { display: flex; align-items: center; gap: 4px; }
        .tool-btn { width: 28px; height: 28px; border-radius: 8px; border: none; background: transparent; color: var(--text-color-light); cursor: pointer; display: flex; justify-content: center; align-items: center; transition: all 0.2s; padding: 0; }
        .tool-btn:hover { color: var(--text-color); background-color: rgba(255,255,255,0.1); }
        body.theme-light .tool-btn:hover { background-color: rgba(0,0,0,0.05); }
        .tool-btn.active { color: #fff; background-color: var(--highlight-color); }
        body.theme-light .tool-btn.active { color: #fff; }
        .tool-btn svg { width: 18px; height: 18px; fill: currentColor; }
		.tool-btn svg::hover { fill: var(--bg-color); }
        .divider { width: 1px; height: 20px; background: var(--border-color); margin: 0 5px; }
        #color-picker { position: relative; padding-bottom: 5px; }
        #active-color-btn { width: 16px; height: 16px; border-radius: 50%; cursor: pointer; filter: drop-shadow(0px 0px 0.5px grey); padding-bottom: 3px}
        #color-palette-popup { position: absolute; bottom: 170%; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; padding: 8px; border-radius: 8px; background: var(--bg-color); border: 1px solid var(--border-color); z-index: 25; }
        .color-btn { width: 16px; height: 16px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: all 0.2s; }
        .color-btn:hover { transform: scale(1.2); }
        #play-pause-btn, #mute-btn { background: none; border: none; color: var(--text-color); cursor: pointer; padding: 5px; display: flex; align-items: center; }
        #play-pause-btn svg, #mute-btn svg { width: 20px; height: 20px; fill: currentColor; }
        #timeline-wrapper { position: relative; flex-grow: 1; display: flex; align-items: center; height: 25px; }
        #timeline-bg { position: absolute; left: 0; top: 50%; transform: translateY(-50%); height: 5px; border-radius: 5px; pointer-events: none; width: 100%; background: rgba(255, 255, 255, 0.3); }
        body.theme-light #timeline-bg { background: rgba(0,0,0,0.1); }
        #timeline-slider { position: relative; z-index: 1; flex-grow: 1; -webkit-appearance: none; appearance: none; width: 100%; height: 100%; background: transparent !important; border-radius: 5px; outline: none; }
        #timeline-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 2.5px; height: 30px; background: var(--highlight-color); cursor: pointer; border-radius: 0; margin-top: -1px;}
        #timeline-slider::-moz-range-thumb { width: 2.5x; height: 30px; background: var(--highlight-color); cursor: pointer; border-radius: 0;}
        #speed-controls { display: flex; background: rgba(0,0,0,0.2); border-radius: 8px; margin-left: 10px; }
        body.theme-light #speed-controls { background: rgba(0,0,0,0.05); }
        .speed-btn { background: none; border: none; color: var(--text-color-light); padding: 4px 8px; cursor: pointer; font-size: 0.9em;}
        .speed-btn.active { color: #fff; background: var(--text-color-light); border-radius: 8px; }
        body.theme-light .speed-btn.active { color: #fff; }
        
        #zoom-controls { position: relative; }
        #zoom-display-btn { background: transparent; border: none; color: var(--text-color-light); cursor: pointer; font-weight: bold; width: 50px; padding-bottom: 3px; }
        #zoom-dropdown { position: absolute; bottom: 160%; left: 50%; transform: translateX(-50%); background: var(--bg-color); border: 1px solid var(--border-color); border-radius: 8px; list-style: none; padding: 5px 0; margin: 0; min-width: 60px; text-align: center; z-index: 10; }
        #zoom-dropdown li { padding: 5px 10px; cursor: pointer; width: 50px; }
        #zoom-dropdown li:hover { background-color: var(--highlight-color); color: #fff; }
        #movable-controls.simple-mode #zoom-controls { display: none; }

        #right-panel { flex: 0 0 340px; display: flex; flex-direction: column; z-index: 20; background: var(--bg-color); border-left: 1px solid var(--border-color); flex-shrink: 0; transition: flex-basis 0.3s ease; min-width: 0; }
        #right-panel.collapsed { flex-basis: 0 !important; min-width: 0 !important; border: none; }
        #right-panel.collapsed > * { display: none; }
        #list-header { padding: 10px; }
        #search-input { width: 100%; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-color); padding: 8px; box-sizing: border-box; }
        #list-container { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; min-width: 0; }
        #annotation-list { list-style: none; padding: 10px; margin: 0; overflow-y: auto; flex-grow: 1; min-width: 0; }
        #annotation-list.mask-completed li.completed { display: none; }
        #save-btn { display: block; width: calc(100% - 20px); margin: 10px; padding: 12px; border: none; border-radius: 10px; background-color: var(--highlight-color); color: #fff; font-size: 1em; font-weight: bold; cursor: pointer; flex-shrink: 0; transition: background-color 0.3s ease, color 0.3s ease, opacity 0.3s ease; }
        #save-btn.unsaved { background-color: #ffc107; color: #000; }
        #save-btn.saving { background-color: #17a2b8; opacity: 0.7; cursor: default;}
        #annotation-list li { padding: 10px 12px; border-radius: 8px; margin-bottom: 8px; position: relative; background-color: var(--list-item-bg); transition: all 0.2s; cursor: pointer; border: 1px solid var(--border-color); }
        #annotation-list li.selected { box-shadow: 0 0 0 2px var(--highlight-color) inset; border-color: var(--highlight-color);}
        #annotation-list li.completed { opacity: 0.6; }
        #annotation-list li.completed .content, #annotation-list li.completed .annotation-image { text-decoration: line-through; }
        #annotation-list li .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        #annotation-list li .time { font-size: 0.8em; color: var(--text-color-light); }
        #annotation-list li .content { margin: 0; font-size: 0.9em; white-space: pre-wrap; min-height: 1em; word-break: break-word; }
        #annotation-list li .annotation-image { max-width: 100%; border-radius: 4px; margin-top: 5px; display: block; }
        #annotation-list li.reply-item { margin-left: 20px; transform: scale(0.98); }
        #annotation-list .group-header { font-weight: bold; font-size: 0.9em; color: var(--text-color); background-color: var(--list-item-reply-bg); padding: 5px 10px; margin: 15px 0 5px 0; border-radius: 5px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; overflow: hidden;}
        #annotation-list .group-header:first-child { margin-top: 0; }
        #annotation-list .group-header > span:first-child { font-size: 0.8em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1 1 auto; padding-right: 5px; min-width: 0; }
        .collapse-toggle { transition: transform 0.2s; display: inline-block; }
        .group-header.collapsed .collapse-toggle { transform: rotate(-90deg); }
        .header-tools { display: flex; align-items: center; gap: 2px; } 
        .icon-btn { background: transparent; border: none; color: var(--icon-btn-color); cursor: pointer; opacity: 0.7; transition: all 0.2s; display: flex; justify-content: center; align-items: center; width: 20px; height: 20px; padding: 0; }
        .icon-btn:hover { opacity: 1; color: var(--icon-btn-hover-color); }
        .icon-btn svg { width: 12px; height: 12px; fill: currentColor; }
        .complete-checkbox { transform: scale(0.75); }
        #annotation-list li textarea { width: 100%; background: var(--panel-bg); border: none; border-radius: 4px; color: var(--text-color); font-family: inherit; font-size: 1em; resize: none; overflow-y: hidden; box-sizing: border-box; outline: none; }
		#annotation-list li textarea:focus { outline: none; background-color: var(--panel-bg);}
        .complete-checkbox { appearance: none; width: 16px; height: 16px; border: 2px solid var(--checkbox-border); border-radius: 50%; cursor: pointer; transition: all 0.2s; }
        .complete-checkbox:checked { background-color: #28a745; border-color: #28a745; }
        .complete-checkbox:checked::after { content: '\2713'; display: block; text-align: center; color: #fff; font-weight: bold; font-size: 11px; line-height: 13px; }
        #panel-resizer { width: 1px; cursor: col-resize; flex-shrink: 0; background-color: transparent; transition: background-color 0.2s ease; align-self: stretch; z-index: 21; -webkit-touch-callout: none; }
        #panel-resizer:hover { width: 5px; background-color: var(--highlight-color); -webkit-touch-callout: none;}
        #right-panel.collapsed + #panel-resizer { display: none; }

        #help-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 200; display: flex; justify-content: center; align-items: center; }
        body.theme-light #help-modal { background: rgba(0,0,0,0.4); }
        #help-modal .modal-content { position: relative; padding: 20px 30px; width: 975px; border-radius: 15px; max-height: 80vh; overflow-y: auto; }
        #help-modal .shortcuts-guide { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px 25px; }
        #help-modal ul { list-style: none; padding-left: 0; margin-top: 5px; }
        #help-modal li { margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
        #help-modal h3 { margin-top: 0; }
        #help-modal h4 { margin-top: 15px; margin-bottom: 5px; color: var(--text-color-light); border-bottom: 1px solid var(--border-color); padding-bottom: 5px; font-size: 1em; }
        #help-modal strong { color: var(--highlight-color); }
        #modal-close-btn { position: absolute; top: 10px; right: 15px; background: none; border: none; color: var(--text-color); font-size: 28px; cursor: pointer; }
        #help-modal hr { border-color: var(--border-color); }
        .help-actions { display: flex; align-items: center;  justify-content: space-between; flex-wrap: wrap; }
        .help-actions button { background: var(--input-bg); border: 1px solid var(--border-color); color: var(--text-color); border-radius: 5px; padding: 4px 8px; cursor: pointer; }
        .help-actions label { display: flex; align-items: center; gap: 5px; }
        input[type="color"] { background-color: transparent; border: none; width: 17px; height: 17px; padding: 0; cursor: pointer; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 1px solid var(--border-color); border-radius: 50%; }
        #change-user-btn, #theme-selector { background: var(--input-bg); border: 1px solid var(--border-color); color: var(--text-color); border-radius: 5px; padding: 2px 6px; margin-left: 10px; cursor: pointer; }
        #theme-selector {-webkit-appearance: none; appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23f0f0f0'%3E%3Cpath d='M6 9L.5 3h11z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 6px center; padding-right: 20px;}
        body.theme-light #theme-selector { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%231a1a1a'%3E%3Cpath d='M6 9L.5 3h11z'/%3E%3C/svg%3E");}
        #theme-selector option { background: var(--panel-bg); color: var(--text-color); }
        
        #tool-cursor-icon { position: fixed; pointer-events: none; z-index: 9999; transform: translate(12px, 12px); display: flex; align-items: center; justify-content: center; }
        #tool-cursor-icon svg { width: 14px; height: 14px; fill: #ffffff; filter: drop-shadow(0 0 1.5px rgba(0,0,0,0.9)); display: block; }
        #context-menu { position: fixed; z-index: 1000; min-width: 180px; padding: 5px 0; border-radius: 8px; font-size: 14px; }
        .context-menu-item { padding: 8px 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .context-menu-item:hover { background-color: var(--highlight-color); color: #fff; }
        .context-menu-item.disabled { color: var(--text-color-light); cursor: default; }
        .context-menu-item.disabled:hover { background-color: transparent; }
        .context-menu-divider { height: 1px; background-color: var(--border-color); margin: 5px 0; }
        		
        #workspace-guide-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 15; }

        #toolbar-drag-handle { cursor: grab; padding-left: 1px; margin-right: 6px; align-self: stretch; display: flex; align-items: center; justify-content: center; }
        #toolbar-drag-handle::before { content: ''; width: 4px; height: 24px; background-color: var(--text-color-light); border-radius: 2px; opacity: 0.7; }
        #toolbar-drag-handle:active { cursor: grabbing; }
        #toolbar-drag-handle:active::before { opacity: 1; }
        
        #movable-controls.simple-mode #tools-panel .tool-btn:not([data-tool="comment"]):not([data-tool="rect"]):not([data-tool="line"]),
        #movable-controls.simple-mode #tools-panel .divider,
        #movable-controls.simple-mode #tools-panel #color-picker { display: none; }

        .artboard.loading .artboard-content::after {
            content: ''; position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; margin: -20px 0 0 -20px; border: 4px solid var(--border-color); border-top-color: var(--highlight-color); border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .artboard.loading .artboard-content > * { display: none; }
        
        #timeline-panel { display: flex; flex-direction: column; width: 100%; padding: 8px; box-sizing: border-box; background: var(--bg-color); border-top: 1px solid var(--border-color);}
        #master-timeline-controls { width: 100%; }
        .timeline-header { display: flex; align-items: center; gap: 10px; padding: 0 5px; }
        .timeline-title { font-weight: bold; font-size: 0.9em; flex-shrink: 0; color: var(--text-color-light); margin-right: 10px; }
        #master-timeline-ruler { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        #ocr-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); cursor: crosshair; z-index: 1000; }
        #ocr-selection-box { position: fixed; border: 2px solid var(--highlight-color); background: rgba(0, 170, 255, 0.2); z-index: 1001; pointer-events: none;}
        #ocr-result-box { position: fixed; z-index: 1002; background: var(--panel-bg); border: 1px solid var(--border-color); box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 10px; min-width: 300px; max-width: 500px; display: flex; flex-direction: column; gap: 8px; backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); }
        #ocr-result-box .header { display: flex; justify-content: space-between; align-items: center; cursor: grab; padding-bottom: 8px; }
        #ocr-result-box .header:active { cursor: grabbing; }
        #ocr-result-box .header span { font-size: 1em; font-weight: bold; color: var(--text-color-light); }
        #ocr-result-box .header .close-btn { background: none; border: none; color: var(--text-color-light); font-size: 1.4em; cursor: pointer; padding: 0 5px; line-height: 1; }
        #ocr-result-box textarea { width: 100%; min-height: 100px; resize: vertical; background: var(--input-bg); color: var(--text-color); font-family: inherit; box-sizing: border-box; border: 0px; }
        #ocr-result-box .footer { display: flex; justify-content: space-between; align-items: center; }
        #ocr-result-box .footer .status { font-size: 0.8em; color: var(--text-color-light); }
        #ocr-result-box .footer .copy-btn { background: var(--input-bg); border: 1px solid var(--border-color); color: var(--text-color); border-radius: 5px; padding: 4px 8px; cursor: pointer; }
        
        #ocr-result-box .qr-result { padding: 10px 5px; font-size: 0.9em; color: var(--text-color-light); min-height: 100px; box-sizing: border-box; line-height: 1.5; }
        #ocr-result-box .qr-result a { color: var(--highlight-color); text-decoration: none; word-break: break-all; font-weight: bold; }
        #ocr-result-box .qr-result a:hover { text-decoration: underline; }
		
        #annotation-popup { position: fixed; z-index: 999; background: var(--panel-bg); border: 1px solid var(--border-color); box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 10px 12px; width: 280px; backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); transform: translate(15px, 15px); }
        #annotation-popup .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        #annotation-popup .time { font-size: 0.8em; color: var(--text-color-light); }
        #annotation-popup .header-tools { display: flex; align-items: center; gap: 2px; }
        #annotation-popup .content { margin: 0; font-size: 0.9em; white-space: pre-wrap; word-break: break-word; min-height: 1em; }
        #annotation-popup textarea { width: 100%; background: var(--input-bg); border: none; border-radius: 4px; color: var(--text-color); font-family: inherit; font-size: 1em; resize: none; overflow-y: hidden; box-sizing: border-box; outline: none; }
    </style>
</head>
<body class="theme-dark">
    <input type="file" id="file-input" accept="video/*,image/*,.gif" style="display: none;" multiple>
    <input type="file" id="image-tool-input" accept="image/*" style="display:none;">
    <a id="frame-download-link" class="hidden"></a>
    
    <div id="app-container">
        <div id="main-content">
            <div id="drop-zone">
                <p style="-webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; pointer-events: none; ">Drag & drop Video, Image files here<br>Or double-click / Ctrl+D to select files</p>
            </div>

            <div id="workspace-container" class="hidden">
                <div id="workspace"></div>
                <canvas id="workspace-guide-canvas"></canvas>
            </div>

            <div id="toolbar-container" class="hidden">
                <div id="movable-controls">
                    <div id="tools-panel" class="glass-panel">
                        <div id="toolbar-drag-handle" title="Hold to move. Double-click to toggle mode. Click to reset position."></div>
                        <button id="select-pan-btn" class="tool-btn" data-tool="select" title="Select (V) / Pan (H)">
                            <svg id="select-tool-icon" viewBox="0 0 24 24" style="width: 20px; height: 20px;"><path d="M12.9,12.5l2.7,7.3-2.4.9-2.7-7.3-3.6,2.7,1.3-12.8,9.2,9-4.5.2h0Z"/></svg>
                            <svg id="pan-tool-icon" class="hidden" viewBox="0 0 24 24" style="width: 20px; height: 20px;"><path d="M12,21.1c-4.3,0-7.8-3.5-7.8-7.8v-1.8c0-1.3,1.1-2.4,2.4-2.4s.2,0,.4,0v-3.1c0-1.3,1.1-2.4,2.4-2.4s.5,0,.8.1c.4-.6,1.1-1,1.9-1s1.5.4,1.9,1c.2,0,.5-.1.8-.1,1.3,0,2.4,1.1,2.4,2.4v.4c.1,0,.2,0,.4,0,1.3,0,2.4,1.1,2.4,2.4v4.5c0,4.3-3.5,7.8-7.8,7.8ZM6.6,11.2c-.2,0-.4.2-.4.4v1.8c0,3.2,2.6,5.8,5.8,5.8s5.8-2.6,5.8-5.8v-4.5c0-.2-.2-.4-.4-.4s-.4.2-.4.4v2.3c0,.6-.4,1-1,1s-1-.4-1-1v-5c0-.2-.2-.4-.4-.4s-.4.2-.4.4v5c0,.6-.4,1-1,1s-1-.4-1-1v-5.9c0-.2-.2-.4-.4-.4s-.4.2-.4.4v5.9c0,.6-.4,1-1,1s-1-.4-1-1v-5c0-.2-.2-.4-.4-.4s-.4.2-.4.4v7.7c0,.6-.4,1-1,1s-1-.4-1-1v-2.3c0-.2-.2-.4-.4-.4Z"/></svg>
                        </button>
                        <button class="tool-btn" data-tool="comment" title="Comment (C)"><svg viewBox="0 0 24 24"><path d="M3,12v9h9c5,0,9-4,9-9h0c0-5-4-9-9-9h0C7,3,3,7,3,12ZM12,19h-7v-7c0-3.9,3.1-7,7-7h0c3.9,0,7,3.1,7,7h0c0,3.9-3.1,7-7,7Z"/><rect x="8" y="13" width="7.4" height="2"/><rect x="8" y="9" width="7.4" height="2"/></svg></button>
                        <button class="tool-btn" data-tool="rect" title="Rec (R)"><svg viewBox="0 0 24 24"><path d="M3 3v18h18V3H3zm16 16H5V5h14v14z"/></svg></button>
                        <button class="tool-btn" data-tool="circle" title="Circle (O)"><svg viewBox="0 0 24 24"><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg></button>
                        <button class="tool-btn" data-tool="line" title="Line (L)"><svg viewBox="0 0 24 24"><path d="M21 11H3v2h18v-2z"/></svg></button>
                        <button class="tool-btn" data-tool="arrow" title="Arrow (Shift L)"><svg viewBox="0 0 24 24"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8-8-8z"/></svg></button>
                        <button class="tool-btn" data-tool="image" title="Image (I)"><svg viewBox="0 0 24 24"><path d="M3,3v18h18V3H3ZM19,5v8.5l-3-4.6-11,7.6V5h14ZM5,19l10.5-7.2,3.5,5.4v1.8H5Z"/><path d="M8.9,11.8c1.6,0,2.9-1.3,2.9-2.9s-1.3-2.9-2.9-2.9-2.9,1.3-2.9,2.9,1.3,2.9,2.9,2.9ZM8.9,8.1c.5,0,.9.4.9.9s-.4.9-.9.9-.9-.4-.9-.9.4-.9.9-.9Z"/></svg></button>
                        <button class="tool-btn" data-tool="ocr" title="Scan (S)"><svg viewBox="0 0 24 24"><polygon points="5 15.9 3 15.9 3 20 7.1 20 7.1 18 5 18 5 15.9"/><polygon points="16.9 4 16.9 6 19 6 19 8.1 21 8.1 21 4 16.9 4"/><polygon points="19 18 16.9 18 16.9 20 21 20 21 15.9 19 15.9 19 18"/><polygon points="5 6 7.1 6 7.1 4 3 4 3 8.1 5 8.1 5 6"/><rect x="3" y="11" width="18" height="2"/></svg></button>
                        <div class="divider"></div>
                        <div id="color-picker">
                            <button id="active-color-btn" class="color-btn"></button>
                            <div id="color-palette-popup" class="hidden">
                                <button class="color-btn" data-color="#FFFFFF" style="background-color: #FFFFFF;"></button>
                                <button class="color-btn" data-color="#2D2D2D" style="background-color: #2D2D2D;"></button>
                                <button class="color-btn" data-color="#E53935" style="background-color: #E53935;"></button>
                                <button class="color-btn" data-color="#1E88E5" style="background-color: #1E88E5;"></button>
                                <button class="color-btn" data-color="#43A047" style="background-color: #43A047;"></button>
                                <button class="color-btn" data-color="#FDD835" style="background-color: #FDD835;"></button>
                                <button class="color-btn" data-color="#BDBDBD" style="background-color: #BDBDBD;"></button>
                            </div>
                        </div>
						<div id="zoom-controls">
                            <button id="zoom-display-btn">100%</button>
                            <ul id="zoom-dropdown" class="hidden">
                                <li data-zoom="4">400%</li>
                                <li data-zoom="2">200%</li>
                                <li data-zoom="1.5">150%</li>
                                <li data-zoom="1">100%</li>
                                <li data-zoom="0.75">75%</li>
                                <li data-zoom="0.5">50%</li>
                                <li data-zoom="0.25">25%</li>
                            </ul>
                        </div>
                    </div>
                     <div id="help-panel">
                        <button id="help-btn" title="Help & Shortcuts">?</button>
                    </div>
                </div>
            </div>
            
            <div id="timeline-panel" class="hidden">
                <div id="master-timeline-controls">
                    <div class="timeline-header">
                        <span class="timeline-title">Master Timeline</span>
                        <div class="playback-controls">
                            <button id="play-pause-btn" title="Play/Pause (Spacebar/Ctrl+Spacebar)"><svg id="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg><svg id="pause-icon" class="hidden" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg></button>
                            <button id="mute-btn" title="Mute/Unmute (M/Ctrl+M)"><svg id="unmute-icon" class="hidden" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg><svg id="mute-icon" viewBox="0 0 24 24"><path d="M19,12c0,.9-.2,1.8-.5,2.6l1.5,1.5c.7-1.2,1-2.6,1-4.1,0-4.3-3-7.9-7-8.8v2.1c2.9.9,5,3.5,5,6.7Z"/><path d="M16.5,12c0-1.8-1-3.3-2.5-4v2.1l2.5,2.5v-.6Z"/><path d="M4.3,3l-1.3,1.3,4.7,4.7H3v6h4l5,5v-6.7l4.2,4.2c-.7.5-1.4.9-2.2,1.2v2.1c1.4-.3,2.6-1,3.7-1.8l2,2,1.3-1.3-9-9L4.3,3Z"/><polygon points="12 4 9.9 6.1 12 8.1 12 4"/></svg></button>
                            <div id="speed-controls">
                                <button class="speed-btn" data-speed="0.5">0.5x</button>
                                <button class="speed-btn active" data-speed="1">1x</button>
                                <button class="speed-btn" data-speed="2">2x</button>
                            </div>
                        </div>
                        <input type="text" id="time-display" class="time-input" value="00:00:00">
                        <div id="timeline-wrapper">
                            <div id="timeline-bg"></div>
                            <canvas id="master-timeline-ruler"></canvas>
                            <input type="range" id="timeline-slider" value="0" step="0.01">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="panel-resizer" title="Double-click to toggle panel. Ctrl+H"></div>

        <div id="right-panel" class="hidden">
            <div id="list-header">
                <input type="search" id="search-input" placeholder="Search...">
            </div>
            <div id="list-container"><ul id="annotation-list"></ul><button id="save-btn">Save HTML File</button></div>
        </div>
    </div>

    <div id="help-modal" class="hidden">
        <div class="modal-content glass-panel">
            <button id="modal-close-btn">&times;</button>
            <h3>Shortcuts & Help</h3>
            <div class="shortcuts-guide">
                <div>
                    <h4><strong>General</strong></h4>
                    <ul>
                        <li>Pan tool (hand tool)<span>H</span></li>
						<li>Comment tool<span>Q</span></li>
						<li>Rectangle tool<span>R</span></li>
						<li>Circle tool<span>O</span></li>
						<li>Line tool<span>L</span></li>
						<li>Arrow tool<span>Shift + L</span></li>
						<li>Image tool<span>I</span></li>
						<li>Scan tool<span>S</span></li>
                        <li>Add Files<span>Ctrl + D</span></li>
                        <li>Save (as) File</strong><span>Ctrl + (Shift) + S</span></li>
                        <li>Package Project (.zip)<span>Ctrl+Alt+Shift+P</span></li>
                    </ul>
                </div>
                <div>
                    <h4><strong>Workspace & Guide</strong></h4>
                    <ul>
                        <li>Pan<span>Space + Drag</span></li>
						<li>Pan<span>Hold right click</span></li>
						<li>Pan<span>Middle click</span></li>
						<li>Show/hide Comment Panel<span>Ctrl + H</span></li>
						<li>Close Selected Artboar<span>Ctrl + W</span></li>
                        <li>Zoom In / Out<span>Ctrl+Scroll/Mouse croll</span></li>
                        <li>Fit Artboard to View<span>Ctrl + 1</span></li>
                        <li>Reset View<span>Ctrl + 0</span></li>
                        <li>Fit All Artboards<span>Ctrl + Alt + 0</span></li>
                        <li>Arrange Artboards<span>Ctrl + G</span></li>
                        <li>Show/Hide Guides<span>Ctrl + ;</span></li>
                        <li>Lock/Unlock Guides<span>Ctrl + Shift + ;</span></li>
                    </ul>
                </div>
                 <div>
                    <h4><strong>Video Artboard</strong></h4>
                    <ul>
					   <li>Jump Between Comments<span>Alt + ←/→</span></li>
                       <li>Play/Pause Selected<span>Spacebar</span></li>
                       <li>Play/Pause All<span>Ctrl + Spacebar</span></li>
                       <li>Mute Selected<span>M</span></li>
					   <li>Mute All<span>Ctrl+M</span></li>
                       <li>Previous / Next Frame<span>←/→</span></li>
                       <li>Jump 10 Frames<span>Shift + ←/→</span></li>
                       <li>Go to Start / End of Video<span>↑/↓</span></li>
                       <li>Apply to All Videos<span>Ctrl+Arrow</span></li>
                   </ul>
                </div>
            </div>
            <hr>
            <div class="help-actions">
                <span>User:<span id="current-user-display"></span> <button id="change-user-btn">Edit</button></span>
                 <label>Background color:<input type="color" id="artboard-bg-color-picker" title="Artboard Background Color"></label>
                 <label>Guide color:<input type="color" id="guide-color-picker" title="Guide Color"></label>
                <span>Theme: 
                    <select id="theme-selector">
                        <option value="system">System</option>
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                    </select>
                </span>
                <span id="extra-settings" style="display: flex; align-items: center; gap: 10px;">
                    <button id="clean-cache-btn">Clean Cache</button>
                </span>
            </div>
        </div>
    </div>
    
    <div id="tool-cursor-icon" class="hidden"></div>
    <div id="context-menu" class="hidden glass-panel"></div>
	<div id="annotation-popup" class="hidden"></div>

    <script id="app-data" type="application/json"></script>
    <script src="https://cdn.jsdelivr.net/npm/gifler@0.1.0/gifler.min.js"></script>
    <script>
        window.addEventListener('load', () => {
            const app = {
                body: document.body,
                fileInput: document.getElementById('file-input'),
                imageToolInput: document.getElementById('image-tool-input'),
                frameDownloadLink: document.getElementById('frame-download-link'),
                dropZone: document.getElementById('drop-zone'),
                mainContent: document.getElementById('main-content'),
                workspaceContainer: document.getElementById('workspace-container'),
                workspace: document.getElementById('workspace'),
                workspaceGuideCanvas: document.getElementById('workspace-guide-canvas'),
                toolbarContainer: document.getElementById('toolbar-container'),
                movableControls: document.getElementById('movable-controls'),
                rightPanel: document.getElementById('right-panel'),
                panelResizer: document.getElementById('panel-resizer'),
                annotationList: document.getElementById('annotation-list'),
                searchInput: document.getElementById('search-input'),
                listHeader: document.getElementById('list-header'),
                listContainer: document.getElementById('list-container'),
                saveBtn: document.getElementById('save-btn'),
                timelinePanel: document.getElementById('timeline-panel'),
                timelineSlider: document.getElementById('timeline-slider'),
                timeDisplay: document.getElementById('time-display'),
                playPauseBtn: document.getElementById('play-pause-btn'),
                playIcon: document.getElementById('play-icon'),
                pauseIcon: document.getElementById('pause-icon'),
                toolCursorIcon: document.getElementById('tool-cursor-icon'),
                contextMenu: document.getElementById('context-menu'),
                masterTimelineRuler: document.getElementById('master-timeline-ruler'),
                annotationPopup: null,
            };

            const FRAME_RATE = 30;
            const MUTE_ICON_SVG = `<svg viewBox="0 0 24 24"><path d="M19,12c0,.9-.2,1.8-.5,2.6l1.5,1.5c.7-1.2,1-2.6,1-4.1,0-4.3-3-7.9-7-8.8v2.1c2.9.9,5,3.5,5,6.7Z"/><path d="M16.5,12c0-1.8-1-3.3-2.5-4v2.1l2.5,2.5v-.6Z"/><path d="M4.3,3l-1.3,1.3,4.7,4.7H3v6h4l5,5v-6.7l4.2,4.2c-.7.5-1.4.9-2.2,1.2v2.1c1.4-.3,2.6-1,3.7-1.8l2,2,1.3-1.3-9-9L4.3,3Z"/><polygon points="12 4 9.9 6.1 12 8.1 12 4"/></svg>`;
            const UNMUTE_ICON_SVG = `<svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>`;

            let state = {};
            let imageAnnotationCache = new Map();
            let historyManager;
            let autoSaveTimeout;
            let dragHandleClicks = { count: 0, time: 0 };
            
            let tesseractWorker = null;
            let tesseractReady = false;
            let ocrSelectionActive = false;
            let ocrStartPos = null;

            function resetState() {
                state = {
                    annotations: [], artboards: [], currentTool: 'select', activeColor: '#E53935',
                    pendingImageData: { data: null, width: 0, height: 0 },
                    selectedAnnotationIndices: [], selectedArtboardIds: [], lastClickedAnnIndex: -1,
                    currentFileHandle: null, hasUnsavedChanges: false,
                    currentUser: null, clipboard: [],
                    interaction: { mode: 'none', target: null, startPos: { x: 0, y: 0 }, startWorkspacePos: {x:0, y:0}, startData: new Map(), didDrag: false },
                    view: { scale: 1, offsetX: 0, offsetY: 0, minScale: 0.1, maxScale: 10 },
                    layout: { nextX: 50, nextY: 50, rowMaxHeight: 0, margin: 50, maxRowWidth: 4000, isPanelCollapsed: false, artboardBgColor: '#ffffff' },
                    spacebarPressed: false, isGlobalMuted: true, areVideosInSync: true,
                    guides: { visible: true, locked: false, color: '#00FFFF', workspace: [], artboard: {} },
                    toolbar: { x: 0, y: 0, isSimple: false, isDefault: true }
                };
                historyManager = createHistoryManager();
                imageAnnotationCache.clear();
            }

			function toggleSimpleMode() {
                toggleRightPanel();

                const isPanelCollapsed = state.layout.isPanelCollapsed;

                state.toolbar.isSimple = isPanelCollapsed;
                applyToolbarState();

                if (isPanelCollapsed) {
                    app.timelinePanel.classList.add('hidden');
                } else {
                    global_updateTimeline();
                }
            }
			
            async function initTesseract() {
                const ocrStatusContainer = document.getElementById('extra-settings');
                const ocrStatus = document.createElement('span');
                ocrStatus.id = 'ocr-status';
                ocrStatus.textContent = '◷';
                ocrStatus.title = 'OCR Engine Loading...';
                ocrStatus.style.cssText = 'font-size: 0.8em; color: var(--text-color-light); user-select: none;';
                ocrStatusContainer.appendChild(ocrStatus);

                if (!window.Tesseract) {
                    ocrStatus.textContent = 'OCR Failed';
                    ocrStatus.title = 'OCR Engine failed to load.';
                    console.error('Tesseract.js script not loaded.');
                    return;
                }

                const checkTesseract = setInterval(() => {
                    if (window.Tesseract) {
                        tesseractReady = true;
                        ocrStatus.textContent = 'OCR English';
                        ocrStatus.title = 'OCR Engine Ready';
                        clearInterval(checkTesseract);
                    }
                }, 100);
            }

            function init() {
                resetState();
                promptForUser();
                initTheme();
                initTesseract();
                autoLoadData();
                selectTool('select');

                app.annotationPopup = document.getElementById('annotation-popup');
                app.annotationPopup.addEventListener('dblclick', (e) => {
                    if (state.selectedAnnotationIndices.length === 1 && !e.target.closest('.header-tools, .complete-checkbox')) {
                        updateAnnotationPopup(state.selectedAnnotationIndices[0]);
                    }
                });

                app.mainContent.addEventListener('dblclick', (e) => { if (e.target === app.dropZone || e.target === app.workspaceContainer) app.fileInput.click(); });
                window.addEventListener('dragover', e => { e.preventDefault(); document.body.classList.add('dragging'); });
                window.addEventListener('dragleave', e => { if (e.relatedTarget === null) document.body.classList.remove('dragging'); });
                window.addEventListener('drop', handleDrop);
                app.fileInput.addEventListener('change', (e) => handleFiles(Array.from(e.target.files)));
                app.imageToolInput.addEventListener('change', handleImageToolFile);
                window.addEventListener('paste', handlePaste);
                window.addEventListener('keydown', onKeyDown);
                window.addEventListener('keyup', onKeyUp);
                
                app.toolbarContainer.addEventListener('contextmenu', e => e.preventDefault());
                app.timelinePanel.addEventListener('contextmenu', e => e.preventDefault());
                app.contextMenu.addEventListener('contextmenu', e => e.preventDefault());
                app.listHeader.addEventListener('contextmenu', e => e.preventDefault());
                app.searchInput.addEventListener('contextmenu', onSearchInputContextMenu);
                
                app.workspaceContainer.addEventListener('mousedown', onWorkspaceMouseDown);
                window.addEventListener('mousemove', onWindowMouseMove);
                window.addEventListener('mouseup', onWindowMouseUp);
                app.workspaceContainer.addEventListener('wheel', onWorkspaceWheel, { passive: false });
                
                window.addEventListener('mousemove', (e) => { if (!app.toolCursorIcon.classList.contains('hidden')) { app.toolCursorIcon.style.left = `${e.clientX}px`; app.toolCursorIcon.style.top = `${e.clientY}px`; } });
                app.workspaceContainer.addEventListener('mousemove', updateCursorOnMouseMove);

                document.querySelectorAll('.tool-btn').forEach(b => {
                    if (b.id !== 'select-pan-btn') {
                        b.addEventListener('click', () => selectTool(b.dataset.tool));
                    }
                });
                document.getElementById('select-pan-btn').addEventListener('click', toggleSelectPanTool);

                document.getElementById('active-color-btn').addEventListener('click', (e) => { e.stopPropagation(); toggleColorPalette(); });
                document.querySelectorAll('#color-palette-popup .color-btn').forEach(b => b.addEventListener('click', (e) => { e.stopPropagation(); selectColor(b); }));
                selectColor(document.querySelector('#color-palette-popup .color-btn[data-color="#E53935"]'));
                
                app.saveBtn.addEventListener('click', saveState);
                app.saveBtn.addEventListener('contextmenu', onSaveButtonContextMenu);
                app.searchInput.addEventListener('input', () => updateAnnotationList());
                app.annotationList.addEventListener('scroll', drawAnnotationConnectorLines);
                app.listContainer.addEventListener('click', (e) => { if (e.target === app.listContainer || e.target === app.annotationList) { state.selectedAnnotationIndices = []; state.lastClickedAnnIndex = -1; updateListSelection(); } });
                app.panelResizer.addEventListener('mousedown', initPanelResize);
                app.panelResizer.addEventListener('dblclick', toggleRightPanel);
                app.panelResizer.addEventListener('contextmenu', e => e.preventDefault());

                app.playPauseBtn.addEventListener('click', () => global_togglePlayPause(false));
                document.getElementById('mute-btn').addEventListener('click', global_toggleMute);
                document.querySelectorAll('.speed-btn').forEach(btn => btn.addEventListener('click', () => global_setPlaybackSpeed(parseFloat(btn.dataset.speed))));
                
                initTimeInput(app.timeDisplay, () => app.timelineSlider.valueAsNumber, global_seekTo);

                document.getElementById('help-btn').addEventListener('click', () => document.getElementById('help-modal').classList.remove('hidden'));
                document.getElementById('modal-close-btn').addEventListener('click', () => document.getElementById('help-modal').classList.add('hidden'));
                document.getElementById('change-user-btn').addEventListener('click', changeUser);
                document.getElementById('clean-cache-btn').addEventListener('click', cleanCache);
                
                const artboardBgColorPicker = document.getElementById('artboard-bg-color-picker');
                artboardBgColorPicker.addEventListener('input', (e) => changeArtboardBg(e.target.value));
                artboardBgColorPicker.addEventListener('change', (e) => { changeArtboardBg(e.target.value, true); });

                const guideColorPicker = document.getElementById('guide-color-picker');
                guideColorPicker.addEventListener('input', (e) => changeGuideColor(e.target.value));
                guideColorPicker.addEventListener('change', (e) => { changeGuideColor(e.target.value, true); });
                
                document.getElementById('zoom-display-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    document.getElementById('zoom-dropdown').classList.toggle('hidden');
                });
                document.querySelectorAll('#zoom-dropdown li').forEach(item => {
                    item.addEventListener('click', () => {
                        const newScale = parseFloat(item.dataset.zoom);
                        setZoom(newScale);
                    });
                });

                window.addEventListener('click', (e) => { 
                    if (!e.target.closest('#color-picker')) document.getElementById('color-palette-popup').classList.add('hidden'); 
                    if (!e.target.closest('#zoom-controls')) document.getElementById('zoom-dropdown').classList.add('hidden');
                    hideContextMenu(); 
                });
                
                app.workspaceContainer.addEventListener('contextmenu', onWorkspaceContextMenu);
                app.annotationList.addEventListener('contextmenu', onAnnotationListContextMenu);

                document.getElementById('toolbar-drag-handle').addEventListener('mousedown', onToolbarDragStart);

                new ResizeObserver(drawMasterRuler).observe(app.timelinePanel);
                new ResizeObserver(drawAnnotationConnectorLines).observe(app.workspaceContainer);


                updateWorkspaceTransform();
                applyToolbarState();
                requestAnimationFrame(masterTimelineUpdater);
            }
            
            function cleanCache() {
                if (confirm('Are you sure you want to clean the cache? This will remove saved user and theme preferences.')) {
                    localStorage.removeItem('qcToolUser');
                    localStorage.removeItem('qcToolTheme');
                    alert('Cache cleaned. The page will now reload.');
                    location.reload();
                }
            }

            async function autoLoadData() {
                const dataScript = document.getElementById('app-data');
                if (!dataScript || !dataScript.textContent.trim()) return;
                try {
                    const data = JSON.parse(dataScript.textContent.trim());
                    if (!data.artboards || !data.annotations) return;

                    resetState();
                    promptForUser();
                    app.dropZone.classList.add('hidden');
                    app.workspaceContainer.classList.remove('hidden');
                    app.toolbarContainer.classList.remove('hidden');
                    app.rightPanel.classList.remove('hidden');
                    
                    state.annotations = data.annotations || [];
                    state.artboards = data.artboards || [];
                    if(data.layout) Object.assign(state.layout, data.layout);
                    if(data.guides) Object.assign(state.guides, data.guides);
                    if(data.toolbar) Object.assign(state.toolbar, data.toolbar);

                    document.getElementById('artboard-bg-color-picker').value = state.layout.artboardBgColor;
                    document.getElementById('guide-color-picker').value = state.guides.color;
                    
                    applyToolbarState();
                    applyRightPanelState();
                    renderWorkspace(); 
                    applyArtboardBackgroundColor();
                    updateAnnotationList();
                    updateSaveButtonState();
                    global_updateTimeline();

                } catch (err) { console.error("Error auto-loading embedded data:", err); alert('Error loading embedded data. Please ensure any video files are in the same directory as the HTML file.'); }
            }
            
            async function handleDrop(e) { e.preventDefault(); document.body.classList.remove('dragging'); if (e.dataTransfer.files.length) handleFiles(Array.from(e.dataTransfer.files)); }
            function handleFiles(files) { if (!files || files.length === 0) return; if (state.artboards.length === 0) { app.dropZone.classList.add('hidden'); app.workspaceContainer.classList.remove('hidden'); app.toolbarContainer.classList.remove('hidden'); app.rightPanel.classList.remove('hidden'); } const imageFiles = files.filter(f => f.type.startsWith('image/') && !f.name.endsWith('.gif')); const videoFiles = files.filter(f => f.type.startsWith('video/')); const gifFiles = files.filter(f => f.name.endsWith('.gif')); imageFiles.forEach(file => { const reader = new FileReader(); reader.onload = e => addArtboard(file.name, e.target.result, 'image', {width: 0, height: 0}); reader.readAsDataURL(file); }); videoFiles.forEach(file => { const url = URL.createObjectURL(file); addArtboard(file.name, url, 'video'); }); gifFiles.forEach(gifToVideo); }
            async function handlePaste(e) {
                const activeEl = document.activeElement; if (activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'INPUT') return;
                const imageItem = Array.from(e.clipboardData.items).find(item => item.type.startsWith('image/'));
                if (imageItem) {
                    e.preventDefault();
                    const file = imageItem.getAsFile();
                    const artboardId = state.selectedArtboardIds.length > 0 ? state.selectedArtboardIds[0] : (state.artboards.length > 0 ? state.artboards[0].id : null);
                    if (artboardId) {
                        const {data, width, height} = await compressImage(file, true);
                        addAnnotation({ type: 'image', artboardId, data: { p1: {x:0.1, y:0.1}, p2: {x:0.9, y:0.9}, imageData: data, imgRatio: width/height }, text: '' }, true);
                    } else { handleFiles([file]); }
                    return;
                }
                if (state.clipboard.length > 0) { e.preventDefault(); pasteAnnotations(); }
            }
            function onKeyUp(e) { if (e.key === ' ') { e.preventDefault(); state.spacebarPressed = false; app.body.classList.remove('spacebar-down', 'panning'); } }

			function onKeyDown(e) {
				if (e.key === 'Tab') {
                    e.preventDefault();
                    toggleSimpleMode();
                    return;
                }
				
                const activeEl = document.activeElement;
                const isInputFocused = ['TEXTAREA', 'INPUT'].includes(activeEl.tagName);

                if (e.ctrlKey && e.altKey && e.shiftKey && e.key.toLowerCase() === 'p') {
                    e.preventDefault();
                    packageProjectAsZip();
                    return;
                }
                
                if (!isInputFocused) {
                    const key = e.key.toUpperCase();
                    
                    if (!e.ctrlKey && !e.altKey && !e.shiftKey) {
                        switch(e.key) {
                            case 'v': case 'V': e.preventDefault(); selectTool('select'); return;
                            case 'h': case 'H': e.preventDefault(); selectTool('pan'); return;
                            case 'm': case 'M': e.preventDefault(); toggleMuteForSelected(); return;
                            case 'c': case 'C': e.preventDefault(); selectTool('comment'); return;
                            case 'r': case 'R': e.preventDefault(); selectTool('rect'); return;
                            case 'o': case 'O': e.preventDefault(); selectTool('circle'); return;
                            case 'l': case 'L': e.preventDefault(); selectTool('line'); return;
                            case 'a': case 'A': e.preventDefault(); selectTool('arrow'); return;
                            case 'i': case 'I': e.preventDefault(); selectTool('image'); return;
                            case 's': case 'S': e.preventDefault(); selectTool('ocr'); return;
                            case ',': e.preventDefault(); navigateCommentMarkers(-1); return;
                            case '.': e.preventDefault(); navigateCommentMarkers(1); return;
                        }
                    }

                    if (!e.ctrlKey && !e.metaKey && e.shiftKey && key === 'L') {
                        e.preventDefault();
                        selectTool('arrow');
                        return;
                    }
                }
                
                if (e.key === ' ' && !state.spacebarPressed && !isInputFocused) { 
                    e.preventDefault(); 
                    state.spacebarPressed = true; 
                    app.body.classList.add('spacebar-down'); 
                }

                if (e.ctrlKey || e.metaKey) {
                    switch (e.key.toLowerCase()) {
                        case '=': e.preventDefault(); zoomAtPoint(1.1, e.clientX, e.clientY); return;
                        case '-': e.preventDefault(); zoomAtPoint(1 / 1.1, e.clientX, e.clientY); return;
                        case 's': if(!e.shiftKey) { e.preventDefault(); saveState(); return; } break; 
                        case 'z': e.preventDefault(); e.shiftKey ? historyManager.redo() : historyManager.undo(); return;
                        case 'f': e.preventDefault(); app.searchInput.focus(); app.searchInput.select(); return;
                        case 'a': if (!isInputFocused) { e.preventDefault(); state.selectedAnnotationIndices = state.annotations.map((_, i) => i); updateListSelection(); } return;
                        case 'd': e.preventDefault(); app.fileInput.click(); return;
                        case 'w': e.preventDefault(); if (state.selectedArtboardIds.length > 0) { deleteSelectedArtboards(); } return;
                        case 'm': e.preventDefault(); global_toggleMute(); return;
                        case 'c': if (!isInputFocused && state.selectedAnnotationIndices.length > 0) { copyAnnotations(); } return;
                        case 'v': if (!isInputFocused) { e.preventDefault(); pasteAnnotations(); } return;
                        case 'h': e.preventDefault(); toggleRightPanel(); return;
                        case 'g': e.preventDefault(); if (e.shiftKey) { resizeAllVideosTo720p(); } else { rearrangeArtboards(); } return;
                        case '1': e.preventDefault(); if(state.selectedArtboardIds.length === 1) { fitArtboardToView(state.selectedArtboardIds[0]); } else { setZoom(1); } return;
                        case '0': if (e.altKey) { e.preventDefault(); fitAllArtboardsToView(); } else { e.preventDefault(); state.view = { ...state.view, scale: 1, offsetX: 0, offsetY: 0 }; updateWorkspaceTransform(); } return;
                        case ';':
                            e.preventDefault();
                            if (e.shiftKey) { state.guides.locked = !state.guides.locked; } 
                            else { state.guides.visible = !state.guides.visible; }
                            drawGuides();
                            return;
                    }
                }

                if (!isInputFocused && (e.key === 'Delete' || e.key === 'Backspace')) { e.preventDefault(); if (state.selectedAnnotationIndices.length > 0) { deleteAnnotationsByIndices(state.selectedAnnotationIndices); } else if (state.selectedArtboardIds.length > 0) { deleteSelectedArtboards(); } }
                
                if (state.artboards.some(b => b.type === 'video') && !isInputFocused) {
                    let handled = true;
                    const frameCount = e.shiftKey ? 10 : 1; 
                    const target = e.ctrlKey ? 'all' : 'selected';
                    switch(e.key) {
                        case 'ArrowLeft': advancedSeek({ frameDelta: -frameCount, target }); break;
                        case 'ArrowRight': advancedSeek({ frameDelta: frameCount, target }); break;
                        case 'ArrowUp': advancedSeek({ position: 'start', target }); break;
                        case 'ArrowDown': advancedSeek({ position: 'end', target }); break;
                        default: handled = false;
                    }
                    if (handled) e.preventDefault();
                }
            }			
            function startPanning(e) {
                e.preventDefault(); e.stopPropagation();
                state.interaction.mode = 'panning';
                state.interaction.startPos = { x: e.clientX, y: e.clientY };
                state.interaction.startWorkspacePos = { x: state.view.offsetX, y: state.view.offsetY };
                app.workspaceContainer.classList.add('panning'); app.body.classList.add('panning');
            }

            function onWorkspaceMouseDown(e) {
                hideContextMenu();
                state.interaction.didDrag = false;
				
                if (e.button === 2) {
                    e.preventDefault();
                    state.interaction.rightClickStartPos = { x: e.clientX, y: e.clientY };
                }

                if (e.target.closest('.artboard')) return;

                const hitGuide = getHitGuide(e);
                if(hitGuide) {
                    e.preventDefault(); e.stopPropagation();
                    if (!hitGuide.guide.id) hitGuide.guide.id = crypto.randomUUID();
                    state.interaction.mode = 'draggingGuide';
                    state.interaction.target = hitGuide;
                    state.interaction.startData.set('guide', { position: hitGuide.guide.position });
                    return;
                }

                if (state.currentTool === 'pan' || state.spacebarPressed || e.button === 1 || e.button === 2) { 
                    startPanning(e); 
                    return; 
                }
                
                state.selectedAnnotationIndices = []; state.selectedArtboardIds = [];
                updateListSelection(); updateArtboardSelection();
            }
			
            function onWindowMouseMove(e) {
                if (e.altKey && state.interaction.mode === 'dragging') {
                    app.workspaceContainer.style.cursor = 'copy';
                }
                
                if(state.interaction.mode === 'panning' && !state.interaction.didDrag) {
                    const dx = Math.abs(e.clientX - state.interaction.startPos.x);
                    const dy = Math.abs(e.clientY - state.interaction.startPos.y);
                    if (dx > 5 || dy > 5) {
                        state.interaction.didDrag = true;
                    }
                }

                switch(state.interaction.mode) { 
                    case 'panning': { 
                        const dx = e.clientX - state.interaction.startPos.x; const dy = e.clientY - state.interaction.startPos.y; state.view.offsetX = state.interaction.startWorkspacePos.x + dx; state.view.offsetY = state.interaction.startWorkspacePos.y + dy; updateWorkspaceTransform(); break; 
                    }
                    case 'draggingToolbar': onToolbarDrag(e); break;
                    case 'draggingArtboard': onArtboardDrag(e); break; 
                    case 'resizingArtboard': onArtboardResize(e); break; 
                    case 'draggingGuide': onGuideDrag(e); break;
                    default: onCanvasMouseMove(e); break; 
                } 
            }
			
            function onWindowMouseUp(e) {
                app.workspaceContainer.style.cursor = '';
                if (['panning'].includes(state.interaction.mode)) { app.workspaceContainer.classList.remove('panning'); app.body.classList.remove('panning'); } 
                else if (['draggingArtboard', 'resizingArtboard'].includes(state.interaction.mode)) {
                    document.querySelectorAll('.artboard.dragging').forEach(el => el.classList.remove('dragging'));
                    const beforeState = []; const afterState = [];
                    state.selectedArtboardIds.forEach(id => { const board = state.artboards.find(b => b.id === id); const start = state.interaction.startData.get(id); if(board && start) { beforeState.push({id, x: start.x, y: start.y }); afterState.push({id, x: board.x, y: board.y }); } });
                     if (JSON.stringify(beforeState) !== JSON.stringify(afterState)) {
                        const doAction = (action) => {
                            const videoTimes = new Map();
                            document.querySelectorAll('#workspace video').forEach(v => {
                                const artboardEl = v.closest('.artboard');
                                if (artboardEl) {
                                    videoTimes.set(artboardEl.dataset.id, v.currentTime);
                                }
                            });

                            action.after.forEach(s => { const board = state.artboards.find(b=>b.id===s.id); if(board) Object.assign(board, {x:s.x, y:s.y}); });
                            renderWorkspace();

                            if (videoTimes.size > 0) {
                                document.querySelectorAll('#workspace video').forEach(v => {
                                    const artboardEl = v.closest('.artboard');
                                    if (artboardEl && videoTimes.has(artboardEl.dataset.id)) {
                                        const savedTime = videoTimes.get(artboardEl.dataset.id);
                                        const setTime = () => { if(isFinite(v.duration)) v.currentTime = savedTime; };
                                        if (v.readyState >= 1) { setTime(); } 
                                        else { v.addEventListener('loadedmetadata', setTime, { once: true }); }
                                    }
                                });
                            }
                        };
                        const undoAction = (action) => {
                             const videoTimes = new Map();
                            document.querySelectorAll('#workspace video').forEach(v => {
                                const artboardEl = v.closest('.artboard');
                                if (artboardEl) {
                                    videoTimes.set(artboardEl.dataset.id, v.currentTime);
                                }
                            });
                            
                            action.before.forEach(s => { const board = state.artboards.find(b=>b.id===s.id); if(board) Object.assign(board, {x:s.x, y:s.y}); });
                            renderWorkspace();

                             if (videoTimes.size > 0) {
                                document.querySelectorAll('#workspace video').forEach(v => {
                                    const artboardEl = v.closest('.artboard');
                                    if (artboardEl && videoTimes.has(artboardEl.dataset.id)) {
                                        const savedTime = videoTimes.get(artboardEl.dataset.id);
                                        const setTime = () => { if(isFinite(v.duration)) v.currentTime = savedTime; };
                                        if (v.readyState >= 1) { setTime(); } 
                                        else { v.addEventListener('loadedmetadata', setTime, { once: true }); }
                                    }
                                });
                            }
                        };
                        historyManager.execute({ type: 'MOVE_ARTBOARDS', before: beforeState, after: afterState, do: doAction, undo: undoAction });
                     }
                } else if (state.interaction.mode === 'draggingGuide') {
                    const { scope, guide, artboardId } = state.interaction.target;
                    const startData = state.interaction.startData.get('guide');
                    if (startData && startData.position !== guide.position) {
                        historyManager.execute({
                            type: 'MOVE_GUIDE', guideId: guide.id, scope: scope, artboardId: artboardId,
                            before: startData.position, after: guide.position,
                            do: function(action) { const g = findGuide(action.guideId); if (g) g.position = action.after; drawGuides(); },
                            undo: function(action) { const g = findGuide(action.guideId); if (g) g.position = action.before; drawGuides(); }
                        });
                    }
                }
                onCanvasMouseUp(e); state.interaction.mode = 'none'; state.interaction.target = null;
            }
            
			function onWorkspaceWheel(e) {
                e.preventDefault();
                
				if (e.ctrlKey) {
                    return; 
                }

                state.view.offsetX -= e.deltaX;
                state.view.offsetY -= e.deltaY;
                updateWorkspaceTransform();
            }
            
            function selectArtboard(artboardId, isShift) {
                if (isShift) { const index = state.selectedArtboardIds.indexOf(artboardId); if (index > -1) state.selectedArtboardIds.splice(index, 1); else state.selectedArtboardIds.push(artboardId); } 
                else { if (!state.selectedArtboardIds.includes(artboardId)) { state.selectedArtboardIds = [artboardId]; } }
                updateArtboardSelection();
            }
            function updateArtboardSelection() { document.querySelectorAll('.artboard').forEach(el => el.classList.toggle('selected', state.selectedArtboardIds.includes(el.dataset.id))); }

            function toggleSelectPanTool() {
                const newTool = state.currentTool === 'select' ? 'pan' : 'select';
                selectTool(newTool);
            }
            
            function selectTool(tool) {
                if (ocrSelectionActive && tool !== 'ocr') {
                    endOcrSelection(false);
                }
                
                state.currentTool = tool;
                document.querySelectorAll('.tool-btn').forEach(b => {
                    if (b.id !== 'select-pan-btn') {
                        b.classList.toggle('active', b.dataset.tool === state.currentTool);
                    }
                });

                if (tool === 'ocr') {
                    if (!tesseractReady) {
                        alert('OCR engine is not ready yet. Please wait.');
                        selectTool('select');
                        return;
                    }
                    startOcrSelection();
                }

                const toggleBtn = document.getElementById('select-pan-btn');
                const selectIcon = document.getElementById('select-tool-icon');
                const panIcon = document.getElementById('pan-tool-icon');
                const isSelectPan = ['select', 'pan'].includes(state.currentTool);
                toggleBtn.classList.toggle('active', isSelectPan);
                if (isSelectPan) {
                    selectIcon.classList.toggle('hidden', state.currentTool === 'pan');
                    panIcon.classList.toggle('hidden', state.currentTool === 'select');
                }
                app.workspaceContainer.classList.toggle('hand-tool', state.currentTool === 'pan');
                updateCursorOnMouseMove({target: app.workspaceContainer});
            };

            function updateCursorOnMouseMove(e) {
                if (state.interaction.mode !== 'none' || state.spacebarPressed || ocrSelectionActive) return;
                
                const hitGuide = getHitGuide(e);
                if(hitGuide) { 
                    app.workspaceContainer.style.cursor = hitGuide.guide.type === 'horizontal' ? 'row-resize' : 'col-resize'; 
                    document.querySelectorAll('.interaction-canvas, .guide-canvas').forEach(c => c.style.cursor = hitGuide.guide.type === 'horizontal' ? 'row-resize' : 'col-resize');
                    app.toolCursorIcon.classList.add('hidden'); 
                    return; 
                }

                if (state.currentTool === 'pan') {
                    if (e.target.closest('.artboard:not(.artboard-header)')) {
                        app.workspaceContainer.style.cursor = 'move';
                        document.querySelectorAll('.interaction-canvas, .guide-canvas').forEach(c => c.style.cursor = 'move');
                    } else {
                        app.workspaceContainer.style.cursor = 'grab';
                        document.querySelectorAll('.interaction-canvas, .guide-canvas').forEach(c => c.style.cursor = 'grab');
                    }
                    app.toolCursorIcon.classList.add('hidden');
                    return;
                }
                
                const canvas = e.target.closest('.interaction-canvas, .guide-canvas');
                if (canvas) {
                    const artboardEl = canvas.closest('.artboard');
                    if (artboardEl) {
                        const artboard = state.artboards.find(b => b.id === artboardEl.dataset.id);
                        if (artboard) { 
                            const pos = getMousePosOnArtboard(e, artboard); 
                            const hit = getHitAnnotation(pos, artboard.id, true);
                            let cursor = (hit && hit.cursor) ? hit.cursor : 'default';
                            if (e.altKey && cursor === 'move') cursor = 'copy';
                            canvas.style.cursor = cursor;

                            const isDrawingTool = state.currentTool && !['select', 'pan', 'ocr'].includes(state.currentTool);
                            if (isDrawingTool && (!hit || hit.cursor === 'default')) { 
                                app.toolCursorIcon.classList.remove('hidden');
                                const toolBtn = document.querySelector(`.tool-btn[data-tool='${state.currentTool}']`);
                                if (toolBtn) {
                                    app.toolCursorIcon.innerHTML = '';
                                    app.toolCursorIcon.appendChild(toolBtn.querySelector('svg').cloneNode(true));
                                }
                            } else { 
                                app.toolCursorIcon.classList.add('hidden'); 
                            } 
                        }
                    }
                } else { 
                    app.workspaceContainer.style.cursor = 'default'; 
                    app.toolCursorIcon.classList.add('hidden');
                }
            }

            function startOcrSelection() {
                if (ocrSelectionActive) return;

                const ocrOverlay = document.createElement('div');
                ocrOverlay.id = 'ocr-overlay';
                const ocrSelectionBox = document.createElement('div');
                ocrSelectionBox.id = 'ocr-selection-box';

                document.body.appendChild(ocrOverlay);
                document.body.appendChild(ocrSelectionBox);

                ocrSelectionActive = true;
                
                window.addEventListener('mousedown', onOcrMouseDown, true);
                window.addEventListener('mousemove', onOcrMouseMove, true);
                window.addEventListener('mouseup', onOcrMouseUp, true);
            }

            function endOcrSelection(runOcr = true) {
                if (!ocrSelectionActive) return;

                const overlay = document.getElementById('ocr-overlay');
                const selectionBox = document.getElementById('ocr-selection-box');
                
                if (runOcr && ocrStartPos && selectionBox) {
                    const rect = selectionBox.getBoundingClientRect();
                     if (rect.width > 10 && rect.height > 10) {
                        captureAndRunOcr(rect);
                    }
                }
                
                if (overlay) overlay.remove();
                if (selectionBox) selectionBox.remove();

                ocrSelectionActive = false;
                ocrStartPos = null;
                if (state.currentTool === 'ocr') {
                    selectTool('select');
                }

                window.removeEventListener('mousedown', onOcrMouseDown, true);
                window.removeEventListener('mousemove', onOcrMouseMove, true);
                window.removeEventListener('mouseup', onOcrMouseUp, true);
            }

            function onOcrMouseDown(e) {
                if (e.button !== 0 || !ocrSelectionActive) return;
                e.preventDefault(); e.stopPropagation();
                ocrStartPos = { x: e.clientX, y: e.clientY };
                const box = document.getElementById('ocr-selection-box');
                box.style.left = `${e.clientX}px`;
                box.style.top = `${e.clientY}px`;
                box.style.width = '0px';
                box.style.height = '0px';
            }

            function onOcrMouseMove(e) {
                if (!ocrStartPos) return;
                e.preventDefault(); e.stopPropagation();
                const x1 = Math.min(e.clientX, ocrStartPos.x);
                const y1 = Math.min(e.clientY, ocrStartPos.y);
                const x2 = Math.max(e.clientX, ocrStartPos.x);
                const y2 = Math.max(e.clientY, ocrStartPos.y);

                const box = document.getElementById('ocr-selection-box');
                if(box) {
                    box.style.left = `${x1}px`;
                    box.style.top = `${y1}px`;
                    box.style.width = `${x2 - x1}px`;
                    box.style.height = `${y2 - y1}px`;
                }
            }
            
            function onOcrMouseUp(e) {
                if (!ocrStartPos) return;
                e.preventDefault(); e.stopPropagation();
                endOcrSelection(true);
            }

            async function captureWorkspaceArea(rect) {
                app.toolbarContainer.classList.add('hidden');
                document.querySelectorAll('.artboard-resizer').forEach(el => el.style.display = 'none');
                
                const captureCanvas = document.createElement('canvas');
                captureCanvas.width = rect.width;
                captureCanvas.height = rect.height;
                const ctx = captureCanvas.getContext('2d');
                
                ctx.fillStyle = getComputedStyle(app.workspaceContainer).backgroundColor;
                ctx.fillRect(0, 0, rect.width, rect.height);

                for (const artboardEl of document.querySelectorAll('.artboard')) {
                    const artboardRect = artboardEl.getBoundingClientRect();

                    const intersection = {
                        x1: Math.max(rect.left, artboardRect.left),
                        y1: Math.max(rect.top, artboardRect.top),
                        x2: Math.min(rect.right, artboardRect.right),
                        y2: Math.min(rect.bottom, artboardRect.bottom),
                    };

                    if (intersection.x1 < intersection.x2 && intersection.y1 < intersection.y2) {
                        const contentEl = artboardEl.querySelector('.artboard-content');
                        const contentRect = contentEl.getBoundingClientRect();
                        
                        const tempArtboardCanvas = document.createElement('canvas');
                        tempArtboardCanvas.width = contentRect.width;
                        tempArtboardCanvas.height = contentRect.height;
                        const tempCtx = tempArtboardCanvas.getContext('2d', { willReadFrequently: true });
                        
                        tempCtx.fillStyle = getComputedStyle(contentEl).backgroundColor;
                        tempCtx.fillRect(0,0, contentRect.width, contentRect.height);

                        const mediaEl = artboardEl.querySelector('video, img:not(.frame-backup)');
                        if (mediaEl) {
                           try { tempCtx.drawImage(mediaEl, 0, 0, contentRect.width, contentRect.height); }
                           catch (e) { console.warn("Could not draw media element for OCR:", e); }
                        }

                        const displayCanvas = artboardEl.querySelector('.display-canvas');
                        if (displayCanvas) { tempCtx.drawImage(displayCanvas, 0, 0); }
                        
                        const contentIntersection = {
                            x1: Math.max(rect.left, contentRect.left),
                            y1: Math.max(rect.top, contentRect.top),
                            x2: Math.min(rect.right, contentRect.right),
                            y2: Math.min(rect.bottom, contentRect.bottom)
                        };

                        if(contentIntersection.x1 < contentIntersection.x2 && contentIntersection.y1 < contentIntersection.y2) {
                            const srcX = contentIntersection.x1 - contentRect.left;
                            const srcY = contentIntersection.y1 - contentRect.top;
                            const srcWidth = contentIntersection.x2 - contentIntersection.x1;
                            const srcHeight = contentIntersection.y2 - contentIntersection.y1;
                            const destX = contentIntersection.x1 - rect.left;
                            const destY = contentIntersection.y1 - rect.top;
                            ctx.drawImage(tempArtboardCanvas, srcX, srcY, srcWidth, srcHeight, destX, destY, srcWidth, srcHeight);
                        }
                    }
                }

                app.toolbarContainer.classList.remove('hidden');
                document.querySelectorAll('.artboard-resizer').forEach(el => el.style.display = '');

                return captureCanvas;
            }
            
            async function preprocessImageForOcr(imageDataUrl) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        for (let i = 0; i < data.length; i += 4) {
                            const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                            const contrast = 1.5;
                            const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
                            const adjusted = factor * (gray - 128) + 128;
                            const value = Math.min(255, Math.max(0, adjusted));
                            data[i] = data[i + 1] = data[i + 2] = value;
                        }
                        ctx.putImageData(imageData, 0, 0);
                        resolve(canvas.toDataURL('image/png'));
                    };
                    img.onerror = reject;
                    img.src = imageDataUrl;
                });
            }

            async function captureAndRunOcr(rect) {
                const resultBox = createOcrResultBox(rect);
                const statusEl = resultBox.querySelector('.status');
                const contentWrapper = resultBox.querySelector('.ocr-content-wrapper');
                let worker; 

                try {
                    statusEl.textContent = 'Capturing screen area...';
                    const capturedCanvas = await captureWorkspaceArea(rect);
                    
                    statusEl.textContent = 'Scanning for QR Code...';
                    const qrResult = scanForQrCode(capturedCanvas);

                    if (qrResult && qrResult.data) {
                        try {
                            new URL(qrResult.data);
                            statusEl.textContent = 'QR Code Found!';
                            contentWrapper.innerHTML = `<div class="qr-result"><a href="${qrResult.data}" target="_blank" rel="noopener noreferrer">${qrResult.data}</a></div>`;
                            return;
                        } catch (_) {
                            statusEl.textContent = 'QR Code Found!';
                             contentWrapper.innerHTML = `<textarea readonly>${qrResult.data}</textarea>`;
                             const textarea = contentWrapper.querySelector('textarea');
                             textarea.readOnly = false;
                             return;
                        }
                    }
                    
                    statusEl.textContent = 'Preprocessing image...';
                    const imageDataUrl = capturedCanvas.toDataURL('image/png');
                    const processedImageDataUrl = await preprocessImageForOcr(imageDataUrl);

                    if (!tesseractReady) throw new Error("Tesseract is not initialized.");

                    statusEl.textContent = 'Initializing OCR worker...';
                    
                    worker = await Tesseract.createWorker('lat', 1, {
					    corePath: 'https://cdn.jsdelivr.net/npm/tesseract.js-core@5.0.0/tesseract-core.wasm.js',
					    langPath: 'https://cdn.jsdelivr.net/gh/tesseract-ocr/tessdata@4.00/',
					    gzip: false,
					    logger: m => {
					        if (m.status === 'recognizing text') {
					            const progress = Math.round(m.progress * 100);
					            statusEl.textContent = `Recognizing text... ${progress}%`;
					        }
					    }
					});

                    await worker.setParameters({
                         preserve_interword_spaces: '1',
                    });

                    const { data: { text } } = await worker.recognize(processedImageDataUrl);
                    
                    const textarea = contentWrapper.querySelector('textarea');
                    textarea.value = text.trim() || 'No text or QR code detected.';
                    textarea.readOnly = false;
                    statusEl.textContent = 'OCR text extracted.';

                } catch (err) {
                    console.error('OCR Process Failed:', err);
                    const textarea = contentWrapper.querySelector('textarea');
                    textarea.value = `OCR failed: ${err ? (err.message || String(err)) : 'Unknown error'}`;
                    statusEl.textContent = 'Error.';
                } finally {
                    if (worker) {
                        await worker.terminate();
                    }
                }
            }

            function createOcrResultBox(rect) {
                const existingBox = document.getElementById('ocr-result-box');
                if (existingBox) existingBox.remove();
                
                const box = document.createElement('div');
                box.id = 'ocr-result-box';
                box.innerHTML = `
                    <div class="header">
                        <span>Scan Result</span>
                        <button class="close-btn">&times;</button>
                    </div>
                    <div class="ocr-content-wrapper">
                         <textarea readonly placeholder="Recognizing..."></textarea>
                    </div>
                    <div class="footer">
                        <span class="status">Initializing...</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                `;
                document.body.appendChild(box);
                
                let topPos = rect.bottom + 10;
                let leftPos = rect.left;

                if (leftPos + 300 > window.innerWidth) {
                    leftPos = window.innerWidth - 310;
                }
                if (topPos + 150 > window.innerHeight) {
                    topPos = rect.top - 160;
                }
                box.style.left = `${leftPos}px`;
                box.style.top = `${topPos}px`;
                
                box.querySelector('.close-btn').onclick = () => box.remove();
                box.querySelector('.copy-btn').onclick = () => {
                    const textarea = box.querySelector('textarea');
                    const qrLink = box.querySelector('.qr-result a');
                    const textToCopy = textarea ? textarea.value : (qrLink ? qrLink.href : '');
                    
                    if (textToCopy) {
                        navigator.clipboard.writeText(textToCopy);
                        const btn = box.querySelector('.copy-btn');
                        const oldText = btn.textContent;
                        btn.textContent = 'Copied!';
                        setTimeout(() => { btn.textContent = oldText; }, 1500);
                    }
                };
                
                const header = box.querySelector('.header');
                header.onmousedown = (e) => {
                    e.preventDefault();
                    let shiftX = e.clientX - box.getBoundingClientRect().left;
                    let shiftY = e.clientY - box.getBoundingClientRect().top;
                    const moveAt = (pageX, pageY) => {
                        box.style.left = pageX - shiftX + 'px';
                        box.style.top = pageY - shiftY + 'px';
                    }
                    const onMouseMove = (event) => moveAt(event.pageX, event.pageY);
                    document.addEventListener('mousemove', onMouseMove);
                    header.onmouseup = () => {
                        document.removeEventListener('mousemove', onMouseMove);
                        header.onmouseup = null;
                    };
                };
                return box;
            }

			function scanForQrCode(canvas) {
                if (!canvas || !window.jsQR) return null;
                try {
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const code = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: "dontInvert",
                    });
                    return code;
                } catch (e) {
                    console.error("Lỗi trong quá trình quét QR:", e);
                    return null;
                }
            }

            function addArtboard(name, src, type, size = {width:0, height:0}, options = {}) {
                const { isLoading = false, id = crypto.randomUUID() } = options;
                const onMediaReady = () => {
                    if (type === 'image' && !isLoading) {
                        const mediaElement = new Image();
                        mediaElement.onload = () => {
                           createArtboardObject(id, name, src, type, { width: mediaElement.naturalWidth, height: mediaElement.naturalHeight }, isLoading);
                        };
                        mediaElement.src = src;
                    } else if (type === 'video' && !isLoading) {
                         const mediaElement = document.createElement('video');
                         mediaElement.onloadedmetadata = () => {
                            createArtboardObject(id, name, src, type, { width: mediaElement.videoWidth, height: mediaElement.videoHeight }, isLoading);
                         };
                         mediaElement.src = src;
                    } else {
                        createArtboardObject(id, name, src, type, size, isLoading);
                    }
                };

                const createArtboardObject = (id, name, src, type, size, isLoading) => {
                    const artboard = { id, name, type, src, x: 50, y: 50, width: size.width, height: size.height, originalWidth: size.width, originalHeight: size.height, scale: 1, isLoading };
                    
                    if ((type === 'video' || type === 'image') && !isLoading && artboard.originalHeight > 720) {
                        const targetHeight = 720;
                        const aspectRatio = artboard.originalWidth / artboard.originalHeight;
                        artboard.height = targetHeight;
                        artboard.width = targetHeight * aspectRatio;
                        artboard.scale = artboard.height / artboard.originalHeight;
                    }

                    if (type === 'video') { 
                        artboard.frameBackups = {}; 
                        artboard.videoFailedToLoad = false;
                    }
                    state.guides.artboard[artboard.id] = [];
                    state.artboards.push(artboard);
                    rearrangeArtboards();
                    if (type === 'video' && !isLoading) {
                        global_updateTimeline();
                    }
                };
                onMediaReady();
            }

            function renderWorkspace() {
                app.workspace.innerHTML = '';
                state.artboards.forEach(artboard => {
                    const artboardEl = document.createElement('div'); artboardEl.className = 'artboard'; artboardEl.dataset.id = artboard.id;
                    artboardEl.classList.toggle('loading', !!artboard.isLoading);
                    const controlsHeight = artboard.type === 'video' ? 32 : 0;
                    artboardEl.style.cssText = `left: ${artboard.x}px; top: ${artboard.y}px; width: ${artboard.width}px; height: ${artboard.height + 30 + controlsHeight}px;`;
                    artboardEl.classList.toggle('selected', state.selectedArtboardIds.includes(artboard.id));
                    let contentHTML = ''; let videoControlsHTML = '';
                    if (!artboard.isLoading) {
                        let artboardSrc = artboard.src || artboard.name;
                        if (!artboardSrc.startsWith('data:') && !artboardSrc.startsWith('blob:') && !artboardSrc.includes('://') && !artboardSrc.startsWith('/')) {
                            artboardSrc = './' + artboardSrc;
                        }
                        switch(artboard.type) {
                            case 'image': contentHTML = `<img src="${artboardSrc}" alt="${artboard.name}" crossOrigin="anonymous">`; break;
                            case 'video': contentHTML = `<video src="${artboardSrc}" playsinline loop crossOrigin="anonymous"></video><img class="frame-backup hidden" alt="Backup Frame">`; break;
                        }
                        if(artboard.type === 'video') videoControlsHTML = `<div class="artboard-video-controls"><button class="vid-play-btn" title="Play/Pause">▶</button><button class="vid-mute-btn" title="Mute/Unmute">${MUTE_ICON_SVG}</button><input type="text" class="time-input vid-time" value="00:00:00"><div class="vid-timeline-wrapper"><div class="vid-timeline-bg"></div><canvas class="vid-timeline-markers"></canvas><input type="range" class="vid-timeline" value="0" step="0.01"></div><span class="vid-duration time-input">00:00:00</span></div>`;
                    }
                    const dimensionsDisplay = `<span class="artboard-info">(${artboard.originalWidth}x${artboard.originalHeight})</span>`;
                    const headerToolsHTML = `<div class="artboard-header-tools"><button class="header-icon-btn fit-view-btn" title="Fit to View (Ctrl+1)"><svg viewBox="0 0 24 24"><path d="M15 3h6v6l-2-2-4 4-2-2 4-4-2-2zM9 21H3v-6l2 2 4-4 2 2-4 4 2 2z"/></svg></button><button class="artboard-close-btn" title="Close Artboard (Ctrl+W)">&times;</button></div>`;
                    
                    artboardEl.innerHTML = `
                        <div class="artboard-header"><div class="artboard-title-container" title="${artboard.name} ${artboard.originalWidth}x${artboard.originalHeight}"><span class="artboard-title">${artboard.name}</span><span class="artboard-info-wrapper">${dimensionsDisplay}</span></div>${headerToolsHTML}</div>
                        <div class="artboard-content">${contentHTML}<canvas class="guide-canvas"></canvas><canvas class="display-canvas"></canvas><canvas class="interaction-canvas"></canvas></div>
                        ${videoControlsHTML}
                        <div class="artboard-resizer" title="Resize (Double-click to reset)"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.0002 12.0001L12.0002 10.0001" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M6.00009 16.0001L16.0001 6.00009" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M14.0002 12.0001L12.0002 14.0001" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg></div>`;
                    app.workspace.appendChild(artboardEl);
                    artboardEl.addEventListener('mousedown', e => { 
                        if(e.target === artboardEl) {
                           if (state.currentTool === 'pan') { onArtboardHeaderMouseDown(e, artboard.id); }
                           else { selectArtboard(artboard.id, e.ctrlKey || e.metaKey); }
                        }
                    });
                    artboardEl.addEventListener('contextmenu', e => onArtboardContextMenu(e, artboard.id));
                    
                    const contentEl = artboardEl.querySelector('.artboard-content');
                    if(contentEl) {
                        contentEl.style.backgroundColor = state.layout.artboardBgColor;
                    }

                    artboardEl.querySelector('.artboard-header').addEventListener('mousedown', e => onArtboardHeaderMouseDown(e, artboard.id));
                    artboardEl.querySelector('.fit-view-btn').addEventListener('click', () => fitArtboardToView(artboard.id));
                    artboardEl.querySelector('.artboard-close-btn').addEventListener('click', () => deleteSelectedArtboards());
                    artboardEl.querySelector('.artboard-resizer').addEventListener('mousedown', e => onArtboardResizeMouseDown(e, artboard.id));
                    artboardEl.querySelector('.artboard-resizer').addEventListener('dblclick', e => { e.stopPropagation(); resetArtboardScale(artboard.id); });
                    const interactionCanvas = artboardEl.querySelector('.interaction-canvas');
                    interactionCanvas.addEventListener('mousedown', e => onCanvasMouseDown(e, artboard.id));
                    interactionCanvas.addEventListener('dblclick', e => onCanvasDblClick(e, artboard.id));
                    interactionCanvas.addEventListener('contextmenu', e => onAnnotationCanvasContextMenu(e, artboard.id));
                    
                    const guideCanvas = artboardEl.querySelector('.guide-canvas');
                    guideCanvas.addEventListener('mousedown', e => onCanvasMouseDown(e, artboard.id));

                    if (artboard.type === 'video' && !artboard.isLoading) {
                        initVideoArtboardControls(artboardEl, artboard);
                    }
                });
                redrawAllAnnotations(); 
                drawGuides();
            }

            function handleVideoRelink(e, artboardId) {
                e.preventDefault();
                e.stopPropagation();
                
                const file = e.dataTransfer.files[0];
                if (!file || !file.type.startsWith('video/')) return;
                
                const artboard = state.artboards.find(b => b.id === artboardId);
                if (!artboard) return;

                const relink = () => {
                    const artboardEl = document.querySelector(`.artboard[data-id="${artboardId}"]`);
                    const videoEl = artboardEl.querySelector('video');
                    
                    const url = URL.createObjectURL(file);
                    artboard.src = url;
                    artboard.name = file.name;
                    artboard.videoFailedToLoad = false;
                    
                    videoEl.src = url;
                    videoEl.load();
                    videoEl.classList.remove('hidden');
                    
                    artboardEl.classList.remove('video-missing');
                    
                    renderWorkspace();
                    markAsChanged();
                };

                if (file.name !== artboard.name) {
                    if (confirm(`Relink with "${file.name}"? This will replace the original reference to "${artboard.name}".`)) {
                        relink();
                    }
                } else {
                    relink();
                }
            }

            function initVideoArtboardControls(artboardEl, artboard) {
                const video = artboardEl.querySelector('video');
                if(!video) return;
                artboard.videoFailedToLoad = false;
                
                video.onerror = () => { 
                    artboard.videoFailedToLoad = true; 
                    artboardEl.classList.add('video-missing');
                    artboardEl.addEventListener('dragover', e => e.preventDefault());
                    artboardEl.addEventListener('drop', e => handleVideoRelink(e, artboard.id));
                    video.classList.add('hidden'); 
                    redrawArtboardAnnotations(artboard.id); 
                };

                const controlsEl = artboardEl.querySelector('.artboard-video-controls');
                const playBtn = artboardEl.querySelector('.vid-play-btn'); 
                const muteBtn = artboardEl.querySelector('.vid-mute-btn'); 
                const timeInput = artboardEl.querySelector('.vid-time'); 
                const timeline = artboardEl.querySelector('.vid-timeline');

                controlsEl.addEventListener('mousedown', e => {
                    hideContextMenu();
                    state.interaction.didDrag = false;
                    if (e.button === 1 || e.button === 2 || state.spacebarPressed) {
                        e.preventDefault();
                        if (!e.target.closest('button, input')) {
                            startPanning(e);
                        }
                    }
                });

                video.muted = state.isGlobalMuted; muteBtn.innerHTML = video.muted ? MUTE_ICON_SVG : UNMUTE_ICON_SVG;
                playBtn.addEventListener('click', e => { e.stopPropagation(); video.paused ? video.play() : video.pause(); });
                muteBtn.addEventListener('click', e => { e.stopPropagation(); video.muted = !video.muted; muteBtn.innerHTML = video.muted ? MUTE_ICON_SVG : UNMUTE_ICON_SVG; });
                video.addEventListener('play', () => { playBtn.textContent = '❚❚'; global_updatePlayButtonState(); });
                video.addEventListener('pause', () => { playBtn.textContent = '▶'; global_updatePlayButtonState(); });
                video.addEventListener('loadedmetadata', () => { timeline.max = video.duration; global_updateTimeline(); });
                video.addEventListener('timeupdate', () => { if (!timeline.matches(':active')) timeline.value = video.currentTime; if (document.activeElement !== timeInput) { timeInput.value = formatTimeHHMMSSFF(video.currentTime, video.duration); } redrawArtboardAnnotations(artboard.id); });
                timeline.addEventListener('input', e => { e.stopPropagation(); video.currentTime = parseFloat(timeline.value); redrawArtboardAnnotations(artboard.id); });
                initTimeInput(timeInput, () => video.currentTime, (newTime) => {video.currentTime = newTime; redrawArtboardAnnotations(artboard.id);}, () => video.duration);
            }
			
            async function captureFrame(videoEl) { const canvas = document.createElement('canvas'); canvas.width = videoEl.videoWidth; canvas.height = videoEl.videoHeight; const ctx = canvas.getContext('2d'); ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height); return canvas.toDataURL('image/webp', 0.5); }
            async function saveVideoFrame(artboardId) {
                const artboard = state.artboards.find(b => b.id === artboardId);
                const videoEl = document.querySelector(`.artboard[data-id="${artboardId}"] video`);
                if (!artboard || !videoEl) return;
                const canvas = document.createElement('canvas'); canvas.width = videoEl.videoWidth; canvas.height = videoEl.videoHeight; const ctx = canvas.getContext('2d'); ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height);
                app.frameDownloadLink.href = canvas.toDataURL('image/png');
                const timecode = formatTimeHHMMSSFF(videoEl.currentTime, videoEl.duration).replace(/:/g, '_');
                app.frameDownloadLink.download = `${artboard.name}_Frame_${timecode}.png`;
                app.frameDownloadLink.click();
            }

            function deleteSelectedArtboards() {
                if (state.selectedArtboardIds.length === 0) return;
                const artboardsToRemove = state.artboards.filter(b => b.id === state.selectedArtboardIds[0]);
                const annotationsOnArtboards = state.annotations.filter(a => state.selectedArtboardIds.includes(a.artboardId));

                if (annotationsOnArtboards.length > 0) {
                    if (!confirm(`Delete ${artboardsToRemove.length} artboard(s) and all ${annotationsOnArtboards.length} comments on them? This action cannot be undone.`)) {
                        return;
                    }
                }
                
                historyManager.execute({ 
                    type: 'DELETE_ARTBOARDS', 
                    artboards: JSON.parse(JSON.stringify(artboardsToRemove)), 
                    annotations: JSON.parse(JSON.stringify(annotationsOnArtboards)),
                    do: () => { 
                        artboardsToRemove.forEach(board => { 
                            if(board.type === 'video' && board.src.startsWith('blob:')) URL.revokeObjectURL(board.src); 
                            delete state.guides.artboard[board.id]; 
                        }); 
                        state.artboards = state.artboards.filter(b => !state.selectedArtboardIds.includes(b.id)); 
                        state.annotations = state.annotations.filter(a => !state.selectedArtboardIds.includes(a.artboardId)); 
                        state.selectedArtboardIds = []; 
                        
                        if (state.artboards.length === 0) {
                            app.dropZone.classList.remove('hidden');
                            app.workspaceContainer.classList.add('hidden');
                            app.toolbarContainer.classList.add('hidden');
                            app.rightPanel.classList.add('hidden');
                            app.timelinePanel.classList.add('hidden');
                        } else {
                            rearrangeArtboards(); 
                        }
                        updateAnnotationList(); 
                        global_updateTimeline(); 
                    },
                    undo: (action) => { 
                        const wasEmpty = state.artboards.length === 0;
                        state.artboards.push(...action.artboards); 
                        state.annotations.push(...action.annotations); 
                        action.artboards.forEach(b => state.guides.artboard[b.id] = state.guides.artboard[b.id] || [] ); 
                        state.selectedArtboardIds = action.artboards.map(b => b.id); 
                        
                        if (wasEmpty && state.artboards.length > 0) {
                            app.dropZone.classList.add('hidden');
                            app.workspaceContainer.classList.remove('hidden');
                            app.toolbarContainer.classList.remove('hidden');
                            app.rightPanel.classList.remove('hidden');
                            if (state.artboards.some(b => b.type === 'video')) {
                                app.timelinePanel.classList.remove('hidden');
                            }
                        }
                        rearrangeArtboards(); 
                        updateAnnotationList(); 
                        global_updateTimeline(); 
                    }
                });
            }

            
            async function compressImage(file, returnSize = false, quality = 0.8) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => { const canvas = document.createElement('canvas'); canvas.width = img.width; canvas.height = img.height; const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0); const data = canvas.toDataURL('image/webp', quality); if (returnSize) { resolve({ data, width: img.width, height: img.height }); } else { resolve(data); } };
                        img.onerror = reject; img.src = event.target.result;
                    };
                    reader.onerror = reject; reader.readAsDataURL(file);
                });
            }

            async function handleImageToolFile(e) {
                const file = e.target.files[0]; if (!file || !state.interaction.target) { state.interaction.mode = 'none'; state.interaction.target = null; return; }
                try {
                    const { data, width, height } = await compressImage(file, true); state.pendingImageData = { data, width, height };
                    const { artboardId } = state.interaction.target; const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard || !state.pendingImageData.data) return;
                    const pos = state.interaction.startPos; const defaultWidth = 300; const imgRatio = state.pendingImageData.width / state.pendingImageData.height; const defaultHeight = defaultWidth / imgRatio;
                    const normWidth = defaultWidth / artboard.width; const normHeight = defaultHeight / artboard.height; const p1 = { x: pos.x, y: pos.y }; const p2 = { x: pos.x + normWidth, y: pos.y + normHeight };
                    addAnnotation({ type: 'image', artboardId, data: { p1, p2, imageData: data, imgRatio: imgRatio }, text: '' }, false);
                } catch(err) { console.error("Image compression failed", err); } 
                finally { state.pendingImageData = { data: null, width: 0, height: 0 }; state.interaction.mode = 'none'; state.interaction.target = null; app.imageToolInput.value = ''; }
            }
            
            async function addAnnotation(ann, startEditing = false) {
                const newAnn = { ...ann, user: state.currentUser, id: crypto.randomUUID(), parentId: ann.parentId || null, completed: false, };
                if (!newAnn.color && (newAnn.type !== 'reply' && newAnn.type !== 'image')) {
                    newAnn.color = state.activeColor;
                }
                const artboard = state.artboards.find(b => b.id === newAnn.artboardId);
                if (artboard && artboard.type === 'video') {
                     const videoEl = document.querySelector(`.artboard[data-id="${artboard.id}"] video`);
                     if (videoEl && !artboard.videoFailedToLoad) { newAnn.videoTime = videoEl.currentTime; videoEl.pause(); const frameKey = newAnn.videoTime.toFixed(5); if (!artboard.frameBackups) artboard.frameBackups = {}; if (!artboard.frameBackups[frameKey]) { artboard.frameBackups[frameKey] = await captureFrame(videoEl); } }
                }
                historyManager.execute({ type: 'ADD_ANNOTATION', annotation: newAnn,
                    do: () => {
                        state.annotations.push(newAnn);
                        const newIndex = state.annotations.length - 1;
                        state.selectedAnnotationIndices = [newIndex];
                        state.lastClickedAnnIndex = newIndex;
                        updateAnnotationList();
                        redrawAllAnnotations();
                        
                        if (startEditing) {
                            if (state.layout.isPanelCollapsed) {
                                updateAnnotationPopup(newIndex);
                            } else {
                                const li = app.annotationList.querySelector(`li[data-id='${newAnn.id}']`);
                                if (li) {
                                    li.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                    makeListItemEditable(li, newIndex);
                                }
                            }
                        } else {
                            drawAnnotationConnectorLines();
                            updateAnnotationPopup();
                        }
                    },
                    undo: () => { state.annotations = state.annotations.filter(a => a.id !== newAnn.id); state.selectedAnnotationIndices = []; updateAnnotationList(); redrawAllAnnotations(); }
                });
            }
            
            function createAnnotationListItem(ann, index) {
                const li = document.createElement('li'); li.dataset.id = ann.id; li.dataset.index = index;
                li.classList.toggle('selected', state.selectedAnnotationIndices.includes(index)); li.classList.toggle('completed', ann.completed); li.classList.toggle('reply-item', !!ann.parentId);
                const contentHtml = ann.text ? `<p class="content">${ann.text.replace(/\n/g, '<br>')}</p>` : '<p class="content" style="min-height: 1em;"></p>';
                const headerToolsHtml = `<button class="icon-btn" title="Delete"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button><button class="icon-btn" title="Copy Text"><svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button><button class="icon-btn" title="Reply"><svg viewBox="0 0 24 24"><path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/></svg></button><input type="checkbox" class="complete-checkbox" ${ann.completed ? 'checked' : ''}>`;
                const typeDisplay = ann.type === 'reply' ? 'reply' : (ann.type === 'comment' ? 'cmt' : ann.type);
                const userDisplay = ann.user ? `<strong>${ann.user}</strong>` : '';
                let timeInfo = ann.videoTime !== undefined ? ` @${formatTime(ann.videoTime)}` : '';
                const finalUserDisplay = userDisplay + (userDisplay ? ' - ' : '');
                
                li.innerHTML = `<div class="header"><span class="time">${finalUserDisplay}${typeDisplay}${timeInfo}</span><div class="header-tools">${headerToolsHtml}</div></div>${contentHtml}`;
                li.addEventListener('click', e => {
                    if (e.target.closest('.icon-btn, .complete-checkbox')) return; 
                    const clickedIndex = parseInt(li.dataset.index, 10);
                    if (e.ctrlKey || e.metaKey) { 
                        const idxInSelection = state.selectedAnnotationIndices.indexOf(clickedIndex); 
                        if (idxInSelection > -1) {
                            state.selectedAnnotationIndices.splice(idxInSelection, 1);
                        } else {
                            state.selectedAnnotationIndices.push(clickedIndex);
                        }
                    } else if (e.shiftKey && state.lastClickedAnnIndex !== -1) {
                        const allListItems = Array.from(app.annotationList.querySelectorAll('li[data-index]'));
                        const lastDomIndex = allListItems.findIndex(item => parseInt(item.dataset.index, 10) === state.lastClickedAnnIndex);
                        const currentDomIndex = allListItems.findIndex(item => parseInt(item.dataset.index, 10) === clickedIndex);
                        
                        const start = Math.min(lastDomIndex, currentDomIndex);
                        const end = Math.max(lastDomIndex, currentDomIndex);

                        const indicesToSelect = allListItems.slice(start, end + 1).map(item => parseInt(item.dataset.index, 10));
                        state.selectedAnnotationIndices = [...new Set(indicesToSelect)];
                    } else { 
                        state.selectedAnnotationIndices = [clickedIndex]; 
                    }
                    state.lastClickedAnnIndex = clickedIndex; 
                    updateListSelection();
                    const clickedAnn = state.annotations[clickedIndex];
                    if (clickedAnn && clickedAnn.artboardId) {
                         selectArtboard(clickedAnn.artboardId, false); 
                         const artboard = state.artboards.find(b => b.id === clickedAnn.artboardId);
                         if (artboard && artboard.type === 'video' && clickedAnn.videoTime !== undefined) {
                             const artboardEl = document.querySelector(`.artboard[data-id="${artboard.id}"]`);
                             const videoEl = artboardEl ? artboardEl.querySelector('video') : null; const timelineEl = artboardEl ? artboardEl.querySelector('.vid-timeline') : null;
                             if(videoEl && !artboard.videoFailedToLoad) { videoEl.currentTime = clickedAnn.videoTime; videoEl.pause(); } 
                             else if (timelineEl) { timelineEl.value = clickedAnn.videoTime; redrawArtboardAnnotations(artboard.id); }
                         }
                    }
                });
                li.addEventListener('dblclick', () => makeListItemEditable(li, index));
                li.querySelector('.complete-checkbox').addEventListener('click', e => { e.stopPropagation(); ann.completed = e.target.checked; li.classList.toggle('completed', ann.completed); markAsChanged(); redrawAllAnnotations(); updateAnnotationPopup();});
                li.querySelector('.icon-btn[title="Delete"]').addEventListener('click', e => { e.stopPropagation(); deleteAnnotationsByIndices([index]); });
                li.querySelector('.icon-btn[title="Copy Text"]').addEventListener('click', e => { e.stopPropagation(); if (ann.text) navigator.clipboard.writeText(ann.text); });
                li.querySelector('.icon-btn[title="Reply"]').addEventListener('click', e => { e.stopPropagation(); addAnnotation({ type: 'reply', artboardId: ann.artboardId, text: '', parentId: ann.id }, true); });
                return li;
            }

            function updateAnnotationList() {
                const listScrollTop = app.annotationList.scrollTop;
                app.annotationList.innerHTML = '';
                const searchTerm = app.searchInput.value.toLowerCase();

                const filteredAnnotations = searchTerm ? state.annotations.filter(ann => (ann.text || '').toLowerCase().includes(searchTerm) || (ann.user || '').toLowerCase().includes(searchTerm)) : state.annotations;
                const grouped = filteredAnnotations.reduce((acc, ann) => { const key = ann.artboardId || 'workspace'; if (!acc[key]) acc[key] = []; acc[key].push(ann); return acc; }, {});

                const getSortKey = (ann) => {
                    let y, x;
                    if (ann.type === 'comment' || ann.type === 'reply') { y = ann.data.y; x = ann.data.x; } 
                    else if (ann.data && ann.data.p1) { y = Math.min(ann.data.p1.y, ann.data.p2.y); x = Math.min(ann.data.p1.x, ann.data.p2.x); } 
                    else { y = 0; x = 0; }
                    return { time: ann.videoTime, y, x };
                };
                
                const artboardOrder = [...state.artboards.map(b => b.id), 'workspace'];
                
                artboardOrder.forEach(artboardId => {
                    const groupAnnotations = grouped[artboardId];
                    if (!groupAnnotations || groupAnnotations.length === 0) return;

                    const artboard = state.artboards.find(b => b.id === artboardId);
                    const groupName = artboard ? artboard.name : 'Ungrouped';
                    const header = document.createElement('li');
                    header.className = 'group-header';
                    header.innerHTML = `<span>${groupName}</span><span class="collapse-toggle">▼</span>`;
                    app.annotationList.appendChild(header);

                    const annotationMap = new Map();
                    const childrenMap = new Map();
                    groupAnnotations.forEach(ann => {
                        annotationMap.set(ann.id, ann);
                        if (ann.parentId) {
                            if (!childrenMap.has(ann.parentId)) {
                                childrenMap.set(ann.parentId, []);
                            }
                            childrenMap.get(ann.parentId).push(ann);
                        }
                    });

                    const groupItems = [];
                    const renderThread = (ann, depth) => {
                        const originalIndex = state.annotations.findIndex(a => a.id === ann.id);
                        if (originalIndex === -1) return;

                        const item = createAnnotationListItem(ann, originalIndex);
                        app.annotationList.appendChild(item);
                        groupItems.push(item);
                        
                        const children = childrenMap.get(ann.id) || [];
                        children.forEach(child => {
                            renderThread(child, depth + 1);
                        });
                    };

                    const rootAnnotations = groupAnnotations
                        .filter(a => !a.parentId || !annotationMap.has(a.parentId))
                        .sort((a,b) => {
                            const keyA = getSortKey(a); const keyB = getSortKey(b);
                            if (keyA.time !== undefined && keyB.time !== undefined) { if (Math.abs(keyA.time - keyB.time) > 0.001) return keyA.time - keyB.time; }
                            if (keyA.time !== undefined && keyB.time === undefined) return -1;
                            if (keyA.time === undefined && keyB.time !== undefined) return 1;
                            if (Math.abs(keyA.y - keyB.y) > 0.01) return keyA.y - keyB.y;
                            return keyA.x - keyB.x;
                        });
                    
                    rootAnnotations.forEach(ann => renderThread(ann, 0));

                    header.addEventListener('click', () => {
                        header.classList.toggle('collapsed');
                        groupItems.forEach(item => item.classList.toggle('hidden'));
                    });
                });

                app.annotationList.scrollTop = listScrollTop;
                updateListSelection();
            }
            
            function getAnnotationScreenPos(ann) {
                const artboard = state.artboards.find(b => b.id === ann.artboardId);
                if (!artboard) return null;

                const workspaceContainerRect = app.workspaceContainer.getBoundingClientRect();
                const artboardHeaderHeight = 30;

                let localX, localY;

                if (ann.type === 'comment' || ann.type === 'reply') {
                    const iconSize = 24;
                    localX = ann.data.x * artboard.width;
                    localY = (ann.data.y * artboard.height) - (iconSize / 2);
                } else if (ann.data && ann.data.p1 && ann.data.p2) {
                    localX = ((ann.data.p1.x + ann.data.p2.x) / 2) * artboard.width;
                    localY = ((ann.data.p1.y + ann.data.p2.y) / 2) * artboard.height;
                } else {
                    return null;
                }

                const worldX = artboard.x + localX;
                const worldY = artboard.y + artboardHeaderHeight + localY;

                const finalScreenX = (worldX * state.view.scale) + state.view.offsetX + workspaceContainerRect.left;
                const finalScreenY = (worldY * state.view.scale) + state.view.offsetY + workspaceContainerRect.top;

                return { x: finalScreenX, y: finalScreenY };
            }

            function drawAnnotationConnectorLines() {
                const canvas = app.workspaceGuideCanvas;
                const ctx = canvas.getContext('2d');
                
                drawGuides();

                if (state.layout.isPanelCollapsed || state.selectedAnnotationIndices.length === 0) {
                    return;
                }

                const canvasRect = canvas.getBoundingClientRect();

                state.selectedAnnotationIndices.forEach(index => {
                    const ann = state.annotations[index];
                    if (!ann) return;

                    const li = app.annotationList.querySelector(`li[data-id='${ann.id}']`);
                    if (!li) return;

                    const screenPos = getAnnotationScreenPos(ann);
                    if (!screenPos) return;

                    const liRect = li.getBoundingClientRect();
                                     
                    const startX = liRect.left - canvasRect.left;
                    const startY = liRect.top + liRect.height / 2 - canvasRect.top;
                    
                    const endX = screenPos.x - canvasRect.left;
                    const endY = screenPos.y - canvasRect.top;

                    const dx = endX - startX;
                    const handleOffset = Math.max(50, Math.min(150, Math.abs(dx) * 0.5));

                    const cp1x = startX - handleOffset;
                    const cp1y = startY;
                    
                    const cp2x = endX + handleOffset;
                    const cp2y = endY;

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                    
                    ctx.strokeStyle = ann.color || '#E53935';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                });
            }

            function updateAnnotationPopup(editIndex = -1) {
                if (!state.layout.isPanelCollapsed || state.selectedAnnotationIndices.length !== 1) {
                    app.annotationPopup.classList.add('hidden');
                    return;
                }

                const index = state.selectedAnnotationIndices[0];
                const ann = state.annotations[index];
                if (!ann) {
                    app.annotationPopup.classList.add('hidden');
                    return;
                }
                
                const screenPos = getAnnotationScreenPos(ann);
                if (!screenPos) {
                    app.annotationPopup.classList.add('hidden');
                    return;
                }
                
                const isEditing = index === editIndex;

                const userDisplay = ann.user ? `<strong>${ann.user}</strong>` : '';
                const timeInfo = ann.videoTime !== undefined ? ` @${formatTime(ann.videoTime)}` : '';
                const headerToolsHtml = `<div class="header-tools"><button class="icon-btn" title="Delete"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button><button class="icon-btn" title="Copy Text"><svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button><button class="icon-btn" title="Reply"><svg viewBox="0 0 24 24"><path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/></svg></button><input type="checkbox" class="complete-checkbox" ${ann.completed ? 'checked' : ''}></div>`;
                const contentHtml = isEditing 
                    ? `<textarea rows="1">${ann.text || ''}</textarea>` 
                    : `<div class="content">${ann.text ? ann.text.replace(/\n/g, '<br>') : '...'}</div>`;

                app.annotationPopup.innerHTML = `
                    <div class="header">
                        <span class="time">${userDisplay}${timeInfo}</span>
                        ${headerToolsHtml}
                    </div>
                    ${contentHtml}
                `;
                app.annotationPopup.style.borderColor = ann.color || '';

                app.annotationPopup.querySelector('.icon-btn[title="Delete"]').onclick = () => deleteAnnotationsByIndices([index]);
                app.annotationPopup.querySelector('.icon-btn[title="Copy Text"]').onclick = () => { if (ann.text) navigator.clipboard.writeText(ann.text); };
                app.annotationPopup.querySelector('.icon-btn[title="Reply"]').onclick = () => addAnnotation({ type: 'reply', artboardId: ann.artboardId, text: '', parentId: ann.id }, true);
                app.annotationPopup.querySelector('.complete-checkbox').onchange = (e) => { 
                    ann.completed = e.target.checked; 
                    markAsChanged(); 
                    redrawAllAnnotations(); 
                    const li = app.annotationList.querySelector(`li[data-id='${ann.id}']`);
                    if (li) {
                        li.classList.toggle('completed', ann.completed);
                        li.querySelector('.complete-checkbox').checked = ann.completed;
                    }
                };
                
                if (isEditing) {
                    const textarea = app.annotationPopup.querySelector('textarea');
                    const autoSize = () => { textarea.style.height = 'auto'; textarea.style.height = `${textarea.scrollHeight}px`; };
                    textarea.addEventListener('input', autoSize);
                    setTimeout(() => { textarea.focus(); textarea.select(); autoSize(); }, 0);
                    
                    const save = () => {
                        const newText = textarea.value;
                        const oldText = ann.text || '';
                        if (newText !== oldText) {
                            historyManager.execute({ type: 'EDIT_TEXT', annotationId: ann.id, before: oldText, after: newText,
                                do: (action) => { const annToUpdate = state.annotations.find(a => a.id === action.annotationId); if(annToUpdate) annToUpdate.text = action.after; updateAnnotationList(); redrawAllAnnotations(); updateAnnotationPopup(); },
                                undo: (action) => { const annToUpdate = state.annotations.find(a => a.id === action.annotationId); if(annToUpdate) annToUpdate.text = action.before; updateAnnotationList(); redrawAllAnnotations(); updateAnnotationPopup(); }
                            });
                        }
                        state.selectedAnnotationIndices = [];
                        state.lastClickedAnnIndex = -1;
                        updateListSelection();
                    };

                    textarea.addEventListener('blur', save, { once: true });
                    textarea.addEventListener('keydown', e => {
                        if (e.key === 'Escape') {
                            e.stopPropagation();
                            textarea.removeEventListener('blur', save);
                            updateAnnotationPopup();
                        }
                        if (e.ctrlKey && e.key === 'Enter') {
                            e.stopPropagation();
                            textarea.blur();
                        }
                    });
                }
                
                app.annotationPopup.style.left = `${screenPos.x}px`;
                app.annotationPopup.style.top = `${screenPos.y}px`;
                app.annotationPopup.classList.remove('hidden');
            }

			function onCanvasMouseDown(e, artboardId) {
                hideContextMenu();
                state.interaction.didDrag = false;

                if (e.button === 2) {
                    e.preventDefault();
                }

                const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return;
                
                if (state.currentTool === 'pan' || state.spacebarPressed || e.button === 1 || e.button === 2) { 
                    startPanning(e); 
                    return; 
                }
                
                const hitGuide = getHitGuide(e);
                if (hitGuide && hitGuide.scope === 'artboard') {
                    e.preventDefault(); e.stopPropagation();
                    if (!hitGuide.guide.id) hitGuide.guide.id = crypto.randomUUID();
                    state.interaction.mode = 'draggingGuide';
                    state.interaction.target = hitGuide;
                    state.interaction.startData.set('guide', { position: hitGuide.guide.position });
                    return;
                }
                
                e.stopPropagation();
                
                selectArtboard(artboardId, e.ctrlKey || e.metaKey);
                if (state.interaction.mode !== 'none') return; 
                
                const pos = getMousePosOnArtboard(e, artboard); 
                state.interaction.startPos = pos;
                const hit = getHitAnnotation(pos, artboardId, true);
                
                if (hit.index !== -1) {
                    if (e.altKey) {
                        app.workspaceContainer.style.cursor = 'copy';
                        const { newAnnotations, newIndices } = duplicateSelectedAnnotations();
                        if (newAnnotations.length > 0) {
                            state.interaction.mode = 'dragging';
                            state.interaction.target = { artboardId, isDuplicating: true, originalAnnotations: state.clipboard };
                            state.interaction.startData.clear();
                            newIndices.forEach(index => {
                                const ann = state.annotations[index];
                                state.interaction.startData.set(ann.id, { artboardId: ann.artboardId, data: JSON.parse(JSON.stringify(ann.data)) });
                            });
                        }
                        return;
                    }
                    
                    if (hit.handle) {
                        state.interaction.mode = 'resizing';
                        state.interaction.target = { index: hit.index, handle: hit.handle, artboardId };
                        const ann = state.annotations[hit.index];
                        state.interaction.startData.set(ann.id, JSON.parse(JSON.stringify(ann.data)));
                    } else {
                        const ann = state.annotations[hit.index];
                        if (ann.videoTime !== undefined) {
                            const artboardEl = document.querySelector(`.artboard[data-id="${artboardId}"]`);
                            const videoEl = artboardEl ? artboardEl.querySelector('video') : null;
                            if (videoEl && !artboard.videoFailedToLoad && Math.abs(videoEl.currentTime - ann.videoTime) > (1 / FRAME_RATE / 2)) {
                                if (!state.selectedAnnotationIndices.includes(hit.index)) {
                                    state.selectedAnnotationIndices = [hit.index];
                                    updateListSelection();
                                }
                                return;
                            }
                        }
                        if (!state.selectedAnnotationIndices.includes(hit.index)) {
                            state.selectedAnnotationIndices = [hit.index];
                            updateListSelection();
                        }
                        state.lastClickedAnnIndex = hit.index;
                        state.interaction.mode = 'dragging';
                        state.interaction.target = { artboardId };
                        state.interaction.startData.clear();
                        state.selectedAnnotationIndices.forEach(index => {
                            const ann = state.annotations[index];
                            state.interaction.startData.set(ann.id, { artboardId: ann.artboardId, data: JSON.parse(JSON.stringify(ann.data)) });
                        });
                    }
                } else {
                    
                    const isSimpleMode = app.movableControls.classList.contains('simple-mode');
                    const hasSelection = state.selectedAnnotationIndices.length > 0;
                    
                    if (isSimpleMode && hasSelection) {
                        state.selectedAnnotationIndices = [];
                        updateListSelection();
                        return;
                    }

                    if (hasSelection) {
                        state.selectedAnnotationIndices = [];
                        updateListSelection();
                    }

                    if (state.currentTool && !['select', 'pan'].includes(state.currentTool)) {
                        if (state.currentTool === 'comment') {
                            addAnnotation({ type: 'comment', artboardId, data: pos, color: state.activeColor, text: '' }, true);
                        } else if (state.currentTool === 'image') {
                            state.interaction.mode = 'placingImage';
                            state.interaction.target = { artboardId };
                            app.imageToolInput.click();
                        } else {
                            state.interaction.mode = 'drawing';
                            state.interaction.target = { artboardId };
                        }
                    }
                }
            }
			
            function getConstrainedPos(startPos, currentPos, tool, isShiftPressed, artboard) {
                if (!isShiftPressed) return currentPos;
                let finalPos = { ...currentPos }; let dx = currentPos.x - startPos.x; let dy = currentPos.y - startPos.y;
                if (tool === 'rect' || tool === 'circle') { const dx_pixels = dx * artboard.width; const dy_pixels = dy * artboard.height; const side_pixels = Math.max(Math.abs(dx_pixels), Math.abs(dy_pixels)); finalPos = { x: startPos.x + (side_pixels * Math.sign(dx_pixels || 1)) / artboard.width, y: startPos.y + (side_pixels * Math.sign(dy_pixels || 1)) / artboard.height }; } 
                else if (tool === 'line' || tool === 'arrow') { if (dx === 0 && dy === 0) return currentPos; const angle = Math.atan2(dy * artboard.height, dx * artboard.width); const snappedAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4); const dist = Math.hypot(dx * artboard.width, dy * artboard.height); finalPos = { x: startPos.x + (dist * Math.cos(snappedAngle)) / artboard.width, y: startPos.y + (dist * Math.sin(snappedAngle)) / artboard.height }; }
                return finalPos;
            }

            function onCanvasMouseMove(e) {
                if (state.interaction.mode === 'none' || !state.interaction.target) return;
                const { artboardId } = state.interaction.target; if (!artboardId) return;
                const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return;
                const currentPos = getMousePosOnArtboard(e, artboard); const { ctxInteraction } = getArtboardCanvases(artboardId); if (!ctxInteraction) return;
                ctxInteraction.clearRect(0, 0, artboard.width, artboard.height);
                switch (state.interaction.mode) {
                    case 'drawing': { const finalPos = getConstrainedPos(state.interaction.startPos, currentPos, state.currentTool, e.shiftKey, artboard); drawShape(ctxInteraction, { type: state.currentTool, data: { p1: state.interaction.startPos, p2: finalPos }, color: state.activeColor }, artboard, false, true); break; }
                    case 'dragging': { const dx = currentPos.x - state.interaction.startPos.x; const dy = currentPos.y - state.interaction.startPos.y; state.selectedAnnotationIndices.forEach(idx => { const ann = state.annotations[idx]; const startData = state.interaction.startData.get(ann.id)?.data; if (!startData) return; if (ann.type === 'comment' || ann.type === 'reply') { ann.data.x = startData.x + dx; ann.data.y = startData.y + dy; } else { ann.data.p1.x = startData.p1.x + dx; ann.data.p1.y = startData.p1.y + dy; ann.data.p2.x = startData.p2.x + dx; ann.data.p2.y = startData.p2.y + dy; } }); redrawAllAnnotations(); break; }
                    case 'resizing': resizeAnnotation(state.interaction.target.index, state.interaction.target.handle, currentPos); redrawAllAnnotations(); break;
                }
            }

            function onCanvasMouseUp(e) {
                if (state.interaction.mode === 'none' || !state.interaction.target) { return; }
                const { artboardId, isDuplicating, originalAnnotations } = state.interaction.target; 
                if (!artboardId) return;
                
                const originalArtboard = state.artboards.find(b => b.id === artboardId);
                if (!originalArtboard) return;

                const { ctxInteraction } = getArtboardCanvases(artboardId);
                if (ctxInteraction) ctxInteraction.clearRect(0, 0, originalArtboard.width, originalArtboard.height);

                if (state.interaction.mode === 'drawing') {
                    const currentPos = getMousePosOnArtboard(e, originalArtboard); const endPos = getConstrainedPos(state.interaction.startPos, currentPos, state.currentTool, e.shiftKey, originalArtboard);
                    if (Math.hypot((endPos.x-state.interaction.startPos.x)*originalArtboard.width, (endPos.y-state.interaction.startPos.y)*originalArtboard.height) > 5) { addAnnotation({ type: state.currentTool, artboardId, data: { p1: state.interaction.startPos, p2: endPos }, color: state.activeColor, text: '' }, true); }
                } else if (state.interaction.mode === 'dragging' || state.interaction.mode === 'resizing') {
                    const beforeState = [];
                    const afterState = [];

                    const targetArtboardEl = document.elementFromPoint(e.clientX, e.clientY)?.closest('.artboard');
                    const targetArtboard = targetArtboardEl ? state.artboards.find(b => b.id === targetArtboardEl.dataset.id) : null;
                    
                    const indicesToUpdate = state.interaction.mode === 'resizing' ? [state.interaction.target.index] : state.selectedAnnotationIndices;

                    indicesToUpdate.forEach(idx => {
                        const ann = state.annotations[idx];
                        const startState = state.interaction.startData.get(ann.id);
                        if (!startState) return;

                        beforeState.push({ id: ann.id, data: startState.data, artboardId: startState.artboardId });

                        let finalData = JSON.parse(JSON.stringify(ann.data));
                        let finalArtboardId = ann.artboardId;

                        if (targetArtboard && targetArtboard.id !== startState.artboardId && state.interaction.mode === 'dragging') {
                            const sourceArtboard = state.artboards.find(b => b.id === startState.artboardId);
                            const workspacePos = {
                                x: sourceArtboard.x + (finalData.p1 ? finalData.p1.x : finalData.x) * sourceArtboard.width,
                                y: sourceArtboard.y + (finalData.p1 ? finalData.p1.y : finalData.y) * sourceArtboard.height
                            };
                            
                            const dx_ws = (finalData.p1 ? (finalData.p2.x - finalData.p1.x) : 0) * sourceArtboard.width;
                            const dy_ws = (finalData.p1 ? (finalData.p2.y - finalData.p1.y) : 0) * sourceArtboard.height;

                            const newRelPos = { x: (workspacePos.x - targetArtboard.x) / targetArtboard.width, y: (workspacePos.y - targetArtboard.y) / targetArtboard.height };
                           
                            if (ann.type === 'comment' || ann.type === 'reply') {
                                finalData.x = newRelPos.x; finalData.y = newRelPos.y;
                            } else {
                                finalData.p1 = newRelPos;
                                finalData.p2 = { x: newRelPos.x + dx_ws / targetArtboard.width, y: newRelPos.y + dy_ws / targetArtboard.height };
                            }
                            finalArtboardId = targetArtboard.id;
                        }
                        afterState.push({ id: ann.id, data: finalData, artboardId: finalArtboardId });
                    });
                    
                    const finalAction = async (action) => {
                         for (const s of action.after) {
                            const ann = state.annotations.find(a => a.id === s.id);
                            if(ann) {
                                ann.data = JSON.parse(JSON.stringify(s.data));
                                ann.artboardId = s.artboardId;
                                const targetBoard = state.artboards.find(b => b.id === s.artboardId);
                                if (targetBoard && targetBoard.type === 'video' && ann.videoTime === undefined) {
                                     const videoEl = document.querySelector(`.artboard[data-id="${targetBoard.id}"] video`);
                                     if (videoEl) {
                                        ann.videoTime = videoEl.currentTime;
                                        const frameData = await captureFrame(videoEl);
                                        const frameKey = ann.videoTime.toFixed(5);
                                        if (!targetBoard.frameBackups) targetBoard.frameBackups = {};
                                        targetBoard.frameBackups[frameKey] = frameData;
                                     }
                                } else if (targetBoard && targetBoard.type !== 'video') {
                                    delete ann.videoTime;
                                }
                            }
                        };
                        redrawAllAnnotations(); 
                        updateAnnotationList();
                        markAsChanged();
                    };

                    const undoAction = (action) => {
                        action.before.forEach(s => { const ann = state.annotations.find(a => a.id === s.id); if(ann) { ann.data = JSON.parse(JSON.stringify(s.data)); ann.artboardId = s.artboardId; } }); 
                        if (isDuplicating) {
                            const idsToRemove = new Set(action.after.map(a => a.id));
                            state.annotations = state.annotations.filter(a => !idsToRemove.has(a.id));
                            state.selectedAnnotationIndices = [];
                        }
                        redrawAllAnnotations(); 
                        updateAnnotationList();
                    };

                    if (isDuplicating) {
                         historyManager.execute({
                            type: 'DUPLICATE_AND_MOVE',
                            originals: originalAnnotations, after: afterState,
                            do: finalAction, undo: undoAction,
                        });
                    } else if (JSON.stringify(beforeState) !== JSON.stringify(afterState)) {
                        historyManager.execute({ 
                            type: 'TRANSFORM_ANNOTATIONS', 
                            before: beforeState, after: afterState,
                            do: finalAction, undo: undoAction
                        });
                    }
                }
            }
            
            function onCanvasDblClick(e, artboardId) { 
                e.stopPropagation(); 
                const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return; 
                const pos = getMousePosOnArtboard(e, artboard); 
                const hit = getHitAnnotation(pos, artboardId, true); 
                if (hit.index !== -1) {
                    state.selectedAnnotationIndices = [hit.index];
                    updateListSelection();
                    if (state.layout.isPanelCollapsed) {
                        updateAnnotationPopup(hit.index);
                    } else {
                        const li = app.annotationList.querySelector(`li[data-id='${state.annotations[hit.index].id}']`); 
                        if (li) {
                            li.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            makeListItemEditable(li, hit.index);
                        }
                    }
                } 
            }
            function global_togglePlayPause(onlySelected) {
                let videos; if (onlySelected && state.selectedArtboardIds.length > 0) { videos = state.selectedArtboardIds.map(id => document.querySelector(`.artboard[data-id="${id}"] video`)).filter(Boolean); } else { videos = Array.from(document.querySelectorAll('#workspace video')); }
                if (videos.length === 0 && onlySelected) { videos = Array.from(document.querySelectorAll('#workspace video'));} if (videos.length === 0) return;
                const isPaused = videos.some(v => v.paused); videos.forEach(v => isPaused ? v.play() : v.pause());
            };
            function global_updatePlayButtonState() { const videos = Array.from(document.querySelectorAll('#workspace video')); const isAnyPlaying = videos.some(v => !v.paused); app.playIcon.classList.toggle('hidden', isAnyPlaying); app.pauseIcon.classList.toggle('hidden', !isAnyPlaying); }
            function global_toggleMute() { state.isGlobalMuted = !state.isGlobalMuted; const muteIcon = document.getElementById('mute-icon'); const unmuteIcon = document.getElementById('unmute-icon'); muteIcon.classList.toggle('hidden', !state.isGlobalMuted); unmuteIcon.classList.toggle('hidden', state.isGlobalMuted); document.querySelectorAll('#workspace video').forEach(v => { v.muted = state.isGlobalMuted; const btn = v.closest('.artboard').querySelector('.vid-mute-btn'); if(btn) btn.innerHTML = state.isGlobalMuted ? MUTE_ICON_SVG : UNMUTE_ICON_SVG; }); }
            function toggleMuteForSelected() { if(state.selectedArtboardIds.length === 0) return; const videos = state.selectedArtboardIds.map(id => document.querySelector(`.artboard[data-id="${id}"] video`)).filter(Boolean); if(videos.length === 0) return; const isAnyUnmuted = videos.some(v => !v.muted); videos.forEach(v => { v.muted = isAnyUnmuted; const btn = v.closest('.artboard').querySelector('.vid-mute-btn'); if(btn) btn.innerHTML = v.muted ? MUTE_ICON_SVG : UNMUTE_ICON_SVG; }); }
            function global_setPlaybackSpeed(speed) { document.querySelectorAll('#workspace video').forEach(v => v.playbackRate = speed); document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed)); }
            function global_seekTo(time) { document.querySelectorAll('#workspace video').forEach(v => { if (isFinite(v.duration)) v.currentTime = Math.min(time, v.duration); }); redrawAllAnnotations(); }
            function advancedSeek({ frameDelta = 0, target = 'selected', position = null }) {
                 let videos; if (target === 'selected' && state.selectedArtboardIds.length > 0) { videos = state.selectedArtboardIds.map(id => document.querySelector(`.artboard[data-id="${id}"] video`)).filter(Boolean); } else { videos = Array.from(document.querySelectorAll('#workspace video')); }
                if (videos.length === 0) return;
                videos.forEach(v => { if (position === 'start') { v.currentTime = 0; } else if (position === 'end') { v.currentTime = v.duration; } else { v.currentTime = Math.max(0, Math.min(v.duration, v.currentTime + (frameDelta / FRAME_RATE))); } });
                redrawAllAnnotations();
            }
            
			function navigateCommentMarkers(direction) {
                if (state.artboards.length === 0) return;

                const sortedArtboards = [...state.artboards].sort((a, b) => a.y - b.y || a.x - b.x);
                let currentArtboardId = state.selectedArtboardIds[0];

                if (!currentArtboardId) {
                    currentArtboardId = sortedArtboards[0].id;
                }
                
                let currentArtboardIndex = sortedArtboards.findIndex(b => b.id === currentArtboardId);

                const getSortKey = (ann) => {
                    let y = 0, x = 0;
                    if (ann.type === 'comment' || ann.type === 'reply') { y = ann.data.y; x = ann.data.x; } 
                    else if (ann.data && ann.data.p1) { y = Math.min(ann.data.p1.y, ann.data.p2.y); x = Math.min(ann.data.p1.x, ann.data.p2.x); }
                    return { time: ann.videoTime, y, x };
                };
                const currentAnnotations = state.annotations
                    .filter(a => a.artboardId === currentArtboardId)
                    .sort((a,b) => {
                        const keyA = getSortKey(a);
                        const keyB = getSortKey(b);
                        if (keyA.time !== undefined && keyB.time !== undefined) {
                            if (Math.abs(keyA.time - keyB.time) > 0.001) return keyA.time - keyB.time;
                        }
                        if (Math.abs(keyA.y - keyB.y) > 0.01) return keyA.y - keyB.y;
                        return keyA.x - keyB.x;
                    });
                
                let currentCommentIndex = -1;
                if (state.selectedAnnotationIndices.length === 1) {
                    const currentAnn = state.annotations[state.selectedAnnotationIndices[0]];
                    if (currentAnn) {
                        currentCommentIndex = currentAnnotations.findIndex(a => a.id === currentAnn.id);
                    }
                }

                const nextCommentIndex = currentCommentIndex + direction;

                if (nextCommentIndex >= 0 && nextCommentIndex < currentAnnotations.length) {
                    const nextAnnotation = currentAnnotations[nextCommentIndex];
                    selectAnnotation(nextAnnotation);
                    return;
                }

                for (let i = 1; i <= sortedArtboards.length; i++) {
                    const nextArtboardIndex = (currentArtboardIndex + (i * direction) + sortedArtboards.length) % sortedArtboards.length;
                    const nextArtboard = sortedArtboards[nextArtboardIndex];
                    
                    const nextArtboardAnnotations = state.annotations
                        .filter(a => a.artboardId === nextArtboard.id)
                        .sort((a,b) => {
                            const keyA = getSortKey(a);
                            const keyB = getSortKey(b);
                            if (keyA.time !== undefined && keyB.time !== undefined) return keyA.time - keyB.time;
                            if (Math.abs(keyA.y - keyB.y) > 0.01) return keyA.y - keyB.y;
                            return keyA.x - keyB.x;
                        });

                    if (nextArtboardAnnotations.length > 0) {
                        const targetAnnotation = direction > 0 ? nextArtboardAnnotations[0] : nextArtboardAnnotations[nextArtboardAnnotations.length - 1];
                        selectArtboard(nextArtboard.id, false);
                        selectAnnotation(targetAnnotation);
                        return;
                    }
                }
            }

            function selectAnnotation(annotation) {
                if (!annotation) return;
                const globalIndex = state.annotations.findIndex(a => a.id === annotation.id);
                if (globalIndex === -1) return;

                state.selectedAnnotationIndices = [globalIndex];
                state.lastClickedAnnIndex = globalIndex;
                updateListSelection();

                const li = app.annotationList.querySelector(`li[data-id='${annotation.id}']`);
                if (li) {
                    li.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                const artboard = state.artboards.find(b => b.id === annotation.artboardId);
                if (artboard && artboard.type === 'video' && annotation.videoTime !== undefined) {
                    const video = document.querySelector(`.artboard[data-id="${artboard.id}"] video`);
                    if (video) {
                        video.currentTime = annotation.videoTime;
                        video.pause();
                    }
                }
            }			
            function drawMasterRuler() {
                const canvas = app.masterTimelineRuler;
                if (!canvas.offsetParent) return;
                const ctx = canvas.getContext('2d');
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;
                canvas.width = width;
                canvas.height = height;

                const duration = parseFloat(app.timelineSlider.max) || 100;
                const isLightTheme = app.body.classList.contains('theme-light');

                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = isLightTheme ? 'rgba(0, 0, 0, 0.3)' : 'rgba(255, 255, 255, 0.4)';
                ctx.fillStyle = isLightTheme ? 'rgba(0, 0, 0, 0.5)' : 'rgba(255, 255, 255, 0.6)';
                ctx.font = '10px sans-serif';
                ctx.textBaseline = 'top';

                const intervals = [1, 5, 10, 30, 60, 300, 600];
                let majorTickSpacing = 1;
                for (const interval of intervals) {
                    majorTickSpacing = interval;
                    if (duration / interval < (width / 80)) { 
                        break;
                    }
                }

                for (let i = 0; i <= duration; i += majorTickSpacing / 5) {
                    const x = (i / duration) * width;
                    const isMajorTick = (i % majorTickSpacing) < (majorTickSpacing / 10);

                    ctx.beginPath();
                    ctx.moveTo(x, height);
                    ctx.lineTo(x, isMajorTick ? height * 0.5 : height * 0.75);
                    ctx.stroke();

                    if (isMajorTick) {
                        ctx.textAlign = 'left';
                        ctx.fillText(formatTime(i), x + 3, 2);
                    }
                }
            }
            
            function masterTimelineUpdater() {
                const videos = Array.from(document.querySelectorAll('#workspace video'));
                const playingVideos = videos.filter(v => !v.paused);
                let videoToFollow = null;

                if (playingVideos.length > 0) {
                    videoToFollow = playingVideos[0];
                } else if (state.selectedArtboardIds.length > 0) {
                    const selectedVideo = document.querySelector(`.artboard[data-id="${state.selectedArtboardIds[0]}"] video`);
                    if (selectedVideo) videoToFollow = selectedVideo;
                } 
                
                if (!videoToFollow && videos.length > 0) {
                    videoToFollow = videos[0];
                }

                if (videoToFollow) {
                    if(!app.timelineSlider.matches(':active')) {
                        app.timelineSlider.value = videoToFollow.currentTime;
                    }
                    if (document.activeElement !== app.timeDisplay) {
                        app.timeDisplay.value = formatTimeHHMMSSFF(videoToFollow.currentTime, videoToFollow.duration);
                    }
                }
                requestAnimationFrame(masterTimelineUpdater);
            }

            function global_updateTimeline() { 
                let maxDuration = 0; 
                const videos = Array.from(document.querySelectorAll('#workspace video')); 
                if (videos.length <= 1) { 
                    app.timelinePanel.classList.add('hidden'); 
                    return; 
                } 
                app.timelinePanel.classList.remove('hidden');
                videos.forEach(v => { 
                    if (isFinite(v.duration) && v.duration > maxDuration) { 
                        maxDuration = v.duration; 
                    } 
                }); 
                app.timelineSlider.max = maxDuration > 0 ? maxDuration : 100; 
                if (app.timelineSlider.oninput) {
                    app.timelineSlider.oninput = null;
                }
                app.timelineSlider.oninput = () => {
                    global_seekTo(parseFloat(app.timelineSlider.value));
                };
                drawMasterRuler();
            }
            const formatTime = (secs) => { if (isNaN(secs)) return '00:00'; const s = Math.floor(secs % 60); const m = Math.floor((secs / 60) % 60); return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; };
            const formatTimeHHMMSSFF = (seconds, duration = 0) => {
                if (isNaN(seconds)) seconds = 0; const totalFrames = Math.round(seconds * FRAME_RATE); const ff = String(totalFrames % FRAME_RATE).padStart(2, '0'); const ss = String(Math.floor(totalFrames / FRAME_RATE) % 60).padStart(2, '0'); const mm = String(Math.floor(totalFrames / (FRAME_RATE*60)) % 60).padStart(2, '0'); const hh = Math.floor(totalFrames / (FRAME_RATE*3600));
                if (duration >= 3600 || hh > 0) { return `${String(hh).padStart(2, '0')}:${mm}:${ss}:${ff}`; } return `${mm}:${ss}:${ff}`;
            };
            const parseMMSSFFToSeconds = (mmssff) => {
                const str = mmssff.replace(/\D/g, '').padStart(6, '0'); const mm = parseInt(str.substring(0, 2), 10); const ss = parseInt(str.substring(2, 4), 10); const ff = parseInt(str.substring(4, 6), 10);
                if (isNaN(mm) || isNaN(ss) || isNaN(ff)) return 0;
                return (mm * 60) + ss + (ff / FRAME_RATE);
            };
            function initTimeInput(inputEl, getTimeFunc, setTimeFunc, getDurationFunc) {
                let originalValue = '';
                inputEl.addEventListener('focus', () => { const duration = getDurationFunc ? getDurationFunc() : 0; originalValue = formatTimeHHMMSSFF(getTimeFunc(), duration); inputEl.value = originalValue.replace(/\D/g, '').slice(-6); });
                inputEl.addEventListener('blur', () => { const newTime = parseMMSSFFToSeconds(inputEl.value); setTimeFunc(newTime); const duration = getDurationFunc ? getDurationFunc() : 0; inputEl.value = formatTimeHHMMSSFF(getTimeFunc(), duration); });
                inputEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); inputEl.blur(); } else if (e.key === 'Escape') { inputEl.value = originalValue; inputEl.blur(); } });
            }

            function promptForUser() { let user = localStorage.getItem('qcToolUser'); if (!user || user.trim() === '') { user = prompt('Please enter your name (max 16 characters):', user || ''); user = user ? user.substring(0, 16) : "Anonymous"; } state.currentUser = user.trim(); localStorage.setItem('qcToolUser', state.currentUser); updateUserDisplay(); }
            function changeUser() { let user = prompt('Enter new name (max 16 characters):', state.currentUser); if (user && user.trim() !== '') { state.currentUser = user.trim().substring(0, 16); localStorage.setItem('qcToolUser', state.currentUser); updateUserDisplay(); } }
            function updateUserDisplay() { document.getElementById('current-user-display').textContent = state.currentUser; }
            function applyTheme(theme) { app.body.classList.remove('theme-light', 'theme-dark'); if (theme === 'light') app.body.classList.add('theme-light'); else if (theme === 'dark') app.body.classList.add('theme-dark'); else { if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) app.body.classList.add('theme-light'); else app.body.classList.add('theme-dark'); } drawMasterRuler(); }
            function setTheme(theme) { applyTheme(theme); localStorage.setItem('qcToolTheme', theme); document.getElementById('theme-selector').value = theme; }
            function initTheme() { const savedTheme = localStorage.getItem('qcToolTheme') || 'dark'; setTheme(savedTheme); window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', () => { const currentSetting = localStorage.getItem('qcToolTheme') || 'system'; if (currentSetting === 'system') applyTheme('system'); }); document.getElementById('theme-selector').addEventListener('change', e => setTheme(e.target.value)); }
            function initPanelResize(e) { e.preventDefault(); const startX = e.clientX; const startWidth = app.rightPanel.offsetWidth; const doResize = (e) => { const newWidth = startWidth - (e.clientX - startX); if (newWidth > 250 && newWidth < 800) { app.rightPanel.style.flexBasis = newWidth + 'px'; } }; const stopResize = () => { window.removeEventListener('mousemove', doResize); window.removeEventListener('mouseup', stopResize); }; window.addEventListener('mousemove', doResize); window.addEventListener('mouseup', stopResize); }
            const selectColor = btn => { state.activeColor = btn.dataset.color; document.getElementById('active-color-btn').style.backgroundColor = state.activeColor; document.getElementById('color-palette-popup').classList.add('hidden'); };
            const toggleColorPalette = () => document.getElementById('color-palette-popup').classList.toggle('hidden');
            function markAsChanged() { if (!state.hasUnsavedChanges) { state.hasUnsavedChanges = true; updateSaveButtonState(); } triggerAutoSave(); }
            function updateSaveButtonState() { const count = state.annotations.length; const countText = count > 0 ? ` (${count} cmt)` : ''; if(app.saveBtn.classList.contains('saving')) return; if (state.hasUnsavedChanges) { app.saveBtn.textContent = `Unsaved${countText}`; app.saveBtn.classList.add('unsaved'); } else { app.saveBtn.classList.remove('unsaved'); app.saveBtn.textContent = state.currentFileHandle ? `Saved${countText}` : `Save HTML File${countText}`; } }
            
            async function saveStateSilently() { if (!state.currentFileHandle) return; const htmlContent = await generateAnnotatedHTML(); try { const writable = await state.currentFileHandle.createWritable(); await writable.write(htmlContent); await writable.close(); state.hasUnsavedChanges = false; app.saveBtn.classList.remove('saving'); updateSaveButtonState(); } catch (err) { console.error('Auto-save failed:', err); app.saveBtn.classList.remove('saving', 'unsaved'); app.saveBtn.textContent = 'Save Error'; } }
            function triggerAutoSave() { clearTimeout(autoSaveTimeout); if (!state.currentFileHandle) return; autoSaveTimeout = setTimeout(() => { app.saveBtn.classList.remove('unsaved'); app.saveBtn.classList.add('saving'); app.saveBtn.textContent = 'Saving...'; saveStateSilently(); }, 2000); }

            async function generateAnnotatedHTML() {
                const dataToSave = {
                    artboards: state.artboards.map(board => { const { id, name, type, htmlContent, x, y, width, height, originalWidth, originalHeight, scale, frameBackups, src } = board; const artboardData = { id, name, type, x, y, width, height, originalWidth, originalHeight, scale }; if (htmlContent) artboardData.htmlContent = htmlContent; if (frameBackups) artboardData.frameBackups = frameBackups; if (src) { if (src.startsWith('data:')) { artboardData.src = src; } else if (src.startsWith('blob:')) { artboardData.src = name; } else { artboardData.src = src; } }  else { artboardData.src = name; } return artboardData; }),
                    annotations: state.annotations, layout: state.layout, guides: state.guides, toolbar: state.toolbar,
                };
                const dataStr = JSON.stringify(dataToSave, null, 2);
                const docClone = document.cloneNode(true); docClone.getElementById('app-data').textContent = '\n' + dataStr + '\n';
                const bodyTag = docClone.querySelector('body'); if (bodyTag) { bodyTag.classList.remove('spacebar-down', 'panning', 'dragging'); }
                return `<!DOCTYPE html>\n` + docClone.documentElement.outerHTML;
            }
            async function saveState() { if (!state.currentFileHandle) { await saveStateAs(); return; } await saveStateSilently(); }

			async function saveStateAs() {
                const htmlContent = await generateAnnotatedHTML();
                
                let suggestedName = 'Media_QC.html';
                if (state.artboards.length > 0) {
                    const firstFileName = state.artboards[0].name;
                    const baseName = firstFileName.substring(0, firstFileName.lastIndexOf('.')) || firstFileName;
                    suggestedName = `${baseName}_QC.html`;
                }

                const fallbackSave = (data) => {
                    const blob = new Blob([data], { type: 'text/html;charset=utf-8' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = suggestedName;
                    a.click();
                    URL.revokeObjectURL(a.href);
                    state.hasUnsavedChanges = false;
                    updateSaveButtonState();
                };

                if ('showSaveFilePicker' in window) {
                    try {
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: suggestedName,
                            types: [{ description: 'HTML QC File', accept: { 'text/html': ['.html'] } }]
                        });
                        const writable = await fileHandle.createWritable();
                        await writable.write(htmlContent);
                        await writable.close();
                        state.currentFileHandle = fileHandle;
                        state.hasUnsavedChanges = false;
                        updateSaveButtonState();
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            console.error('Error saving file:', err);
                            fallbackSave(htmlContent);
                        }
                    }
                } else {
                    fallbackSave(htmlContent);
                }
            }
			
            function deleteAnnotationsByIndices(indicesToDelete) {
                if (!indicesToDelete || indicesToDelete.length === 0) return;
                const idsToDelete = new Set(); const queue = indicesToDelete.map(index => state.annotations[index]?.id).filter(id => id); queue.forEach(id => idsToDelete.add(id)); let currentQueue = [...queue];
                while(currentQueue.length > 0) { const parentId = currentQueue.shift(); const children = state.annotations.filter(ann => ann.parentId === parentId); children.forEach(child => { if (!idsToDelete.has(child.id)) { idsToDelete.add(child.id); currentQueue.push(child.id); } }); }
                const deletedItems = state.annotations.map((annotation, originalIndex) => ({ annotation, originalIndex })).filter(item => idsToDelete.has(item.annotation.id)).sort((a,b) => a.originalIndex - b.originalIndex);
                if (deletedItems.length === 0) return;
                historyManager.execute({ type: 'DELETE_ANNOTATIONS', items: deletedItems,
                    do: () => { 
                        state.annotations = state.annotations.filter(ann => !idsToDelete.has(ann.id)); 
                        state.selectedAnnotationIndices = []; 
                        state.lastClickedAnnIndex = -1; 
                        updateAnnotationList(); 
                        redrawAllAnnotations(); 
                        drawAnnotationConnectorLines();
                        updateAnnotationPopup();
                    },
                    undo: (action) => { action.items.forEach(item => state.annotations.splice(item.originalIndex, 0, item.annotation)); state.selectedAnnotationIndices = action.items.map(item => item.originalIndex); updateAnnotationList(); redrawAllAnnotations(); }
                });
            }
			
            function updateListSelection() {
                const selectedIds = new Set(state.selectedAnnotationIndices.map(i => state.annotations[i]?.id).filter(Boolean));
                document.querySelectorAll('#annotation-list li:not(.group-header)').forEach(item => {
                    const isSelected = selectedIds.has(item.dataset.id);
                    item.classList.toggle('selected', isSelected);
                    
                    if (isSelected) {
                        const ann = state.annotations.find(a => a.id === item.dataset.id);
                        if (ann && ann.color) {
                            item.style.borderColor = ann.color;
                            item.style.boxShadow = `0 0 0 2px ${ann.color} inset`;
                        } else {
                            item.style.borderColor = '';
                            item.style.boxShadow = '';
                        }
                    } else {
                        item.style.borderColor = '';
                        item.style.boxShadow = '';
                    }
                });
                redrawAllAnnotations();
                drawAnnotationConnectorLines();
                updateAnnotationPopup();
            }
			
            function makeListItemEditable(li, index) { 
                let contentEl = li.querySelector('.content'); if (!contentEl) { contentEl = document.createElement('p'); contentEl.className = 'content'; li.appendChild(contentEl); } 
                if (contentEl.querySelector('textarea')) return; const ann = state.annotations[index]; const oldText = ann.text || ''; 
                contentEl.innerHTML = `<textarea rows="1">${oldText}</textarea>`; 
                const textarea = contentEl.querySelector('textarea'); const autoSize = () => { textarea.style.height = 'auto'; textarea.style.height = `${textarea.scrollHeight}px`; }; 
                textarea.addEventListener('input', autoSize); setTimeout(() => { textarea.focus(); textarea.select(); autoSize(); }, 0); 
                const save = () => { 
                    const newText = textarea.value; 
                    if (newText !== oldText) { 
                        historyManager.execute({ type: 'EDIT_TEXT', annotationId: ann.id, before: oldText, after: newText,
                            do: () => { const annToUpdate = state.annotations.find(a => a.id === ann.id); if(annToUpdate) annToUpdate.text = newText; updateAnnotationList(); redrawAllAnnotations(); updateAnnotationPopup(); },
                            undo: () => { const annToUpdate = state.annotations.find(a => a.id === ann.id); if(annToUpdate) annToUpdate.text = oldText; updateAnnotationList(); redrawAllAnnotations(); updateAnnotationPopup(); } });
                    }
                    updateAnnotationList();
                    state.selectedAnnotationIndices = [];
                    state.lastClickedAnnIndex = -1;
                    updateListSelection();
                }; 
                textarea.addEventListener('blur', save, { once: true }); 
                textarea.addEventListener('keydown', e => { 
                    if (e.key === 'Escape') { 
                        e.stopPropagation(); 
                        textarea.removeEventListener('blur', save); 
                        updateAnnotationList();
                    } 
                    if (e.ctrlKey && e.key === 'Enter') { 
                        e.stopPropagation(); 
                        textarea.blur(); 
                    } 
                }); 
            }
            function redrawArtboardAnnotations(artboardId) {
                const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return;
                const artboardEl = app.workspace.querySelector(`.artboard[data-id="${artboardId}"]`); if (!artboardEl) return;
                const displayCanvas = artboardEl.querySelector('.display-canvas');
                const videoEl = (artboard.type === 'video') ? artboardEl.querySelector('video') : null;
                const backupImg = (artboard.type === 'video') ? artboardEl.querySelector('.frame-backup') : null;
                const ctx = displayCanvas.getContext('2d');
                displayCanvas.width = artboard.width; displayCanvas.height = artboard.height;
                artboardEl.querySelector('.interaction-canvas').width = artboard.width; artboardEl.querySelector('.interaction-canvas').height = artboard.height;
                ctx.clearRect(0, 0, displayCanvas.width, displayCanvas.height);
                if (videoEl && backupImg && artboard.videoFailedToLoad) {
                    let bestMatchTime = null; let minDiff = 1 / FRAME_RATE;
                    const currentTime = parseFloat(artboardEl.querySelector('.vid-timeline').value);
                    if (artboard.frameBackups) { for (const timeStr in artboard.frameBackups) { const time = parseFloat(timeStr); const diff = Math.abs(currentTime - time); if (diff < minDiff) { minDiff = diff; bestMatchTime = time; } } }
                    if (bestMatchTime !== null) { const frameKey = bestMatchTime.toFixed(5); if (backupImg.src !== artboard.frameBackups[frameKey]) { backupImg.src = artboard.frameBackups[frameKey]; } backupImg.classList.remove('hidden'); } else { backupImg.classList.add('hidden'); }
                } else if (backupImg) { backupImg.classList.add('hidden'); }
                state.annotations.forEach((ann, index) => {
                    if (ann.artboardId === artboard.id) {
                        let shouldDraw = true;
                        if (videoEl && ann.videoTime !== undefined) { const currentTime = artboard.videoFailedToLoad ? parseFloat(artboardEl.querySelector('.vid-timeline').value) : videoEl.currentTime; if (Math.abs(currentTime - ann.videoTime) > (1 / FRAME_RATE / 2)) { shouldDraw = false; } }
                        if(shouldDraw) { const isSelected = state.selectedAnnotationIndices.includes(index); drawShape(ctx, ann, artboard, isSelected); if (isSelected && ann.type !== 'comment' && ann.type !== 'reply') { drawHandles(ctx, ann, artboard); } }
                    }
                });
                if (videoEl) {
                    const markerCanvas = artboardEl.querySelector('.vid-timeline-markers'); const mCtx = markerCanvas.getContext('2d');
                    const w = markerCanvas.offsetWidth; const h = markerCanvas.offsetHeight; markerCanvas.width = w; markerCanvas.height = h; mCtx.clearRect(0, 0, w, h);
                    const markerTimes = [...new Set(state.annotations.filter(a => a.artboardId === artboardId && a.videoTime !== undefined).map(a => a.videoTime))];
                    if(markerTimes.length > 0) { mCtx.fillStyle = '#ffc107'; const duration = isNaN(videoEl.duration) ? 100 : videoEl.duration; markerTimes.forEach(time => { const x = (time / duration) * w; mCtx.fillRect(x - 1, 0, 2, h); }); }
                }
            }
            function redrawAllAnnotations() { state.artboards.forEach(artboard => redrawArtboardAnnotations(artboard.id)); }
            
            function updateZoomDisplay() {
                const zoomPercent = Math.round(state.view.scale * 100);
                document.getElementById('zoom-display-btn').textContent = `${zoomPercent}%`;
            }
            function updateWorkspaceTransform() { 
                const { offsetX, offsetY, scale } = state.view; 
                app.workspace.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`; 
                updateZoomDisplay();
                drawAnnotationConnectorLines();
                updateAnnotationPopup();
            }
            function zoomAtPoint(factor, x, y) { 
                const oldScale = state.view.scale; 
                const newScale = Math.max(state.view.minScale, Math.min(state.view.maxScale, oldScale * factor)); 
                state.view.scale = newScale; 
                state.view.offsetX = x - (x - state.view.offsetX) * (newScale / oldScale); 
                state.view.offsetY = y - (y - state.view.offsetY) * (newScale / oldScale); 
                updateWorkspaceTransform(); 
            }
            function setZoom(scale) {
                const rect = app.workspaceContainer.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                const oldScale = state.view.scale;
                const newScale = Math.max(state.view.minScale, Math.min(state.view.maxScale, scale));
                
                state.view.offsetX = centerX - (centerX - state.view.offsetX) * (newScale / oldScale);
                state.view.offsetY = centerY - (centerY - state.view.offsetY) * (newScale / oldScale);
                state.view.scale = newScale;
                
                updateWorkspaceTransform();
                document.getElementById('zoom-dropdown').classList.add('hidden');
            }

            function fitArtboardToView(artboardId) {
                const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return;
                const PADDING = 20;
                const container = app.workspaceContainer;
                const artboardEl = document.querySelector(`.artboard[data-id="${artboardId}"]`); if(!artboardEl) return;
                const artboardHeight = artboardEl.offsetHeight;
                const availableWidth = container.offsetWidth - 2 * PADDING;
                const availableHeight = container.offsetHeight - 2 * PADDING;
                const scaleX = availableWidth / artboard.width;
                const scaleY = availableHeight / artboardHeight;
                const newScale = Math.min(scaleX, scaleY);
                state.view.scale = newScale;
                state.view.offsetX = (container.offsetWidth - artboard.width * newScale) / 2 - artboard.x * newScale;
                state.view.offsetY = (container.offsetHeight - artboardHeight * newScale) / 2 - artboard.y * newScale;
                updateWorkspaceTransform();
            }
            function fitAllArtboardsToView() { if (state.artboards.length === 0) return; const PADDING = 50; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; state.artboards.forEach(b => { const artboardEl = document.querySelector(`.artboard[data-id="${b.id}"]`); const height = artboardEl ? artboardEl.offsetHeight : (b.height + 30 + (b.type==='video' ? 32:0)); minX = Math.min(minX, b.x); minY = Math.min(minY, b.y); maxX = Math.max(maxX, b.x + b.width); maxY = Math.max(maxY, b.y + height); }); const totalWidth = maxX - minX; const totalHeight = maxY - minY; if (totalWidth === 0 || totalHeight === 0) return; const container = app.workspaceContainer; const scaleX = (container.offsetWidth - 2 * PADDING) / totalWidth; const scaleY = (container.offsetHeight - 2 * PADDING) / totalHeight; const newScale = Math.min(scaleX, scaleY, 1); state.view.scale = newScale; state.view.offsetX = (container.offsetWidth - totalWidth * newScale) / 2 - minX * newScale; state.view.offsetY = (container.offsetHeight - totalHeight * newScale) / 2 - minY * newScale; updateWorkspaceTransform(); }
            function onArtboardHeaderMouseDown(e, artboardId) {
                hideContextMenu();
                state.interaction.didDrag = false;

                if (e.button === 1 || e.button === 2 || state.spacebarPressed) {
                    e.preventDefault();
                    startPanning(e);
                    return;
                }

                if (e.button !== 0) return;

                e.stopPropagation(); 
                selectArtboard(artboardId, e.ctrlKey || e.metaKey);
                state.interaction.mode = 'draggingArtboard'; 
                state.interaction.target = { artboardId }; 
                state.interaction.startPos = getWorkspaceMousePos(e); 
                state.interaction.startData.clear();
                state.selectedArtboardIds.forEach(id => { const board = state.artboards.find(b => b.id === id); if (board) { state.interaction.startData.set(id, { x: board.x, y: board.y }); } });
                document.querySelectorAll('.artboard.selected').forEach(el => el.classList.add('dragging'));
            }
			
            function onArtboardDrag(e) { if (state.interaction.mode !== 'draggingArtboard') return; const currentPos = getWorkspaceMousePos(e); const dx = currentPos.x - state.interaction.startPos.x; const dy = currentPos.y - state.interaction.startPos.y; state.selectedArtboardIds.forEach(id => { const board = state.artboards.find(b => b.id === id); const startPos = state.interaction.startData.get(id); if (board && startPos) { board.x = startPos.x + dx; board.y = startPos.y + dy; const el = document.querySelector(`.artboard[data-id="${id}"]`); if (el) { el.style.left = `${board.x}px`; el.style.top = `${board.y}px`; } } }); drawGuides(); }
            function onArtboardResizeMouseDown(e, artboardId) { e.stopPropagation(); const artboard = state.artboards.find(b => b.id === artboardId); if(!artboard) return; state.interaction = { mode: 'resizingArtboard', target: { artboardId }, startPos: { x: e.clientX, y: e.clientY }, startWidth: artboard.width, startHeight: artboard.height }; document.querySelector(`.artboard[data-id="${artboardId}"]`).classList.add('dragging'); }
            function onArtboardResize(e) { if (state.interaction.mode !== 'resizingArtboard') return; const { artboardId } = state.interaction.target; const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return; const dx = e.clientX - state.interaction.startPos.x; const newWidth = state.interaction.startWidth + (dx / state.view.scale); const aspectRatio = artboard.originalWidth / artboard.originalHeight; artboard.width = Math.max(50, newWidth); artboard.height = artboard.width / aspectRatio; artboard.scale = artboard.width / artboard.originalWidth; redrawArtboard(artboardId); markAsChanged(); }
            function resetArtboardScale(artboardId) { const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return; artboard.scale = 1; artboard.width = artboard.originalWidth; artboard.height = artboard.originalHeight; redrawArtboard(artboardId); markAsChanged(); }
            const getWorkspaceMousePos = (e) => { const rect = app.workspaceContainer.getBoundingClientRect(); return { x: (e.clientX - rect.left - state.view.offsetX) / state.view.scale, y: (e.clientY - rect.top - state.view.offsetY) / state.view.scale }; };
            const getMousePosOnArtboard = (e, artboard) => { const artboardEl = app.workspace.querySelector(`.artboard[data-id="${artboard.id}"]`); if (!artboardEl) return {x:0, y:0}; const contentEl = artboardEl.querySelector('.artboard-content'); const rect = contentEl.getBoundingClientRect(); return { x: (e.clientX - rect.left) / rect.width, y: (e.clientY - rect.top) / rect.height }; };
            const getArtboardCanvases = (artboardId) => { const el = app.workspace.querySelector(`.artboard[data-id="${artboardId}"]`); if (!el) return {}; return { guideCanvas: el.querySelector('.guide-canvas'), displayCanvas: el.querySelector('.display-canvas'), interactionCanvas: el.querySelector('.interaction-canvas'), ctxDisplay: el.querySelector('.display-canvas').getContext('2d'), ctxInteraction: el.querySelector('.interaction-canvas').getContext('2d') }; };
            function resizeAnnotation(index, handle, pos) {
                const ann = state.annotations[index]; const { p1, p2 } = ann.data;
                const minX = Math.min(p1.x, p2.x), minY = Math.min(p1.y, p2.y), maxX = Math.max(p1.x, p2.x), maxY = Math.max(p1.y, p2.y);
                if (ann.type === 'image' && ann.data.imgRatio) {
                    let anchorX, anchorY; if (handle.includes('t')) { anchorY = maxY; } else { anchorY = minY; } if (handle.includes('l')) { anchorX = maxX; } else { anchorX = minX; }
                    const artboard = state.artboards.find(b => b.id === ann.artboardId); if(!artboard) return;
                    const artboardRatio = artboard.width / artboard.height; const visualImgRatio = ann.data.imgRatio / artboardRatio;
                    let newWidthNorm = Math.abs(pos.x - anchorX); let newHeightNorm = Math.abs(pos.y - anchorY);
                    if (newWidthNorm / newHeightNorm > visualImgRatio) { newHeightNorm = newWidthNorm / visualImgRatio; } else { newWidthNorm = newHeightNorm * visualImgRatio; }
                    const p1x = (handle.includes('l')) ? anchorX - newWidthNorm : anchorX; const p1y = (handle.includes('t')) ? anchorY - newHeightNorm : anchorY;
                    const p2x = (handle.includes('l')) ? anchorX : anchorX + newWidthNorm; const p2y = (handle.includes('t')) ? anchorY : anchorY + newHeightNorm;
                    ann.data.p1 = { x: p1x, y: p1y }; ann.data.p2 = { x: p2x, y: p2y };
                } else { if (handle === 'p1') { ann.data.p1 = pos; return; } if (handle === 'p2') { ann.data.p2 = pos; return; } let anchor = { x: 0, y: 0 }; if (handle.includes('t')) anchor.y = maxY; else anchor.y = minY; if (handle.includes('l')) anchor.x = maxX; else anchor.x = minX; ann.data.p1 = anchor; ann.data.p2 = pos; }
            }
            function getHitAnnotation(pos, artboardId, allowAnyTool = false) {
                let found = { index: -1, handle: null, cursor: 'default' }; 
                if (state.currentTool === 'pan') return found;
                if (state.currentTool !== 'select' && !allowAnyTool) return found;

                const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return found; 
                for (let i = state.annotations.length - 1; i >= 0; i--) { 
                    const ann = state.annotations[i]; if (ann.artboardId !== artboardId) continue;
                    if (artboard.type === 'video' && ann.videoTime !== undefined) { const artboardEl = document.querySelector(`.artboard[data-id="${artboardId}"]`); const videoEl = artboardEl ? artboardEl.querySelector('video') : null; const currentTime = (videoEl && !artboard.videoFailedToLoad) ? videoEl.currentTime : parseFloat(artboardEl.querySelector('.vid-timeline').value); if (Math.abs(currentTime - ann.videoTime) > (1 / FRAME_RATE / 2)) { continue; } }
                    if (state.selectedAnnotationIndices.includes(i) && ann.type !== 'comment' && ann.type !== 'reply') { const handle = getHitHandle(pos, ann); if (handle) return { index: i, handle: handle.name, cursor: handle.cursor }; } 
                    let hit = false; 
                    if (ann.type === 'comment') { const iconSizePx = 24, offsetX = -2, offsetY = -22; const normWidth = iconSizePx / artboard.width, normHeight = iconSizePx / artboard.height; const normOffsetX = offsetX / artboard.width, normOffsetY = offsetY / artboard.height; const iconLeft = ann.data.x + normOffsetX, iconTop = ann.data.y + normOffsetY; hit = (pos.x >= iconLeft && pos.x <= iconLeft + normWidth && pos.y >= iconTop && pos.y <= iconTop + normHeight); } 
                    else if (ann.type !== 'reply') { const { p1, p2 } = ann.data; const padding = 10 / Math.min(artboard.width, artboard.height); const minX = Math.min(p1.x, p2.x) - padding, minY = Math.min(p1.y, p2.y) - padding, maxX = Math.max(p1.x, p2.x) + padding, maxY = Math.max(p1.y, p2.y) + padding; hit = (pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY); } 
                    if (hit) return { index: i, handle: null, cursor: 'move' }; 
                } 
                return found; 
            }
            const getHandlesFor = (ann) => { if (ann.type === 'reply' || ann.type === 'comment') return []; const { p1, p2 } = ann.data; if (ann.type === 'line' || ann.type === 'arrow') return [ { name: 'p1', x: p1.x, y: p1.y, cursor: 'pointer' }, { name: 'p2', x: p2.x, y: p2.y, cursor: 'pointer' } ]; const minX = Math.min(p1.x, p2.x), minY = Math.min(p1.y, p2.y), maxX = Math.max(p1.x, p2.x), maxY = Math.max(p1.y, p2.y); return [ { name: 'tl', x: minX, y: minY, cursor: 'nwse-resize' }, { name: 'tr', x: maxX, y: minY, cursor: 'nesw-resize' }, { name: 'bl', x: minX, y: maxY, cursor: 'nesw-resize' }, { name: 'br', x: maxX, y: maxY, cursor: 'nwse-resize' } ]; };
            const getHitHandle = (pos, ann) => { const artboard = state.artboards.find(b => b.id === ann.artboardId); if (!artboard) return null; const handleSizePx = 16; const handleRadiusX = (handleSizePx / artboard.width) / 2; const handleRadiusY = (handleSizePx / artboard.height) / 2; return getHandlesFor(ann).find(h => pos.x > h.x - handleRadiusX && pos.x < h.x + handleRadiusX && pos.y > h.y - handleRadiusY && pos.y < h.y + handleRadiusY) || null; }
            function drawShape(ctx, ann, artboard, isSelected, isPreview = false) { ctx.save(); const { type, data, color } = ann; ctx.strokeStyle = color || state.activeColor; ctx.lineWidth = isSelected ? 4 : 2; if(isPreview) { ctx.setLineDash([6, 3]); ctx.lineWidth = 3; } const denorm = (p) => ({ x: p.x * artboard.width, y: p.y * artboard.height }); ctx.beginPath(); switch (type) { case 'comment': { const pos = denorm(data); const size = 24; ctx.fillStyle = color || state.activeColor; const path = new Path2D("M3,12v9h9c5,0,9-4,9-9h0c0-5-4-9-9-9h0C7,3,3,7,3,12Z"); ctx.save(); ctx.translate(pos.x, pos.y); ctx.scale(size / 24, size / 24); ctx.translate(-2, -22); ctx.fill(path); ctx.restore(); if (isSelected) { ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.beginPath(); ctx.arc(pos.x, pos.y, 12, 0, 2 * Math.PI); ctx.fill(); } break; } case 'rect': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); ctx.rect(p1_abs.x, p1_abs.y, p2_abs.x - p1_abs.x, p2_abs.y - p1_abs.y); break; } case 'circle': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); ctx.ellipse(p1_abs.x + (p2_abs.x-p1_abs.x)/2, p1_abs.y + (p2_abs.y-p1_abs.y)/2, Math.abs((p2_abs.x-p1_abs.x)/2), Math.abs((p2_abs.y-p1_abs.y)/2), 0, 0, 2 * Math.PI); break; } case 'line': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); ctx.moveTo(p1_abs.x, p1_abs.y); ctx.lineTo(p2_abs.x, p2_abs.y); break; } case 'arrow': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); const h = 15, dx = p2_abs.x - p1_abs.x, dy = p2_abs.y - p1_abs.y, a = Math.atan2(dy, dx); ctx.moveTo(p1_abs.x, p1_abs.y); ctx.lineTo(p2_abs.x, p2_abs.y); ctx.lineTo(p2_abs.x - h * Math.cos(a - Math.PI / 6), p2_abs.y - h * Math.sin(a - Math.PI / 6)); ctx.moveTo(p2_abs.x, p2_abs.y); ctx.lineTo(p2_abs.x - h * Math.cos(a + Math.PI / 6), p2_abs.y - h * Math.sin(a + Math.PI / 6)); break; } case 'image': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); let img = imageAnnotationCache.get(ann.id); if (!img) { img = new Image(); img.src = data.imageData; imageAnnotationCache.set(ann.id, img); } if (img.complete && img.naturalWidth > 0) { ctx.drawImage(img, p1_abs.x, p1_abs.y, p2_abs.x - p1_abs.x, p2_abs.y - p1_abs.y); } else { img.onload = () => redrawArtboardAnnotations(ann.artboardId); } ctx.rect(p1_abs.x, p1_abs.y, p2_abs.x - p1_abs.x, p2_abs.y - p1_abs.y); break; } case 'reply': break; } if (type !== 'comment' && type !== 'reply') ctx.stroke(); ctx.restore(); }
            function drawHandles(ctx, ann, artboard) { if (ann.type === 'reply') return; ctx.save(); const handles = getHandlesFor(ann); ctx.fillStyle = 'white'; ctx.strokeStyle = '#333'; ctx.lineWidth = 1; const handleSize = 10; handles.forEach(h => { const x_abs = h.x * artboard.width; const y_abs = h.y * artboard.height; ctx.fillRect(x_abs - handleSize/2, y_abs - handleSize/2, handleSize, handleSize); ctx.strokeRect(x_abs - handleSize/2, y_abs - handleSize/2, handleSize, handleSize); }); ctx.restore(); }
            function redrawArtboard(artboardId){ const artboard = state.artboards.find(b => b.id === artboardId); if(!artboard) return; const artboardEl = app.workspace.querySelector(`.artboard[data-id="${artboardId}"]`); if(!artboardEl) return; const controlsHeight = artboard.type === 'video' ? 32 : 0; artboardEl.style.width = `${artboard.width}px`; artboardEl.style.height = `${artboard.height + 30 + controlsHeight}px`; const dimensionsDisplay = `<span class="artboard-info">(${artboard.originalWidth}x${artboard.originalHeight})</span>`; const infoWrapper = artboardEl.querySelector('.artboard-info-wrapper'); infoWrapper.innerHTML = `${dimensionsDisplay}`; redrawAllAnnotations(); drawGuides(); }
            function resizeAllVideosTo720p() { state.artboards.forEach(artboard => { if (artboard.type === 'video' && artboard.originalHeight > 0) { const targetHeight = 720; const aspectRatio = artboard.originalWidth / artboard.originalHeight; artboard.height = targetHeight; artboard.width = targetHeight * aspectRatio; artboard.scale = artboard.height / artboard.originalHeight; redrawArtboard(artboard.id); } }); markAsChanged(); }
            function rearrangeArtboards() {
                if (state.artboards.length === 0) return;
                const { margin } = state.layout; let currentY = margin;
                const layoutGroup = (group, startY) => {
                    let nextX = margin; let nextY = startY; let rowMaxHeight = 0;
                    group.sort((a,b) => a.name.localeCompare(b.name)).forEach(board => {
                        const controlsHeight = board.type === 'video' ? 32 : 0; const boardHeight = board.height + 30 + controlsHeight;
                        if (nextX + board.width > state.layout.maxRowWidth && nextX > margin) { nextY += rowMaxHeight + margin; nextX = margin; rowMaxHeight = 0; }
                        board.x = nextX; board.y = nextY; nextX += board.width + margin; rowMaxHeight = Math.max(rowMaxHeight, boardHeight);
                        const boardEl = document.querySelector(`.artboard[data-id="${board.id}"]`); if (boardEl) { boardEl.style.left = `${board.x}px`; boardEl.style.top = `${board.y}px`; }
                    });
                    return nextY + rowMaxHeight;
                };
                const videos = state.artboards.filter(b => b.type === 'video'); const images = state.artboards.filter(b => b.type === 'image');
                if (videos.length > 0) currentY = layoutGroup(videos, currentY) + margin;
                if (images.length > 0) currentY = layoutGroup(images, currentY) + margin;
                renderWorkspace(); markAsChanged();
            }
            function copyAnnotations() { if (state.selectedAnnotationIndices.length === 0) return; const allIdsToCopy = new Set(); const queue = state.selectedAnnotationIndices.map(index => state.annotations[index].id); queue.forEach(id => allIdsToCopy.add(id)); const traversalQueue = [...queue]; while (traversalQueue.length > 0) { const parentId = traversalQueue.shift(); const children = state.annotations.filter(ann => ann.parentId === parentId); for (const child of children) { if (!allIdsToCopy.has(child.id)) { allIdsToCopy.add(child.id); traversalQueue.push(child.id); } } } state.clipboard = state.annotations.filter(ann => allIdsToCopy.has(ann.id)).map(ann => JSON.parse(JSON.stringify(ann))); }
            
            function duplicateSelectedAnnotations() {
                copyAnnotations();
                if (state.clipboard.length === 0) return { newAnnotations: [], newIndices: [] };

                const oldIdToNewIdMap = new Map();
                const newAnnotations = state.clipboard.map(clipboardAnn => {
                    const newAnn = JSON.parse(JSON.stringify(clipboardAnn));
                    const newId = crypto.randomUUID();
                    oldIdToNewIdMap.set(clipboardAnn.id, newId);
                    newAnn.id = newId;
                    return newAnn;
                });

                newAnnotations.forEach(newAnn => {
                    if (newAnn.parentId && oldIdToNewIdMap.has(newAnn.parentId)) {
                        newAnn.parentId = oldIdToNewIdMap.get(newAnn.parentId);
                    } else {
                        newAnn.parentId = null;
                    }
                });

                state.annotations.push(...newAnnotations);
                const newIndices = newAnnotations.map(ann => state.annotations.indexOf(ann));
                state.selectedAnnotationIndices = newIndices;
                updateAnnotationList();
                redrawAllAnnotations();

                return { newAnnotations, newIndices };
            }

            function isAnnotationOutOfBounds(ann) {
                if (ann.type === 'comment' || ann.type === 'reply') {
                    return ann.data.x < 0 || ann.data.x > 1 || ann.data.y < 0 || ann.data.y > 1;
                }
                if (ann.data && ann.data.p1 && ann.data.p2) {
                    const {p1, p2} = ann.data;
                    return p1.x < 0 || p1.x > 1 || p1.y < 0 || p1.y > 1 ||
                           p2.x < 0 || p2.x > 1 || p2.y < 0 || p2.y > 1;
                }
                return false;
            }

            function centerAnnotation(ann) {
                if (ann.type === 'comment' || ann.type === 'reply') {
                    ann.data.x = 0.5;
                    ann.data.y = 0.5;
                } else if (ann.data && ann.data.p1 && ann.data.p2) {
                    const w = Math.abs(ann.data.p2.x - ann.data.p1.x);
                    const h = Math.abs(ann.data.p2.y - ann.data.p1.y);
                    ann.data.p1 = { x: 0.5 - w / 2, y: 0.5 - h / 2 };
                    ann.data.p2 = { x: 0.5 + w / 2, y: 0.5 + h / 2 };
                }
            }
            
            function pasteAnnotations() {
                if (state.clipboard.length === 0) return;
                const targetArtboardIds = state.selectedArtboardIds.length > 0 ? state.selectedArtboardIds : [state.artboards.length > 0 ? state.artboards[0].id : null].filter(Boolean);
                if (targetArtboardIds.length === 0) return;
                
                const allNewAnnotations = [];
                targetArtboardIds.forEach(targetId => {
                    const oldIdToNewIdMap = new Map();
                    const annotationsForThisBoard = [];
                    const targetArtboard = state.artboards.find(b => b.id === targetId);
                    
                    state.clipboard.forEach(clipboardAnn => {
                        const newAnn = JSON.parse(JSON.stringify(clipboardAnn));
                        const newId = crypto.randomUUID();
                        oldIdToNewIdMap.set(clipboardAnn.id, newId);
                        newAnn.id = newId;
                        newAnn.artboardId = targetId;
                        if (targetArtboard && targetArtboard.type !== 'video') {
                            delete newAnn.videoTime;
                            delete newAnn.frameBackup;
                        }
                        if (isAnnotationOutOfBounds(newAnn)) {
                            centerAnnotation(newAnn);
                        }
                        annotationsForThisBoard.push(newAnn);
                    });

                    annotationsForThisBoard.forEach(newAnn => {
                        if (newAnn.parentId && oldIdToNewIdMap.has(newAnn.parentId)) {
                            newAnn.parentId = oldIdToNewIdMap.get(newAnn.parentId);
                        } else {
                            newAnn.parentId = null;
                        }
                    });
                    allNewAnnotations.push(...annotationsForThisBoard);
                });

                if (allNewAnnotations.length === 0) return;
                
                historyManager.execute({
                    type: 'ADD_ANNOTATIONS',
                    annotations: allNewAnnotations,
                    do: (action) => {
                        state.annotations.push(...action.annotations);
                        state.selectedAnnotationIndices = action.annotations.map(ann => state.annotations.indexOf(ann));
                        updateAnnotationList();
                        redrawAllAnnotations();
                    },
                    undo: (action) => {
                        const idsToRemove = new Set(action.annotations.map(a => a.id));
                        state.annotations = state.annotations.filter(a => !idsToRemove.has(a.id));
                        state.selectedAnnotationIndices = [];
                        updateAnnotationList();
                        redrawAllAnnotations();
                    }
                });
            }
            
            function createHistoryManager() {
                const limit = 100; let undoStack = []; let redoStack = [];
                return {
                    execute(action) {
                        action.do(action);
                        undoStack.push(action);
                        if (undoStack.length > limit) { undoStack.shift(); }
                        redoStack = [];
                        markAsChanged();
                    },
                    undo() {
                        if (undoStack.length === 0) return;
                        const action = undoStack.pop();
                        action.undo(action);
                        redoStack.push(action);
                        markAsChanged();
                        updateAnnotationList();
                        renderWorkspace();
                    },
                    redo() {
                        if (redoStack.length === 0) return;
                        const action = redoStack.pop();
                        action.do(action);
                        undoStack.push(action);
                        markAsChanged();
                        updateAnnotationList();
                        renderWorkspace();
                    },
                };
            }
            
            function toggleRightPanel() { 
                state.layout.isPanelCollapsed = !state.layout.isPanelCollapsed; 
                applyRightPanelState(); 
                markAsChanged(); 
                drawAnnotationConnectorLines();
                updateAnnotationPopup();
            }
            function applyRightPanelState() { app.rightPanel.classList.toggle('collapsed', state.layout.isPanelCollapsed); }
            function changeArtboardBg(color, final = false) { 
                state.layout.artboardBgColor = color; 
                document.getElementById('artboard-bg-color-picker').value = color; 
                applyArtboardBackgroundColor(); 
                if (final) markAsChanged();
            }
            function applyArtboardBackgroundColor() { 
                document.querySelectorAll('.artboard-content:not(.transparent-guide)').forEach(el => {
                    el.style.backgroundColor = state.layout.artboardBgColor;
                });
            }
            function changeGuideColor(color, final = false) { 
                state.guides.color = color; 
                document.getElementById('guide-color-picker').value = color; 
                drawGuides(); 
                if (final) markAsChanged();
            }
            
            function findGuide(guideId) {
                let guide = state.guides.workspace.find(g => g.id === guideId);
                if (guide) return guide;
                for (const artboardId in state.guides.artboard) {
                    guide = state.guides.artboard[artboardId].find(g => g.id === guideId);
                    if (guide) return guide;
                }
                return null;
            }

            function getHitGuide(e) {
                if (state.guides.locked) return null;
                const mousePos = getWorkspaceMousePos(e);
                const tolerance = 5 / state.view.scale;

                for (const guide of state.guides.workspace) {
                    if (guide.type === 'horizontal' && Math.abs(mousePos.y - guide.position) < tolerance) return { scope: 'workspace', guide };
                    if (guide.type === 'vertical' && Math.abs(mousePos.x - guide.position) < tolerance) return { scope: 'workspace', guide };
                }

                for (const artboard of state.artboards) {
                    const artboardEl = document.querySelector(`.artboard[data-id="${artboard.id}"]`);
                    if (!artboardEl) continue;

                    const rect = artboardEl.getBoundingClientRect();
                    const isMouseOver = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;

                    if (isMouseOver) {
                        const artboardGuides = state.guides.artboard[artboard.id] || [];
                        const pos = getMousePosOnArtboard(e, artboard);
                        const toleranceY = 8 / (artboard.height * state.view.scale); 
                        const toleranceX = 8 / (artboard.width * state.view.scale);

                        for (const guide of artboardGuides) {
                            if (guide.type === 'horizontal' && Math.abs(pos.y - guide.position) < toleranceY) {
                                return { scope: 'artboard', guide, artboardId: artboard.id };
                            }
                            if (guide.type === 'vertical' && Math.abs(pos.x - guide.position) < toleranceX) {
                                return { scope: 'artboard', guide, artboardId: artboard.id };
                            }
                        }
                    }
                }
                return null;
            }
            
            function onGuideDrag(e) {
                if(state.guides.locked || state.interaction.mode !== 'draggingGuide') return;
                const { scope, guide, artboardId } = state.interaction.target;
                if (scope === 'workspace') {
                    const pos = getWorkspaceMousePos(e);
                    guide.position = guide.type === 'horizontal' ? pos.y : pos.x;
                } else if (scope === 'artboard') {
                    const artboard = state.artboards.find(b => b.id === artboardId);
                    if (artboard) {
                        const pos = getMousePosOnArtboard(e, artboard);
                        guide.position = guide.type === 'horizontal' ? pos.y : pos.x;
                    }
                }
                drawGuides();
            }

            function drawGuides() {
                const canvas = app.workspaceGuideCanvas;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0,0, canvas.width, canvas.height);
                drawWorkspaceGuides();
                state.artboards.forEach(artboard => drawArtboardGuides(artboard.id));
            }

            function drawWorkspaceGuides() {
                const canvas = app.workspaceGuideCanvas; const ctx = canvas.getContext('2d');
                const { width, height } = app.workspaceContainer.getBoundingClientRect(); 
                if(canvas.width !== width || canvas.height !== height) {
                    canvas.width = width; canvas.height = height;
                }
                
                if (!state.guides.visible) return;

                ctx.save();
                ctx.strokeStyle = state.guides.locked ? 'rgba(255, 100, 100, 0.7)' : state.guides.color + '80';
                ctx.lineWidth = 1;
                state.guides.workspace.forEach(guide => {
                    ctx.beginPath();
                    if (guide.type === 'horizontal') { const y = guide.position * state.view.scale + state.view.offsetY; ctx.moveTo(0, y); ctx.lineTo(width, y); } 
                    else { const x = guide.position * state.view.scale + state.view.offsetX; ctx.moveTo(x, 0); ctx.lineTo(x, height); }
                    ctx.stroke();
                });
                ctx.restore();
            }

            function drawArtboardGuides(artboardId) {
                const artboard = state.artboards.find(b => b.id === artboardId);
                const canvases = getArtboardCanvases(artboardId);
                if (!artboard || !canvases.guideCanvas) return;
                const canvas = canvases.guideCanvas; const ctx = canvas.getContext('2d');
                canvas.width = artboard.width; canvas.height = artboard.height; ctx.clearRect(0, 0, artboard.width, artboard.height); if (!state.guides.visible) return;
                ctx.strokeStyle = state.guides.locked ? 'rgba(255, 100, 100, 0.7)' : state.guides.color + '80';
                ctx.lineWidth = 1 / artboard.scale;
                const artboardGuides = state.guides.artboard[artboardId] || [];
                artboardGuides.forEach(guide => {
                    ctx.beginPath();
                    if (guide.type === 'horizontal') { const y = guide.position * artboard.height; ctx.moveTo(0, y); ctx.lineTo(artboard.width, y); } 
                    else { const x = guide.position * artboard.width; ctx.moveTo(x, 0); ctx.lineTo(x, artboard.height); }
                    ctx.stroke();
                });
            }
            
            function onToolbarDragStart(e) {
				e.preventDefault();
				const container = app.toolbarContainer;
				const rect = container.getBoundingClientRect();

				const offsetX = rect.width / 2;
				const offsetY = e.clientY - rect.top;
				const startX = e.clientX;
				const startY = e.clientY;
				let isDragging = false;

				function onMouseMove(ev) {
					const dx = ev.clientX - startX;
					const dy = ev.clientY - startY;
					if (!isDragging && Math.hypot(dx, dy) > 5) {
						isDragging = true;
					}

					if (isDragging) {
						state.toolbar.isDefault = false;
						state.toolbar.x = ev.clientX + offsetX - 4;
						state.toolbar.y = ev.clientY - offsetY;
						container.style.left = `${state.toolbar.x}px`;
						container.style.top = `${state.toolbar.y}px`;
						container.style.bottom = '';
						container.style.transform = '';
					}
				}

				function onMouseUp(ev) {
					window.removeEventListener('mousemove', onMouseMove);
					window.removeEventListener('mouseup', onMouseUp);

					if (!isDragging) {
						const now = Date.now();
						if (now - dragHandleClicks.time < 300) {
							dragHandleClicks.count++;
						} else {
							dragHandleClicks.count = 1;
						}
						dragHandleClicks.time = now;

						if (dragHandleClicks.count === 2) {
							state.toolbar.isSimple = !state.toolbar.isSimple;
							applyToolbarState();
							markAsChanged();
						} else if (dragHandleClicks.count >= 3) {
							state.toolbar.isDefault = true;
							applyToolbarState();
							markAsChanged();
							dragHandleClicks.count = 0;
						}
					} else {
						markAsChanged();
					}
				}

				window.addEventListener('mousemove', onMouseMove);
				window.addEventListener('mouseup', onMouseUp);
			}

            function onToolbarDrag(e) {
                const startData = state.interaction.startData.get('toolbar');
                if (!startData) return;

                const { offsetX, offsetY } = startData;
                const container = app.toolbarContainer;
                const parentRect = app.mainContent.getBoundingClientRect();

                const newX = e.clientX - parentRect.left - offsetX;
                const newY = e.clientY - parentRect.top - offsetY;

                if (state.toolbar.isDefault) {
                    container.style.transform = '';
                    container.style.bottom = '';
                }
                
                container.style.left = `${newX}px`;
                container.style.top = `${newY}px`;
                
                state.toolbar.x = newX;
                state.toolbar.y = newY;
                state.toolbar.isDefault = false;
                markAsChanged();
            }

            function applyToolbarState() {
                const {x, y, isSimple, isDefault} = state.toolbar;
                const container = app.toolbarContainer;
                if (isDefault) {
                    container.style.left = '50%'; container.style.top = ''; container.style.bottom = '50px'; container.style.transform = 'translateX(-50%)';
                } else {
                    container.style.left = `${x}px`; container.style.top = `${y}px`; container.style.bottom = ''; container.style.transform = '';
                }
                app.movableControls.classList.toggle('simple-mode', isSimple);
            }

            function showContextMenu(e, items) {
                e.preventDefault(); e.stopPropagation();
                app.contextMenu.innerHTML = ''; app.contextMenu.classList.remove('hidden');
                items.forEach(item => {
                    if (item.divider) { const div = document.createElement('div'); div.className = 'context-menu-divider'; app.contextMenu.appendChild(div); return; }
                    const menuItem = document.createElement('div'); menuItem.className = 'context-menu-item';
                    if (item.disabled) { menuItem.classList.add('disabled'); }
                    menuItem.textContent = item.label;
                    if (!item.disabled) { menuItem.onclick = () => { hideContextMenu(); item.action(); }; }
                    app.contextMenu.appendChild(menuItem);
                });
                const menuRect = app.contextMenu.getBoundingClientRect(); let x = e.clientX; let y = e.clientY;
                if (x + menuRect.width > window.innerWidth) { x = window.innerWidth - menuRect.width; }
                if (y + menuRect.height > window.innerHeight) { y = window.innerHeight - menuRect.height; }
                app.contextMenu.style.left = `${x}px`; app.contextMenu.style.top = `${y}px`;
            }

            function hideContextMenu() { app.contextMenu.classList.add('hidden'); }
            
            function onWorkspaceContextMenu(e) {
                if (state.interaction.didDrag) {
                    e.preventDefault();
                    return;
                }
                
                if (!e.target.closest('#workspace-container') || e.target.closest('.artboard')) return;

                const items = [
                    { label: 'Add Image/Video...', action: () => app.fileInput.click() }, { divider: true },
                    { label: 'Add Horizontal Guide', action: () => { const pos = getWorkspaceMousePos(e); state.guides.workspace.push({ type: 'horizontal', position: pos.y, id: crypto.randomUUID() }); drawGuides(); markAsChanged(); } },
                    { label: 'Add Vertical Guide', action: () => { const pos = getWorkspaceMousePos(e); state.guides.workspace.push({ type: 'vertical', position: pos.x, id: crypto.randomUUID() }); drawGuides(); markAsChanged(); } }, { divider: true },
                    { label: state.guides.visible ? 'Hide All Guides' : 'Show All Guides', action: () => { state.guides.visible = !state.guides.visible; drawGuides(); } },
                    { label: state.guides.locked ? 'Unlock Guides' : 'Lock Guides', action: () => { state.guides.locked = !state.guides.locked; drawGuides(); } },
                    { label: 'Clean All Guides', action: () => { state.guides.workspace = []; Object.keys(state.guides.artboard).forEach(id => state.guides.artboard[id] = []); drawGuides(); markAsChanged(); } }, { divider: true },
                    { label: 'Fit All Videos to 720p', action: resizeAllVideosTo720p },
                    { label: 'Fit All Artboards to View', action: fitAllArtboardsToView },
                    { label: 'Arrange Artboards', action: rearrangeArtboards }, { divider: true },
                    { label: 'Undo', action: () => historyManager.undo() }, { label: 'Redo', action: () => historyManager.redo() },
                ];
                showContextMenu(e, items);
            }
            
            function onArtboardContextMenu(e, artboardId) {
                if (state.interaction.didDrag) {
                    e.preventDefault();
                    return;
                }
                
                e.preventDefault(); e.stopPropagation();
                if (!state.selectedArtboardIds.includes(artboardId)) { selectArtboard(artboardId, false); }
                const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return;
                const pos = getMousePosOnArtboard(e, artboard);
                let items = [{ label: 'Add Comment', action: () => { addAnnotation({ type: 'comment', artboardId, data: pos, color: state.activeColor, text: '' }, true); } }];
                if (artboard.type === 'video') { items.push({ label: 'Save Frame', action: () => saveVideoFrame(artboardId) }); }
                items.push(
					{ divider: true },
                    { label: 'Add Horizontal Guide', action: () => { if(!state.guides.artboard[artboardId]) state.guides.artboard[artboardId] = []; state.guides.artboard[artboardId].push({type: 'horizontal', position: pos.y, id: crypto.randomUUID()}); drawGuides(); markAsChanged(); } },
                    { label: 'Add Vertical Guide', action: () => { if(!state.guides.artboard[artboardId]) state.guides.artboard[artboardId] = []; state.guides.artboard[artboardId].push({type: 'vertical', position: pos.x, id: crypto.randomUUID()}); drawGuides(); markAsChanged(); } },
                    { label: 'Clean Artboard Guides', action: () => { state.guides.artboard[artboardId] = []; drawGuides(); markAsChanged(); } },
                    { divider: true }, { label: 'Copy File Name', action: () => navigator.clipboard.writeText(artboard.name) }
                );
                if (artboard.type === 'video') { items.push({ label: 'Fit Video to 720p', action: () => { resizeAllVideosTo720p(); } }); items.push({ label: 'Zoom to 100%', action: () => { resetArtboardScale(artboardId); }}); }
                if (artboard.type === 'image' && artboard.name.match(/\.(png|webp|gif)$/i)) { items.push({ label: 'Change Background Color', action: () => { document.getElementById('artboard-bg-color-picker').click(); }}); }
                items.push({ divider: true }); items.push({ label: 'Close Artboard', action: deleteSelectedArtboards });
                showContextMenu(e, items);
            }

            function onAnnotationCanvasContextMenu(e, artboardId) {
                const artboard = state.artboards.find(b => b.id === artboardId); if (!artboard) return;
                const pos = getMousePosOnArtboard(e, artboard); const hit = getHitAnnotation(pos, artboardId, true);
                if (hit.index !== -1) {
                    e.preventDefault(); e.stopPropagation();
                    const ann = state.annotations[hit.index];
                    const items = [
                        { label: 'Copy Text', disabled: !ann.text, action: () => navigator.clipboard.writeText(ann.text) },
                        { label: 'Reply', action: () => addAnnotation({ type: 'reply', artboardId: ann.artboardId, text: '', parentId: ann.id }, true) },
                        { label: ann.completed ? 'Mark as Not Done' : 'Mark as Done', action: () => { ann.completed = !ann.completed; updateAnnotationList(); redrawAllAnnotations(); markAsChanged(); } },
                        { divider: true }, { label: 'Delete', action: () => deleteAnnotationsByIndices([hit.index]) },
                    ];
                    showContextMenu(e, items);
                } else { onArtboardContextMenu(e, artboardId); }
            }

            function onAnnotationListContextMenu(e) {
                const li = e.target.closest('li[data-index]');
                if (li) {
                    e.preventDefault(); e.stopPropagation();
                    const index = parseInt(li.dataset.index, 10); const ann = state.annotations[index]; if (!ann) return;
                    const items = [
                        { label: 'Copy Text', disabled: !ann.text, action: () => navigator.clipboard.writeText(ann.text) },
                        { label: 'Reply', action: () => addAnnotation({ type: 'reply', artboardId: ann.artboardId, text: '', parentId: ann.id }, true) },
                        { label: ann.completed ? 'Mark as Not Done' : 'Mark as Done', action: () => { ann.completed = !ann.completed; li.classList.toggle('completed', ann.completed); li.querySelector('.complete-checkbox').checked = ann.completed; redrawAllAnnotations(); markAsChanged(); } },
                        { divider: true }, { label: 'Delete', action: () => deleteAnnotationsByIndices([index]) },
                    ];
                    showContextMenu(e, items);
                } else if (e.target.closest('#annotation-list')) {
                     e.preventDefault(); e.stopPropagation();
                     const isMasked = app.annotationList.classList.contains('mask-completed');
                     const items = [
                        { label: isMasked ? 'Show All Done Comments' : 'Hide All Done Comments', action: () => app.annotationList.classList.toggle('mask-completed') },
                        { divider: true },
                        { label: 'Remove All Comments...', action: () => {
                            if (confirm(`Are you sure you want to remove all ${state.annotations.length} comments? This cannot be undone.`)) {
                                const allIndices = state.annotations.map((_, i) => i);
                                deleteAnnotationsByIndices(allIndices);
                            }
                        }},
                     ];
                     showContextMenu(e, items);
                }
            }

            function onSearchInputContextMenu(e) {
                const input = e.target;
                const items = [
                    { label: 'Copy', disabled: input.selectionStart === input.selectionEnd, action: () => navigator.clipboard.writeText(input.value.substring(input.selectionStart, input.selectionEnd)) },
                    { label: 'Paste', action: async () => {
                        const text = await navigator.clipboard.readText();
                        const start = input.selectionStart;
                        const end = input.selectionEnd;
                        input.value = input.value.substring(0, start) + text + input.value.substring(end);
                        input.selectionStart = input.selectionEnd = start + text.length;
                        input.dispatchEvent(new Event('input'));
                    }},
                    { label: 'Clear', disabled: input.value === '', action: () => {
                        input.value = '';
                        input.dispatchEvent(new Event('input'));
                    }},
                ];
                showContextMenu(e, items);
            }
             
            function onSaveButtonContextMenu(e) {
                const items = [
                    { label: 'Save HTML File', action: saveState },
                    { label: 'Save As New File...', action: saveStateAs },
                    { divider: true },
                    { label: 'Package Project (.zip)', action: packageProjectAsZip }
                ];
                showContextMenu(e, items);
            }
            
            async function gifToVideo(file) {
                const artboardId = crypto.randomUUID();
                const fileUrl = URL.createObjectURL(file); 
                try {
                    addArtboard(file.name, null, 'video', { width: 300, height: 225 }, { isLoading: true, id: artboardId });
                    
                    const canvas = document.createElement('canvas');
                    let mediaRecorder;
                    let chunks = [];
                    let firstFrame = true;

                    const animation = gifler(fileUrl);
                    
                    const onDone = () => {
                        if (mediaRecorder && mediaRecorder.state === "recording") {
                            mediaRecorder.stop();
                        }
                    };

                    animation.frames(canvas, (ctx, frame) => {
                        if (firstFrame) {
                            canvas.width = frame.width;
                            canvas.height = frame.height;
                            
                            let artboard = state.artboards.find(b => b.id === artboardId);
                            if (artboard) {
                                artboard.width = frame.width;
                                artboard.height = frame.height;
                                artboard.originalWidth = frame.width;
                                artboard.originalHeight = frame.height;
                            }
                            rearrangeArtboards(); 

                            const stream = canvas.captureStream(FRAME_RATE);
                            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
                            
                            mediaRecorder.ondataavailable = e => { 
                                if (e.data.size > 0) chunks.push(e.data); 
                            };
                            
                            mediaRecorder.onstop = () => {
                                const blob = new Blob(chunks, { type: 'video/webm' });
                                const reader = new FileReader();
                                reader.onload = () => {
                                    const dataUrl = reader.result;
                                    let artboard = state.artboards.find(b => b.id === artboardId);
                                    if (artboard) {
                                        artboard.isLoading = false;
                                        artboard.src = dataUrl;
                                        renderWorkspace();
                                        global_updateTimeline();
                                    }
                                }
                                reader.readAsDataURL(blob);
                            };
                            mediaRecorder.start();
                            firstFrame = false;
                        }
                        ctx.drawImage(frame.buffer, frame.x, frame.y, frame.width, frame.height);
                    });
                    
                    if(animation.animator) {
                        const originalOnEnd = animation.animator.onend;
                        animation.animator.onend = () => {
                            if (originalOnEnd) originalOnEnd();
                            onDone();
                        };
                    } else {
                        setTimeout(onDone, 5000);
                    }
                } catch (err) {
                    console.error("Failed to convert GIF:", err);
                    alert("Error converting GIF file.");
                    state.artboards = state.artboards.filter(b => b.id !== artboardId);
                    renderWorkspace();
                } finally {
                    URL.revokeObjectURL(fileUrl);
                }
            }
            
            function dataURLtoBlob(dataurl) {
                let arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
                    bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
                while(n--){
                    u8arr[n] = bstr.charCodeAt(n);
                }
                return new Blob([u8arr], {type:mime});
            }

            async function packageProjectAsZip() {
                if (!window.JSZip) {
                    alert("Packaging library could not be loaded. Please check your internet connection.");
                    return;
                }

                const originalSaveText = app.saveBtn.textContent;
                app.saveBtn.textContent = "Packaging...";
                app.saveBtn.classList.add('saving');

                try {
                    const zip = new JSZip();
                    const htmlContent = await generateAnnotatedHTML();
                    zip.file("Media_QC.html", htmlContent);

                    const mediaFolder = zip.folder("media");
                    const fetchPromises = [];

                    for (const artboard of state.artboards) {
                        if (!artboard.src) continue;

                        const isBlobUrl = artboard.src.startsWith('blob:');
                        const isDataUrl = artboard.src.startsWith('data:');

                        if (isBlobUrl) {
                            const promise = fetch(artboard.src)
                                .then(res => res.blob())
                                .then(blob => {
                                    mediaFolder.file(artboard.name, blob);
                                })
                                .catch(err => console.error(`Failed to fetch blob for ${artboard.name}:`, err));
                            fetchPromises.push(promise);
                        } else if (isDataUrl) {
                            try {
                                const blob = dataURLtoBlob(artboard.src);
                                mediaFolder.file(artboard.name, blob);
                            } catch (err) {
                                console.error(`Failed to convert data URL for ${artboard.name}:`, err);
                            }
                        }
                    }

                    await Promise.all(fetchPromises);

                    const zipBlob = await zip.generateAsync({ type: "blob" });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(zipBlob);
                    a.download = "Media_QC_Project.zip";
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(a.href);

                } catch (err) {
                    console.error("Failed to create zip package:", err);
                    alert("An error occurred while creating the package.");
                } finally {
                    app.saveBtn.textContent = originalSaveText;
                    app.saveBtn.classList.remove('saving');
                }
            }
            
            init();
        });
    </script>
</body>
</html>



















