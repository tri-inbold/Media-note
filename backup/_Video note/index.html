<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAABzUlEQVR4AeyYsStFURzHhZ3EYKWERcmiZJJVSgbJyB8gLFaLTDYmpVjFQmS1KGUzMIuBjUR8vjfn8o57uTfnnndfndf3+86953fO7/fp90697q2vq5FPzYO20OgxPFsFq67qU/pLSR2dJnyD9/BGFay619SdwrFs0EEiW7gJV1PNFN/GQziSDbrMbAMug8S2ZEB0Y641dumrRO42LDZoowl8G++51pkt2qpDqQrFPDZoxarPm0XGTg9WHcokKwto8k7PswHUdcNDR0NHXXfAdb5wRkNHXXfAdb5wRkNHXXfAdb6sZ9R13dz5AmhKy/S8vkbsCB9bXuDe1ruZ8NlRPd0KcJ7io3jEci/3tu7MhE/QHooO4Dw6NYt9graaohnHB9at40g+QaOCGb+eWTeJb3GkMoK+QCbIE8ZYZQMV5AR0B7hCZQJNhRRxFtBVFuo14H+9Q5406UzqveiPTpoNNuirCXwb27jucOB2ciRJkOMEDnGqbNCr1JXFBDJBqrQNusLkG/ahJ4r82UnWRLJBz5idwY+4SF2QfBj/+nMTj2WDKqBDrzOpwz3HhEvrvXwfOfvxOc6sJFBt1t/XPhebjr1LvkucW2mguRMVveEDAAD//4xT+jkAAAAGSURBVAMA+9qQVQ1bZU8AAAAASUVORK5CYII=" type="image/png">
    <title>Video note</title>
    <!-- ADDED: Meta tag to store the relative path to the video file -->
    <meta name="video-filename" content="">
    
    <style>
        /* All CSS content is now here */
        :root { 
            --bg-color: #000; 
            --panel-bg: rgba(40, 40, 40, 0.6); 
            --border-color: rgba(255, 255, 255, 0.2); 
            --text-color: #f0f0f0; 
            --text-color-light: #999;
            --highlight-color: #00aaff;
            --input-bg: rgba(0,0,0,0.3);
            --list-item-bg: rgba(0,0,0,0.2);
            --list-item-reply-bg: rgba(0,0,0,0.3);
            --checkbox-border: #555;
            --icon-btn-color: #999;
            --icon-btn-hover-color: #fff;
            --right-panel-bg: var(--panel-bg);
            --video-slot-bg: #000;
        }

        body.theme-light {
            --bg-color: #ffffff;
            --panel-bg: #ffffff;
            --right-panel-bg: #f8f9fa;
            --border-color: #dee2e6;
            --text-color: #212529;
            --text-color-light: #6c757d;
            --input-bg: #ffffff;
            --list-item-bg: #ffffff;
            --list-item-reply-bg: #f1f3f5;
            --checkbox-border: #adb5bd;
            --icon-btn-color: #6c757d;
            --icon-btn-hover-color: #212529;
            --video-slot-bg: #ffffff;
        }

        body, html { margin: 0; padding: 0; font-family: Arial, sans-serif; background: var(--bg-color); color: var(--text-color); overflow: hidden; height: 100vh; width: 100vw; }
        .hidden { display: none !important; }
        
        .glass-panel { background: var(--panel-bg); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border: 1px solid var(--border-color); box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2); transition: transform 0.4s ease, opacity 0.4s ease; }
        body.theme-light .glass-panel { backdrop-filter: none; -webkit-backdrop-filter: none; box-shadow: 0 2px 10px rgba(0,0,0,0.07); }

        #app-container { display: flex; height: 100%; width: 100%; }
        #main-content { flex-grow: 1; position: relative; height: 100%; }

        #video-grid { display: grid; grid-template-columns: 1fr; width: 100%; height: 100%; }
        body.ref-video-loaded #video-grid { grid-template-columns: 1fr 1fr; }
        body.ref-video-loaded #video-slot-ref { border-right: 1px solid var(--border-color); }

        .video-slot { position: relative; background-color: var(--video-slot-bg); overflow: hidden; display: flex; justify-content: center; align-items: center; box-sizing: border-box; transition: background-color 0.3s; }
        .video-slot video { max-width: 100%; max-height: 100%; }
        body.theme-light .video-slot video { box-shadow: 0 4px 12px rgba(0,0,0,0.1); border-radius: 4px; }

        .video-filename { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; font-size: 0.8em; z-index: 11; color: #fff; }
        #canvas-main { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; cursor: default; pointer-events: none; }
        #canvas-interaction { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 15; cursor: default; }

        #drop-zone { position: absolute; inset: 20px; border: 2px dashed rgba(173, 181, 189, 0.5); border-radius: 20px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 1em; color: var(--text-color-light); z-index: 100; transition: all 0.3s; }
        #drop-zone p { background: var(--panel-bg); padding: 25px 35px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); border: 1px solid var(--border-color); line-height: 1.5; }
        body.theme-dark #drop-zone p { box-shadow: none; }
        body.ref-video-loaded #drop-zone { width: 50%; right: 10px; left: auto; }
        #drop-zone.hidden { pointer-events: none; opacity: 0; }
        body.dragging #drop-zone { border-color: var(--highlight-color); background-color: rgba(0, 170, 255, 0.1); }

        #bottom-controls-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 20; }
        #bottom-controls { display: flex; gap: 10px; align-items: flex-end; }

        #ref-video-panel, #tools-panel, #timeline-panel, #help-panel { padding: 8px; border-radius: 12px; display: flex; align-items: center; }
        #tools-panel { padding: 8px 10px; gap: 4px; }
        #timeline-panel { position: relative; gap: 10px; flex-grow: 1; width: 650px; }
        #help-panel { padding: 0; background: none; border: none; }

        .playback-controls { display: flex; align-items: center; gap: 4px; }

        .tool-btn { width: 28px; height: 28px; border-radius: 8px; border: none; background: transparent; color: var(--text-color-light); cursor: pointer; display: flex; justify-content: center; align-items: center; transition: all 0.2s; padding: 0; }
        .tool-btn:hover { color: var(--text-color); background-color: rgba(255,255,255,0.1); }
        body.theme-light .tool-btn:hover { background-color: rgba(0,0,0,0.05); }
        .tool-btn.active { color: #fff; background-color: var(--highlight-color); transform: scale(1.1); }
        body.theme-light .tool-btn.active { color: #fff; }
        .tool-btn svg { width: 18px; height: 18px; fill: currentColor; }
        #load-ref-video-btn svg { width: 20px; height: 20px; }

        .divider { width: 1px; height: 20px; background: var(--border-color); margin: 0 5px; }
        #color-picker { position: relative; }
        #active-color-btn { width: 20px; height: 20px; border-radius: 50%; cursor: pointer; border: 2px solid var(--text-color); }
        #color-palette-popup { position: absolute; bottom: 170%; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; padding: 8px; border-radius: 10px; background: var(--bg-color); border: 1px solid var(--border-color); }
        .color-btn { width: 20px; height: 20px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: all 0.2s; }
        .color-btn:hover { transform: scale(1.2); }
        #play-pause-btn, #mute-btn, #snapshot-btn { background: none; border: none; color: var(--text-color); cursor: pointer; padding: 5px; display: flex; align-items: center; }
        #play-pause-btn svg, #mute-btn svg, #snapshot-btn svg { width: 20px; height: 20px; fill: currentColor; }
        #help-btn { background: var(--panel-bg); border: 1px solid var(--border-color); color: var(--text-color); cursor: pointer; display: flex; align-items: center; justify-content: center; height: 38px; padding: 0 12px; border-radius: 8px; font-weight: bold; font-size: 1.2em; }
        
        #time-display { cursor: pointer; padding: 2px 5px; font-variant-numeric: tabular-nums; }
        #time-display input { width: 50px; background: var(--input-bg); border: 1px solid var(--highlight-color); color: var(--text-color); font-family: inherit; text-align: center; }
        
        #timeline-wrapper { position: relative; flex-grow: 1; display: flex; align-items: center; }
        #timeline-bg, #timeline-diff { position: absolute; left: 0; top: 50%; transform: translateY(-50%); height: 5px; border-radius: 5px; pointer-events: none; }
        #timeline-bg { width: 100%; background: rgba(255, 255, 255, 0.3); }
        body.theme-light #timeline-bg { background: rgba(0,0,0,0.1); }
        #timeline-diff { background: rgba(255, 82, 82, 0.7); width: 0; }
        #timeline-slider { position: relative; z-index: 1; flex-grow: 1; -webkit-appearance: none; appearance: none; width: 100%; height: 5px; background: transparent !important; border-radius: 5px; outline: none; }
        #timeline-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 15px; height: 15px; background: var(--text-color); cursor: pointer; border-radius: 50%; }
        
        #speed-controls { display: flex; background: rgba(0,0,0,0.2); border-radius: 8px; }
        body.theme-light #speed-controls { background: rgba(0,0,0,0.05); }
        .speed-btn { background: none; border: none; color: var(--text-color-light); padding: 6px 12px; cursor: pointer; }
        .speed-btn.active { color: #fff; background: var(--highlight-color); border-radius: 8px; }
        body.theme-light .speed-btn.active { color: #fff; }

        #right-panel { flex: 0 0 340px; margin: 10px; margin-left: 0; display: flex; flex-direction: column; z-index: 20; border-radius: 15px; overflow: hidden; background: var(--right-panel-bg); border: 1px solid var(--border-color); flex-shrink: 0; /* ADDED: Prevent panel from shrinking */ }
        body.theme-light #right-panel { box-shadow: 0 2px 10px rgba(0,0,0,0.07); }
        #list-header { padding: 10px; border-bottom: 1px solid var(--border-color); }
        #search-input { width: 100%; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-color); padding: 8px; box-sizing: border-box; }
        #list-container { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        #annotation-list { list-style: none; padding: 10px; margin: 0; overflow-y: auto; flex-grow: 1; }
        #save-btn { display: block; width: calc(100% - 20px); margin: 10px; padding: 12px; border: none; border-radius: 10px; background-color: var(--highlight-color); color: #fff; font-size: 1em; font-weight: bold; cursor: pointer; flex-shrink: 0; transition: background-color 0.3s ease, color 0.3s ease; }
        #save-btn.unsaved { background-color: #ffc107; color: #000; }
        #annotation-list li { padding: 10px 12px; border-radius: 8px; margin-bottom: 8px; position: relative; background-color: var(--list-item-bg); transition: all 0.2s; cursor: pointer; border: 1px solid var(--border-color); }
        #annotation-list li.selected { background-color: rgba(0, 170, 255, 0.15); box-shadow: 0 0 0 2px var(--highlight-color) inset; border-color: var(--highlight-color);}
        #annotation-list li.completed { opacity: 0.6; }
        #annotation-list li.completed .content, #annotation-list li.completed .annotation-image { text-decoration: line-through; }
        #annotation-list li .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        #annotation-list li .time { font-size: 0.7em; color: var(--text-color-light); }
        #annotation-list li .content { margin: 0; font-size: 0.9em; white-space: pre-wrap; min-height: 1em; word-break: break-word; }
        #annotation-list li .annotation-image { max-width: 100%; border-radius: 4px; margin-top: 5px; display: block; }
        
        #annotation-list li.reply-item {
            margin-left: 20px;
            padding: 8px 10px;
            transform: scale(0.98);
            background-color: var(--list-item-reply-bg);
        }

        .header-tools { display: flex; align-items: center; gap: 2px; } 
        .icon-btn { background: transparent; border: none; color: var(--icon-btn-color); cursor: pointer; opacity: 0.7; transition: all 0.2s; display: flex; justify-content: center; align-items: center; width: 20px; height: 20px; padding: 0; }
        .icon-btn:hover { opacity: 1; color: var(--icon-btn-hover-color); }
        .icon-btn svg { width: 12px; height: 12px; fill: currentColor; }

        .complete-checkbox { transform: scale(0.75); }
        #annotation-list li textarea { width: calc(100% - 6px); background: transparent; border: 1px solid var(--highlight-color); border-radius: 4px; color: var(--text-color); font-family: inherit; font-size: 1em; resize: none; overflow-y: hidden; box-sizing: border-box; }
        .complete-checkbox { appearance: none; width: 16px; height: 16px; border: 2px solid var(--checkbox-border); border-radius: 50%; cursor: pointer; transition: all 0.2s; }
        .complete-checkbox:checked { background-color: #28a745; border-color: #28a745; }
        .complete-checkbox:checked::after { content: '\2713'; display: block; text-align: center; color: #fff; font-weight: bold; font-size: 11px; line-height: 13px; }
        
        #help-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 200; display: flex; justify-content: center; align-items: center; }
        body.theme-light #help-modal { background: rgba(0,0,0,0.4); }
        #help-modal .modal-content { position: relative; padding: 20px 30px; width: 500px; border-radius: 15px; }
        #help-modal ul { list-style: none; padding-left: 0; }
        #help-modal li { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        #help-modal strong { color: var(--highlight-color); }
        #modal-close-btn { position: absolute; top: 10px; right: 15px; background: none; border: none; color: var(--text-color); font-size: 28px; cursor: pointer; }
        #help-modal hr { border-color: var(--border-color); }
        #change-user-btn, #theme-selector { background: var(--input-bg); border: 1px solid var(--border-color); color: var(--text-color); border-radius: 5px; padding: 2px 6px; margin-left: 10px; cursor: pointer; }
        #theme-selector {-webkit-appearance: none; appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23f0f0f0'%3E%3Cpath d='M6 9L.5 3h11z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 6px center; padding-right: 20px;}
        body.theme-light #theme-selector { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%231a1a1a'%3E%3Cpath d='M6 9L.5 3h11z'/%3E%3C/svg%3E");}
        #theme-selector option { background: var(--panel-bg); color: var(--text-color); }

        #volume-popup { position: absolute; bottom: 120%; left: 45px; padding: 4px; display: flex; gap: 2px; }
        .volume-btn { background: none; border: 1px solid transparent; color: var(--text-color-light); padding: 4px 8px; cursor: pointer; border-radius: 5px; font-size: 0.8em; }
        .volume-btn:hover { background: rgba(255,255,255,0.1); color: var(--text-color); }
        body.theme-light .volume-btn:hover { background-color: rgba(0,0,0,0.05); }
        .volume-btn.active { background: var(--highlight-color); color: #fff; }

        /* ADDED: Styles for the panel resizer */
        #panel-resizer {
            width: 5px;
            cursor: col-resize;
            flex-shrink: 0; /* Prevent it from shrinking */
            background-color: transparent;
            transition: background-color 0.2s ease;
            align-self: stretch; /* Make it full height */
            margin: 10px 0; /* Match right-panel margin */
        }
        #panel-resizer:hover {
            background-color: var(--highlight-color);
        }
    </style>
</head>
<body class="theme-dark">
    <input type="file" id="file-input" accept="video/mp4, .txt, image/*" style="display: none;">
    <input type="file" id="image-input" accept="image/*" style="display: none;">

    <div id="app-container">
        <div id="main-content">
            <div id="video-grid">
                <div class="video-slot hidden" id="video-slot-ref">
                    <video id="video-ref" playsinline></video>
                    <div id="ref-video-filename" class="video-filename hidden"></div>
                </div>
                <div class="video-slot" id="video-slot-main">
                    <video id="video-main" playsinline></video>
                    <div id="main-video-filename" class="video-filename hidden"></div>
                    <canvas id="canvas-main"></canvas>
                    <canvas id="canvas-interaction"></canvas>
                </div>
            </div>
            
            <div id="drop-zone">
                <p id="drop-zone-text">Bấm đúp hoặc Ctrl+D để mở file<br>Hoặc kéo thả video, ảnh vào đây</p>
            </div>

            <div id="bottom-controls-container">
                <div id="bottom-controls">
                    <div id="ref-video-panel" class="glass-panel">
                        <button id="load-ref-video-btn" class="tool-btn" title="Tải/Đóng video tham chiếu">
                            <svg id="ref-video-add-icon" viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                            <svg id="ref-video-remove-icon" class="hidden" viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
                        </button>
                    </div>
        
                    <div id="tools-panel" class="glass-panel">
                        <button class="tool-btn" data-tool="comment" title="Comment (Q)"><svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 14v-2h12v2H6zm0-3v-2h12v2H6zm0-3v-2h12v2H6z"/></svg></button>
                        <button class="tool-btn" data-tool="rect" title="Square (W)"><svg viewBox="0 0 24 24"><path d="M3 3v18h18V3H3zm16 16H5V5h14v14z"/></svg></button>
                        <button class="tool-btn" data-tool="circle" title="Circle (E)"><svg viewBox="0 0 24 24"><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg></button>
                        <button class="tool-btn" data-tool="line" title="Line (R)"><svg viewBox="0 0 24 24"><path d="M21 11H3v2h18v-2z"/></svg></button>
                        <button class="tool-btn" data-tool="arrow" title="Arrow (T)"><svg viewBox="0 0 24 24"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8-8-8z"/></svg></button>
                        <div class="divider"></div>
                        <div id="color-picker">
                            <button id="active-color-btn" class="color-btn"></button>
                            <div id="color-palette-popup" class="hidden">
                                <button class="color-btn" data-color="#FFFFFF" style="background-color: #FFFFFF;"></button>
                                <button class="color-btn" data-color="#2D2D2D" style="background-color: #2D2D2D;"></button>
                                <button class="color-btn" data-color="#E53935" style="background-color: #E53935;"></button>
                                <button class="color-btn" data-color="#1E88E5" style="background-color: #1E88E5;"></button>
                                <button class="color-btn" data-color="#43A047" style="background-color: #43A047;"></button>
                                <button class="color-btn" data-color="#FDD835" style="background-color: #FDD835;"></button>
                                <button class="color-btn" data-color="#BDBDBD" style="background-color: #BDBDBD;"></button>
                            </div>
                        </div>
                    </div>
        
                    <div id="timeline-panel" class="glass-panel">
                        <div class="playback-controls">
                            <button id="play-pause-btn" title="Play/Pause (Spacebar)"><svg id="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg><svg id="pause-icon" class="hidden" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg></button>
                            <button id="mute-btn" title="Mute/Unmute (Nhấn giữ để chỉnh âm lượng)"><svg id="unmute-icon" class="hidden" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg><svg id="mute-icon" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L7 9H3v6h4l5 5v-8.27l-5.73-5.73z"/></svg></button>
                        </div>
                        <div id="volume-popup" class="glass-panel hidden">
                            <button class="volume-btn" data-volume="0">0%</button>
                            <button class="volume-btn" data-volume="0.25">25%</button>
                            <button class="volume-btn" data-volume="0.5">50%</button>
                            <button class="volume-btn" data-volume="0.75">75%</button>
                            <button class="volume-btn" data-volume="1">100%</button>
                        </div>
                        <span id="time-display" title="Click to edit time">00:00</span>
                        <div id="timeline-wrapper">
                            <div id="timeline-bg"></div>
                            <div id="timeline-diff"></div>
                            <input type="range" id="timeline-slider" value="0" step="0.01">
                        </div>
                        <div id="speed-controls"><button class="speed-btn" data-speed="1">1x</button><button class="speed-btn" data-speed="2">2x</button><button class="speed-btn" data-speed="3">3x</button></div>
                        <button id="snapshot-btn" title="Save Frame as PNG"><svg viewBox="0 0 24 24"><path d="M9.4 15.5h5.2l-1.6-2.1-1.3 1.7-1-1.3zm-3.9 2.5h13V6H5.5zM4 4h16c.6 0 1 .4 1 1v14c0 .6-.4 1-1 1H4c-.6 0-1-.4-1-1V5c0-.6.4-1 1-1z"/></svg></button>
                    </div>
        
                    <div id="help-panel" class="glass-panel">
                        <button id="help-btn" title="Help & Shortcuts">?</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ADDED: Resizer element -->
        <div id="panel-resizer"></div>

        <div id="right-panel" class="glass-panel">
            <div id="list-header">
                <input type="search" id="search-input" placeholder="Tìm kiếm...">
            </div>
            <div id="list-container"><ul id="annotation-list"></ul><button id="save-btn">Lưu file HTML</button></div>
        </div>
    </div>

    <div id="help-modal" class="hidden">
        <div class="modal-content glass-panel">
            <button id="modal-close-btn">&times;</button>
            <h3>Phím tắt & Trợ giúp</h3>
            <ul>
                <li><strong>Ctrl + D / Dbl-Click Zone</strong><span>Mở file chính</span></li>
                <li><strong>Ctrl + S</strong><span>Lưu file HTML</span></li>
                <li><strong>Ctrl + Shift + S</strong><span>Lưu thành file HTML mới</span></li>
                <li><strong>Ctrl + C</strong><span>Copy text / hình / annotation</span></li>
                <li><strong>Ctrl + V</strong><span>Dán text / hình / annotation</span></li>
                <li><strong>Ctrl + Z / Ctrl + Shift + Z</strong><span>Undo / Redo Xóa</span></li>
                <li><strong>Spacebar</strong><span>Play / Pause</span></li>
                <li><strong>Delete</strong><span>Xóa annotation(s) đã chọn</span></li>
                <li><strong>← / → | Lăn chuột</strong><span>Từng frame</span></li>
                <li><strong>Shift + ← / →</strong><span>Từng giây</span></li>
                <li><strong>↑ / ↓</strong><span>Về đầu / cuối video</span></li>
                <li><strong>Q, W, E, R, T</strong><span>Chọn công cụ</span></li>
                <li><strong>Ctrl / Shift + Click</strong><span>Chọn nhiều</span></li>
                <li><strong>Ctrl + A</strong><span>Chọn toàn bộ</span></li>
                <li><strong>Ctrl + F</strong><span>Tìm kiếm</span></li>
            </ul>
            <hr>
            <p><strong>User:</strong> <span id="current-user-display"></span> <button id="change-user-btn">[Sửa]</button></p>
            <p><strong>Chế độ:</strong> 
                <select id="theme-selector">
                    <option value="system">Tự động (System)</option>
                    <option value="light">Sáng (Light)</option>
                    <option value="dark">Tối (Dark)</option>
                </select>
            </p>
            <p><strong>Contact:</strong> tri.vu.trong@inbold.com</p>
        </div>
    </div>

    <!-- ADDED: Script tag to hold embedded annotation data -->
    <script id="annotation-data" type="application/json"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const app = {
                body: document.body, fileInput: document.getElementById('file-input'), imageInput: document.getElementById('image-input'), dropZone: document.getElementById('drop-zone'), annotationList: document.getElementById('annotation-list'), timelineSlider: document.getElementById('timeline-slider'), timeDisplay: document.getElementById('time-display'), 
                canvasMain: document.getElementById('canvas-main'), 
                canvasInteraction: document.getElementById('canvas-interaction'),
                videoMain: document.getElementById('video-main'), videoRef: document.getElementById('video-ref'), videoRefSlot: document.getElementById('video-slot-ref'), searchInput: document.getElementById('search-input'), 
                refVideoAddIcon: document.getElementById('ref-video-add-icon'),
                refVideoRemoveIcon: document.getElementById('ref-video-remove-icon'),
                mainVideoFilename: document.getElementById('main-video-filename'),
                refVideoFilename: document.getElementById('ref-video-filename'),
                listContainer: document.getElementById('list-container'),
                saveBtn: document.getElementById('save-btn'),
                get ctxMain() { return this.canvasMain.getContext('2d'); },
                get ctxInteraction() { return this.canvasInteraction.getContext('2d'); },
            };

            let state = {
                annotations: [], currentTool: null, activeColor: '#E53935', 
                interaction: { mode: 'none', target: null, startPos: { x: 0, y: 0 }, lastMousePos: { x: 0, y: 0 } },
                selectedIndices: [], 
                frameDuration: 1 / 30, isMuted: true, lastClickedIndex: -1,
                isLoadingRefVideo: false,
                undoStack: [], redoStack: [],
                currentFileHandle: null,
                currentFileName: null,
                hasUnsavedChanges: false,
                currentUser: null,
                clipboard: [] // ADDED: Internal clipboard for annotations
            };
            
            const imageCache = new Map();

            function init() {
                promptForUser(); 
                initTheme(); 
                autoLoadData(); // MODIFIED: Attempt to auto-load data on startup

                app.dropZone.addEventListener('dblclick', () => { state.isLoadingRefVideo = false; app.fileInput.click(); });
                
                document.getElementById('load-ref-video-btn').addEventListener('click', () => {
                    if (app.body.classList.contains('ref-video-loaded')) removeRefVideo();
                    else { state.isLoadingRefVideo = true; app.fileInput.click(); }
                });

                app.fileInput.addEventListener('change', e => e.target.files.length && handleFile(e.target.files[0]));

                window.addEventListener('dragover', e => { e.preventDefault(); document.body.classList.add('dragging'); });
                window.addEventListener('dragleave', e => { if (e.relatedTarget === null) document.body.classList.remove('dragging'); });
                window.addEventListener('drop', handleDrop);
                
                window.addEventListener('paste', handlePaste);

                document.getElementById('play-pause-btn').addEventListener('click', togglePlayPause);
                initMuteButton();
                document.querySelectorAll('.volume-btn').forEach(btn => btn.addEventListener('click', e => {
                    setVolume(parseFloat(e.target.dataset.volume));
                    document.getElementById('volume-popup').classList.add('hidden');
                }));

                document.querySelectorAll('.speed-btn').forEach(btn => btn.addEventListener('click', () => setPlaybackSpeed(parseFloat(btn.dataset.speed))));
                document.getElementById('snapshot-btn').addEventListener('click', saveFrame);
                app.timeDisplay.addEventListener('click', makeTimeEditable);
                app.timelineSlider.addEventListener('input', () => { seekTo(parseFloat(app.timelineSlider.value)); updateTimeline(); });
                
                document.querySelectorAll('.tool-btn').forEach(b => b.addEventListener('click', () => {
                    selectTool(b.dataset.tool);
                }));

                document.getElementById('active-color-btn').addEventListener('click', (e) => { e.stopPropagation(); toggleColorPalette(); });
                document.querySelectorAll('#color-palette-popup .color-btn').forEach(b => b.addEventListener('click', (e) => { e.stopPropagation(); selectColor(b); }));
                selectColor(document.querySelector('#color-palette-popup .color-btn[data-color="#E53935"]'));
                
                app.canvasInteraction.addEventListener('mousedown', onCanvasMouseDown);
                app.canvasInteraction.addEventListener('mousemove', onCanvasMouseMove);
                window.addEventListener('mouseup', onCanvasMouseUp);
                app.canvasInteraction.addEventListener('dblclick', onCanvasDblClick);
                app.canvasInteraction.addEventListener('wheel', onCanvasWheel, { passive: false });
                window.addEventListener('keydown', onKeyDown);
                
                document.getElementById('help-btn').addEventListener('click', () => document.getElementById('help-modal').classList.remove('hidden'));
                document.getElementById('modal-close-btn').addEventListener('click', () => document.getElementById('help-modal').classList.add('hidden'));
                document.getElementById('change-user-btn').addEventListener('click', changeUser);
                window.addEventListener('click', (e) => {
                     if (!e.target.closest('#color-picker')) document.getElementById('color-palette-popup').classList.add('hidden');
                     if (!e.target.closest('#mute-btn')) document.getElementById('volume-popup').classList.add('hidden');
                });
                app.saveBtn.addEventListener('click', saveAnnotations);
                app.searchInput.addEventListener('input', () => updateAnnotationList());

                app.listContainer.addEventListener('click', (e) => {
                    if (e.target === app.listContainer || e.target === app.annotationList) {
                        state.selectedIndices = [];
                        state.lastClickedIndex = -1;
                        updateListSelection();
                    }
                });
                updateSaveButtonState();

                const rightPanel = document.getElementById('right-panel');
                const resizer = document.getElementById('panel-resizer');

                resizer.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    const startX = e.clientX;
                    const startWidth = rightPanel.offsetWidth;
                    const doResize = (e) => {
                        const newWidth = startWidth - (e.clientX - startX);
                        if (newWidth > 250 && newWidth < 800) {
                            rightPanel.style.flexBasis = newWidth + 'px';
                        }
                    };
                    const stopResize = () => {
                        window.removeEventListener('mousemove', doResize);
                        window.removeEventListener('mouseup', stopResize);
                    };
                    window.addEventListener('mousemove', doResize);
                    window.addEventListener('mouseup', stopResize);
                });
            }

            // --- ADDED: Auto-load functionality ---
            async function autoLoadData() {
                const videoFilenameMeta = document.querySelector('meta[name="video-filename"]');
                const annotationDataScript = document.getElementById('annotation-data');

                const videoFilename = videoFilenameMeta ? videoFilenameMeta.getAttribute('content') : null;
                const annotationJson = annotationDataScript ? annotationDataScript.textContent.trim() : null;

                if (videoFilename && videoFilename !== "" && annotationJson) {
                    try {
                        const parsedAnnotations = JSON.parse(annotationJson);
                        // The video source is a relative path to the HTML file
                        loadMainVideo(videoFilename, videoFilename); 

                        // We must wait for video metadata to be loaded to get dimensions
                        app.videoMain.addEventListener('loadedmetadata', async () => {
                            await processLoadedAnnotations(parsedAnnotations);
                            state.annotations = parsedAnnotations;
                            updateAnnotationList();
                            updateSaveButtonState();
                            redrawAllCanvases();
                        }, { once: true });
                    } catch (err) {
                        console.error("Error auto-loading embedded data:", err);
                        alert('Lỗi khi tải dữ liệu annotation có sẵn trong file.');
                    }
                }
            }
            
            function promptForUser() {
                let user = localStorage.getItem('qcToolUser');
                while (!user || user.trim() === '') {
                    user = prompt('Vui lòng nhập tên của bạn (tối đa 16 ký tự):', user || '');
                    if (user) user = user.substring(0, 16);
                }
                state.currentUser = user.trim();
                localStorage.setItem('qcToolUser', state.currentUser);
                updateUserDisplay();
            }

            function changeUser() {
                let user = prompt('Nhập tên mới (tối đa 16 ký tự):', state.currentUser);
                if (user && user.trim() !== '') {
                    state.currentUser = user.trim().substring(0, 16);
                    localStorage.setItem('qcToolUser', state.currentUser);
                    updateUserDisplay();
                }
            }

            function updateUserDisplay() {
                document.getElementById('current-user-display').textContent = state.currentUser;
            }
            
            function applyTheme(theme) {
                app.body.classList.remove('theme-light', 'theme-dark');
                if (theme === 'light') {
                    app.body.classList.add('theme-light');
                } else if (theme === 'dark') {
                    app.body.classList.add('theme-dark');
                } else { // System
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                        app.body.classList.add('theme-light');
                    } else {
                        app.body.classList.add('theme-dark');
                    }
                }
            }

            function setTheme(theme) {
                applyTheme(theme);
                localStorage.setItem('qcToolTheme', theme);
                document.getElementById('theme-selector').value = theme;
            }

            function initTheme() {
                const savedTheme = localStorage.getItem('qcToolTheme') || 'system';
                setTheme(savedTheme);

                window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', e => {
                    const currentSetting = localStorage.getItem('qcToolTheme') || 'system';
                    if (currentSetting === 'system') {
                        applyTheme('system');
                    }
                });
                
                document.getElementById('theme-selector').addEventListener('change', e => setTheme(e.target.value));
            }


            async function handleDrop(e) {
                e.preventDefault();
                document.body.classList.remove('dragging');
                if (!e.dataTransfer.files.length) return;

                const files = Array.from(e.dataTransfer.files);
                const videoFile = files.find(f => f.type.startsWith('video/'));
                const imageFile = files.find(f => f.type.startsWith('image/'));
                
                // MODIFIED: TXT file loading is removed as it's replaced by HTML saving
                if (imageFile) {
                    state.interaction.lastMousePos = getMousePos(e);
                    const img = await createImageFromBlob(imageFile);
                    placeImageAnnotation(img);
                }

                if (videoFile) {
                    state.isLoadingRefVideo = (e.clientX < window.innerWidth / 2) && app.videoMain.src && !app.body.classList.contains('ref-video-loaded');
                    await handleFile(videoFile);
                }
            }


            async function handleFile(file) {
                if (file.type.startsWith('image/')) {
                    const img = await createImageFromBlob(file);
                    state.interaction.lastMousePos = { x: 0.5, y: 0.5 };
                    placeImageAnnotation(img);
                    return;
                }
                
                const fileURL = URL.createObjectURL(file);
                if (file.type.startsWith('video/')) {
                    if (state.isLoadingRefVideo) { 
                        loadRefVideo(fileURL, file.name); 
                    } else { 
                        loadMainVideo(fileURL, file.name); 
                    }
                }
                // MODIFIED: No longer handling .txt files
                state.isLoadingRefVideo = false;
            }

            async function processLoadedAnnotations(annotations) {
                const imageAnnotations = annotations.filter(ann => ann.type === 'image' && ann.data.base64);
                const promises = imageAnnotations.map(ann => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            imageCache.set(ann.data.base64, img);
                            ann.data.imageObject = img;
                             if (ann.data.x && app.videoMain.videoWidth) {
                                const { x, y, width, height } = ann.data;
                                ann.data.p1 = { x: (x - width / 2) / app.videoMain.videoWidth, y: (y - height / 2) / app.videoMain.videoHeight };
                                ann.data.p2 = { x: (x + width / 2) / app.videoMain.videoWidth, y: (y + height / 2) / app.videoMain.videoHeight };
                            }
                            resolve();
                        };
                        img.onerror = () => { resolve(); };
                        img.src = ann.data.base64;
                    });
                });
                await Promise.all(promises);
            }
            
            function createImageFromBlob(blob) {
                return new Promise((resolve, reject) => {
                    const url = URL.createObjectURL(blob);
                    const img = new Image();
                    img.onload = () => {
                        resolve(img);
                    };
                    img.onerror = (err) => {
                        URL.revokeObjectURL(url);
                        reject(err);
                    };
                    img.src = url;
                });
            }

            function placeImageAnnotation(img) {
                if (!app.videoMain.videoWidth) return;

                const MAX_SIZE_PX = 250;
                let { naturalWidth: width, naturalHeight: height } = img;
                
                const videoRect = getVideoRect(app.canvasInteraction, app.videoMain);
                const scale = Math.min(videoRect.width / app.videoMain.videoWidth, videoRect.height / app.videoMain.videoHeight);

                let scaledWidth = width * scale;
                let scaledHeight = height * scale;

                if (scaledWidth > scaledHeight) {
                    if (scaledWidth > MAX_SIZE_PX) { scaledHeight *= MAX_SIZE_PX / scaledWidth; scaledWidth = MAX_SIZE_PX; }
                } else {
                    if (scaledHeight > MAX_SIZE_PX) { scaledWidth *= MAX_SIZE_PX / scaledHeight; scaledHeight = MAX_SIZE_PX; }
                }

                const finalWidthRatio = (scaledWidth / scale) / app.videoMain.videoWidth;
                const finalHeightRatio = (scaledHeight / scale) / app.videoMain.videoHeight;
                
                const centerPos = state.interaction.lastMousePos.x !== 0 || state.interaction.lastMousePos.y !== 0 
                    ? state.interaction.lastMousePos 
                    : { x: 0.5, y: 0.5};

                const ann = {
                    type: 'image',
                    time: app.videoMain.currentTime,
                    data: {
                        imageObject: img,
                        p1: { x: centerPos.x - finalWidthRatio / 2, y: centerPos.y - finalHeightRatio / 2 },
                        p2: { x: centerPos.x + finalWidthRatio / 2, y: centerPos.y + finalHeightRatio / 2 }
                    },
                    completed: false
                };
                addAnnotation(ann);
            }

            // --- UPDATED to handle internal clipboard pasting ---
            async function handlePaste(e) {
                if (document.activeElement !== document.body && document.activeElement !== app.canvasInteraction) return;

                // PRIORITIZE internal annotation paste
                if (state.clipboard.length > 0) {
                    e.preventDefault();
                    pasteAnnotationsFromInternalClipboard();
                    return;
                }

                // Fallback to original paste logic for system clipboard (images/text)
                const items = e.clipboardData.items;
                let textItem = null;

                for (const item of items) {
                    if (item.type.startsWith('image/')) {
                        e.preventDefault();
                        const blob = item.getAsFile();
                        const img = await createImageFromBlob(blob);
                        state.interaction.lastMousePos = getMousePos(e); 
                        if(state.interaction.lastMousePos.x === 0 && state.interaction.lastMousePos.y === 0){
                           state.interaction.lastMousePos = { x: 0.5, y: 0.5 };
                        }
                        placeImageAnnotation(img);
                        return; 
                    }
                    if (item.type === 'text/plain') {
                        textItem = item;
                    }
                }

                if (textItem) {
                    e.preventDefault();
                    textItem.getAsString(text => {
                        if (text.trim().length > 0) {
                            const pos = state.interaction.lastMousePos.x !== 0 ? state.interaction.lastMousePos : { x: 0.5, y: 0.5 };
                            
                            const ann = {
                                type: 'comment',
                                time: app.videoMain.currentTime,
                                data: { x: pos.x, y: pos.y },
                                color: state.activeColor,
                                text: text,
                                completed: false
                            };
                            addAnnotation(ann, false); 
                        }
                    });
                }
            }


            function loadMainVideo(src, name) {
                // ADDED: Reset state if a new video is loaded manually
                if (app.videoMain.src && !app.videoMain.src.endsWith(src)) {
                    state.annotations = [];
                    state.undoStack = [];
                    state.redoStack = [];
                    state.selectedIndices = [];
                    state.clipboard = [];
                    state.currentFileHandle = null;
                    state.currentFileName = null;
                    state.hasUnsavedChanges = false;
                    updateAnnotationList();
                }

                app.videoMain.src = src; app.videoMain.muted = state.isMuted; app.dropZone.classList.add('hidden');
                app.mainVideoFilename.textContent = name;
                app.mainVideoFilename.classList.remove('hidden');
                app.videoMain.addEventListener('loadedmetadata', () => {
                    const track = app.videoMain.getVideoPlaybackQuality ? app.videoMain.getVideoPlaybackQuality() : {};
                    const frameRate = (track.totalVideoFrames / app.videoMain.duration) || 30;
                    state.frameDuration = 1 / frameRate;
                    updateTimelineDurations();
                    new ResizeObserver(redrawAllCanvases).observe(app.videoMain.parentElement);
                    redrawAllCanvases();
                }, { once: true });
                app.videoMain.addEventListener('timeupdate', updateTimeline);
                app.videoMain.addEventListener('play', () => { setPlayButtonState(true); if (app.videoRef.src) app.videoRef.play(); });
                app.videoMain.addEventListener('pause', () => { setPlayButtonState(false); if (app.videoRef.src) app.videoRef.pause(); });
            }
            
            function loadRefVideo(src, name) {
                app.videoRef.src = src; app.videoRef.muted = true;
                app.body.classList.add('ref-video-loaded');
                app.videoRefSlot.classList.remove('hidden');
                app.refVideoFilename.textContent = name;
                app.refVideoFilename.classList.remove('hidden');
                app.refVideoAddIcon.classList.add('hidden');
                app.refVideoRemoveIcon.classList.remove('hidden');
                app.videoRef.addEventListener('loadedmetadata', () => { 
                    seekTo(app.videoMain.currentTime); 
                    updateTimelineDurations();
                }, { once: true });
                redrawAllCanvases();
            }

            function removeRefVideo() {
                app.videoRef.src = '';
                app.body.classList.remove('ref-video-loaded');
                app.videoRefSlot.classList.add('hidden');
                app.refVideoFilename.classList.add('hidden');
                app.refVideoAddIcon.classList.remove('hidden');
                app.refVideoRemoveIcon.classList.add('hidden');
                updateTimelineDurations(); 
                redrawAllCanvases();
            }

            function updateTimelineDurations() {
                const mainDuration = app.videoMain.duration || 0;
                const refDuration = app.videoRef.duration || 0;
                const diffEl = document.getElementById('timeline-diff');

                if (!isFinite(mainDuration) || refDuration <= 0 || !isFinite(refDuration)) {
                    app.timelineSlider.max = mainDuration || 100;
                    diffEl.style.width = '0%';
                    return;
                }

                const maxDuration = Math.max(mainDuration, refDuration);
                const minDuration = Math.min(mainDuration, refDuration);
                
                app.timelineSlider.max = maxDuration;

                if (maxDuration > minDuration) {
                    const diffPercent = ((maxDuration - minDuration) / maxDuration) * 100;
                    const startPercent = (minDuration / maxDuration) * 100;
                    diffEl.style.width = `${diffPercent}%`;
                    diffEl.style.left = `${startPercent}%`;
                } else {
                    diffEl.style.width = '0%';
                }
            }

            // --- REWRITTEN/NEW Save Functionality ---
            async function getBase64FromImage(img) {
                return new Promise(resolve => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);
                    resolve(canvas.toDataURL('image/jpeg', 0.7));
                });
            }
             
            async function prepareAnnotationsForSave() {
                if (!app.videoMain.videoWidth) return [];
                const annotationsToSave = JSON.parse(JSON.stringify(state.annotations));
                for (let i = 0; i < state.annotations.length; i++) {
                    const ann = state.annotations[i];
                    if (ann.type === 'image' && ann.data.imageObject) {
                        const base64 = await getBase64FromImage(ann.data.imageObject);
                        const { p1, p2 } = ann.data;
                        const width = Math.abs(p2.x - p1.x) * app.videoMain.videoWidth;
                        const height = Math.abs(p2.y - p1.y) * app.videoMain.videoHeight;
                        const x = (p1.x + p2.x) / 2 * app.videoMain.videoWidth;
                        const y = (p1.y + p2.y) / 2 * app.videoMain.videoHeight;

                        annotationsToSave[i].data = { base64, x, y, width, height };
                    }
                }
                return annotationsToSave;
            }

            async function generateAnnotatedHTML() {
                const annotationsToSave = await prepareAnnotationsForSave();
                const dataStr = JSON.stringify(annotationsToSave, null, 2);

                const docClone = document.cloneNode(true);
                
                const annotationScript = docClone.getElementById('annotation-data');
                if (annotationScript) {
                    annotationScript.textContent = '\n' + dataStr + '\n';
                }

                const videoMeta = docClone.querySelector('meta[name="video-filename"]');
                if (videoMeta) {
                    videoMeta.setAttribute('content', app.mainVideoFilename.textContent || '');
                }

                return `<!DOCTYPE html>\n` + docClone.documentElement.outerHTML;
            }

            async function saveAnnotations() {
                if (!app.videoMain.src) return;

                if (!state.currentFileHandle) {
                   await saveAnnotationsAs();
                   return;
                }
                
                const htmlContent = await generateAnnotatedHTML();

                try {
                    const writable = await state.currentFileHandle.createWritable();
                    await writable.write(htmlContent);
                    await writable.close();
                    state.hasUnsavedChanges = false;
                    updateSaveButtonState();
                } catch (err) { 
                    console.error('Error saving:', err); 
                    alert("Lưu file thất bại. Vui lòng thử 'Lưu thành file mới'.");
                    await saveAnnotationsAs();
                }
            }
            
            async function saveAnnotationsAs() {
                if (!app.videoMain.src) return;
                const htmlContent = await generateAnnotatedHTML();

                const fallbackSave = (data) => {
                    const videoFileName = (app.mainVideoFilename.textContent || 'video').split('.').slice(0, -1).join('.') || 'video_qc';
                    const blob = new Blob([data], { type: 'text/html;charset=utf-8' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = `${videoFileName}_QC.html`;
                    a.click();
                    URL.revokeObjectURL(a.href);
                    state.hasUnsavedChanges = false;
                    updateSaveButtonState();
                };

                if ('showSaveFilePicker' in window) {
                    try {
                        const videoFileName = (app.mainVideoFilename.textContent || 'video').split('.').slice(0, -1).join('.') || 'video_qc';
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: `${videoFileName}_QC.html`,
                            types: [{ description: 'HTML QC File', accept: { 'text/html': ['.html'] } }]
                        });
                        
                        const writable = await fileHandle.createWritable();
                        await writable.write(htmlContent);
                        await writable.close();
                        
                        state.currentFileHandle = fileHandle;
                        state.currentFileName = fileHandle.name;
                        state.hasUnsavedChanges = false;
                        updateSaveButtonState();
                        
                    } catch (err) {
                        if (err.name !== 'AbortError') { console.error('Error saving file:', err); fallbackSave(htmlContent); }
                    }
                } else {
                    fallbackSave(htmlContent);
                }
            }


            function updateSaveButtonState() {
                const count = state.annotations.length;
                const countText = ` ${count} cmt`;

                if (state.hasUnsavedChanges) {
                    app.saveBtn.textContent = `Chưa lưu${countText}`;
                    app.saveBtn.classList.add('unsaved');
                } else {
                    app.saveBtn.classList.remove('unsaved');
                    if (state.currentFileHandle) {
                        app.saveBtn.textContent = `Đã lưu${countText}`;
                    } else {
                        app.saveBtn.textContent = `Lưu file HTML${count > 0 ? countText : ''}`;
                    }
                }
            }
            // --- END of new save logic ---

            function markAsChanged() {
                if (!state.hasUnsavedChanges) {
                    state.hasUnsavedChanges = true;
                    updateSaveButtonState();
                }
            }

            const togglePlayPause = () => app.videoMain.src && (app.videoMain.paused ? app.videoMain.play() : app.videoMain.pause());
            const setPlayButtonState = isPlaying => { document.getElementById('play-icon').classList.toggle('hidden', isPlaying); document.getElementById('pause-icon').classList.toggle('hidden', !isPlaying); };
            
            let longPressTimer;
            let isLongPress = false;
            
            function initMuteButton() {
                const muteBtn = document.getElementById('mute-btn');
                muteBtn.addEventListener('mousedown', () => {
                    isLongPress = false;
                    longPressTimer = setTimeout(() => {
                        isLongPress = true;
                        const volumePopup = document.getElementById('volume-popup');
                        volumePopup.classList.remove('hidden');
                    }, 1000); // 1 second
                });
                
                muteBtn.addEventListener('mouseup', () => {
                    clearTimeout(longPressTimer);
                });

                muteBtn.addEventListener('click', () => {
                    if (!isLongPress) {
                        toggleMute();
                    }
                });
            }
            
            const updateMuteIcon = () => {
                const isEffectivelyMuted = state.isMuted || app.videoMain.volume === 0;
                document.getElementById('mute-icon').classList.toggle('hidden', !isEffectivelyMuted);
                document.getElementById('unmute-icon').classList.toggle('hidden', isEffectivelyMuted);
            };

            const toggleMute = () => {
                state.isMuted = !state.isMuted;
                if (state.isMuted) {
                    app.videoMain.muted = true;
                } else {
                    app.videoMain.muted = false;
                    if (app.videoMain.volume === 0) {
                        app.videoMain.volume = 0.75;
                    }
                }
                updateMuteIcon();
            };

            function setVolume(level) {
                app.videoMain.volume = level;
                state.isMuted = level === 0;
                app.videoMain.muted = state.isMuted;
                updateMuteIcon();
                
                document.querySelectorAll('.volume-btn').forEach(btn => {
                    btn.classList.toggle('active', parseFloat(btn.dataset.volume) === level);
                });
            }


            const setPlaybackSpeed = speed => { 
                app.videoMain.playbackRate = speed;
                if(app.videoRef.src) app.videoRef.playbackRate = speed;
                document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed)); 
            };
            const seekTo = time => { 
                if (app.videoMain.src) { 
                    const newTime = Math.max(0, Math.min(app.timelineSlider.max, time));
                    app.videoMain.currentTime = newTime;
                    if (app.videoRef.src) app.videoRef.currentTime = newTime;
                    redrawAllCanvases();
                }
            };
            const seekFrames = count => seekTo(app.videoMain.currentTime + count * state.frameDuration);
            const seekSeconds = count => seekTo(app.videoMain.currentTime + count);
            const updateTimeline = () => { if(!app.timelineSlider.matches(':active')) app.timelineSlider.value = app.videoMain.currentTime; app.timeDisplay.textContent = formatTime(app.videoMain.currentTime); redrawAllCanvases(); };

            function onCanvasMouseDown(e) {
                state.interaction.startPos = getMousePos(e);
                const hit = getHitAnnotation(state.interaction.startPos);
                if (hit.handle) {
                    state.interaction.mode = 'resizing'; state.interaction.target = { index: hit.index, handle: hit.handle };
                } else if (hit.index !== -1) {
                    state.interaction.mode = 'dragging';
                    if (!state.selectedIndices.includes(hit.index)) { state.selectedIndices = [hit.index]; state.lastClickedIndex = hit.index; updateListSelection(); }
                    redrawAllCanvases();
                } else if (state.currentTool) {
                    app.videoMain.pause();
                    if (state.currentTool === 'comment') {
                        addAnnotation({ type: 'comment', time: app.videoMain.currentTime, data: { x: state.interaction.startPos.x, y: state.interaction.startPos.y }, color: state.activeColor, text: '', completed: false }, true);
                    } else {
                        state.interaction.mode = 'drawing';
                    }
                } else {
                    state.selectedIndices = []; state.lastClickedIndex = -1; updateListSelection(); redrawAllCanvases();
                }
            }
            function onCanvasMouseMove(e) {
                const currentPos = getMousePos(e);
                state.interaction.lastMousePos = currentPos;
                const { ctxInteraction: ctx, canvasInteraction: canvas } = app;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                switch (state.interaction.mode) {
                    case 'drawing': 
                        drawShape(ctx, {type: state.currentTool, data: {p1: state.interaction.startPos, p2: currentPos}, color: state.activeColor}, true, true); 
                        break;
                    case 'dragging':
                        const dx = currentPos.x - state.interaction.startPos.x; const dy = currentPos.y - state.interaction.startPos.y;
                        state.selectedIndices.forEach(idx => moveAnnotation(idx, dx, dy));
                        state.interaction.startPos = currentPos; redrawAllCanvases(); markAsChanged(); 
                        break;
                    case 'resizing': 
                        resizeAnnotation(state.interaction.target.index, state.interaction.target.handle, currentPos); 
                        redrawAllCanvases(); 
                        markAsChanged(); 
                        break;
                    default: 
                        const hit = getHitAnnotation(currentPos); 
                        app.canvasInteraction.style.cursor = hit.cursor || (state.currentTool ? 'crosshair' : 'default');
                }
            }
            function onCanvasMouseUp(e) {
                app.ctxInteraction.clearRect(0, 0, app.canvasInteraction.width, app.canvasInteraction.height);
                if (state.interaction.mode === 'drawing') {
                    const endPos = getMousePos(e);
                    if (Math.hypot(endPos.x - state.interaction.startPos.x, endPos.y - state.interaction.startPos.y) * app.videoMain.videoWidth > 5) {
                        addAnnotation({ type: state.currentTool, time: app.videoMain.currentTime, data: { p1: state.interaction.startPos, p2: endPos }, color: state.activeColor, text: '', completed: false }, true);
                    }
                }
                state.interaction.mode = 'none';
                app.canvasInteraction.style.cursor = getHitAnnotation(getMousePos(e)).cursor || 'default';
                redrawAllCanvases();
            }
            function onCanvasDblClick(e) {
                const hit = getHitAnnotation(getMousePos(e));
                if (hit.index !== -1) {
                    const li = app.annotationList.querySelector(`li[data-id='${state.annotations[hit.index].id}']`);
                    if (li) makeListItemEditable(li, hit.index);
                }
            }
            function onCanvasWheel(e) {
                e.preventDefault();
                seekFrames(e.deltaY > 0 ? 1 : -1); 
            }
            
            function onKeyDown(e) {
                const activeEl = document.activeElement;
                if (['TEXTAREA', 'INPUT'].includes(activeEl.tagName) && activeEl.id !== 'search-input') return;
                
                if (e.ctrlKey) {
                    switch (e.key.toLowerCase()) {
                        case 's': 
                            e.preventDefault(); 
                            if (e.shiftKey) { saveAnnotationsAs(); }
                            else { saveAnnotations(); }
                            return;
                        case 'z': e.preventDefault(); e.shiftKey ? redoDelete() : undoDelete(); return;
                        case 'f': e.preventDefault(); app.searchInput.focus(); app.searchInput.select(); return;
                        case 'a': e.preventDefault(); state.selectedIndices = state.annotations.map((_, i) => i); updateListSelection(); redrawAllCanvases(); return;
                        case 'd': e.preventDefault(); state.isLoadingRefVideo = false; app.fileInput.click(); return;
                        case 'c': 
                            if (state.selectedIndices.length > 0) {
                                e.preventDefault();
                                // Logic for system clipboard
                                const selectedAnn = state.annotations[state.selectedIndices[0]];
                                if (selectedAnn.type === 'image') {
                                    copyImageToClipboard(selectedAnn).catch(err => console.error('Failed to copy image:', err));
                                } else {
                                    const textToCopy = state.selectedIndices
                                        .map(index => state.annotations[index].text || '')
                                        .filter(text => text)
                                        .join('\n');
                                    if (textToCopy) navigator.clipboard.writeText(textToCopy).catch(err => console.error('Failed to copy text: ', err));
                                }
                                // ADDED: Logic for internal clipboard
                                copyAnnotationsToInternalClipboard();
                            }
                            return;
                        case 'v': 
                            // Paste is handled by the 'paste' event listener now
                            return;
                    }
                }

                let handled = true;
                switch(e.key) {
                    case ' ': if (activeEl.id !== 'search-input') togglePlayPause(); break;
                    case 'ArrowLeft': e.shiftKey ? seekSeconds(-1) : seekFrames(-1); break;
                    case 'ArrowRight': e.shiftKey ? seekSeconds(1) : seekFrames(1); break;
                    case 'ArrowUp': seekTo(0); break;
                    case 'ArrowDown': seekTo(app.timelineSlider.max); break;
                    case 'Delete': deleteAnnotationsByIndices(state.selectedIndices); break;
                    default: handled = false;
                }
                if (handled) e.preventDefault();

                if ('qwerty'.includes(e.key.toLowerCase())) {
                    const toolMap = {q:'comment', w:'rect', e:'circle', r:'line', t:'arrow'};
                    selectTool(toolMap[e.key]);
                }
            }

            // --- START: NEW Copy/Paste functionality ---
            function copyAnnotationsToInternalClipboard() {
                if (state.selectedIndices.length === 0) {
                    state.clipboard = []; // Clear clipboard if nothing is selected
                    return;
                }

                const allAnnotationsMap = new Map(state.annotations.map(ann => [ann.id, ann]));
                const idsToCopy = new Set();
                const queue = state.selectedIndices.map(index => state.annotations[index].id);

                // Add initially selected items to the set
                queue.forEach(id => idsToCopy.add(id));
                
                // Use a queue to find all children of selected items
                let head = 0;
                while (head < queue.length) {
                    const parentId = queue[head++]; // Process the queue
                    state.annotations.forEach(ann => {
                        if (ann.parentId === parentId && !idsToCopy.has(ann.id)) {
                            idsToCopy.add(ann.id);
                            queue.push(ann.id);
                        }
                    });
                }
                
                // Deep copy all annotations that need to be copied (selected + their descendants)
                state.clipboard = Array.from(idsToCopy)
                    .map(id => allAnnotationsMap.get(id))
                    .map(ann => JSON.parse(JSON.stringify(ann)));
            }

            function pasteAnnotationsFromInternalClipboard() {
                if (state.clipboard.length === 0) return;

                const idMap = new Map();
                const newAnnotations = [];
                const currentTime = app.videoMain.currentTime;
                
                // Create new annotations and map old IDs to new IDs
                state.clipboard.forEach(oldAnn => {
                    const newAnn = JSON.parse(JSON.stringify(oldAnn)); // Deep copy from clipboard
                    const newId = crypto.randomUUID();
                    idMap.set(oldAnn.id, newId);
                    newAnn.id = newId;
                    newAnn.time = currentTime;
                    newAnn.user = state.currentUser; // Assign to current user
                    newAnn.completed = false; // Pasted items are not completed
                    newAnnotations.push(newAnn);
                });

                // Set of all newly created IDs for checking parent relationships
                const newIdSet = new Set(idMap.values());

                // Update parentId references for the new annotations
                newAnnotations.forEach(newAnn => {
                    // if the original parent was also copied, update the parentId to the new parent's ID
                    if (newAnn.parentId && idMap.has(newAnn.parentId)) {
                        newAnn.parentId = idMap.get(newAnn.parentId);
                    } else {
                        // if the original parent was NOT copied, this becomes a top-level annotation
                        newAnn.parentId = null;
                    }
                });

                // Add to main annotations array
                state.annotations.push(...newAnnotations);
                state.annotations.sort((a, b) => a.time - b.time);

                // Select the newly pasted items
                state.selectedIndices = state.annotations
                    .map((ann, index) => ({ ann, index }))
                    .filter(item => newIdSet.has(item.ann.id))
                    .map(item => item.index);
                state.lastClickedIndex = state.selectedIndices.length > 0 ? state.selectedIndices[state.selectedIndices.length - 1] : -1;

                markAsChanged();
                updateAnnotationList();
                redrawAllCanvases();

                // Scroll the last new item into view
                if (state.lastClickedIndex !== -1) {
                    const lastNewId = state.annotations[state.lastClickedIndex].id;
                     const li = app.annotationList.querySelector(`li[data-id='${lastNewId}']`);
                    if (li) li.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
            // --- END: NEW Copy/Paste functionality ---


            function addAnnotation(ann, startEditing = false) {
                 if (['rect', 'circle', 'line', 'arrow'].includes(ann.type) && !ann.text) {
                    ann.text = ''; 
                }
                ann.user = state.currentUser;
                ann.id = crypto.randomUUID();
                ann.parentId = ann.parentId || null;

                state.annotations.push(ann);
                state.annotations.sort((a,b) => a.time - b.time);
                state.undoStack = []; state.redoStack = [];
                const newIndex = state.annotations.findIndex(a => a === ann);
                state.selectedIndices = [newIndex];
                state.lastClickedIndex = newIndex;
                markAsChanged();
                updateAnnotationList();
                updateSaveButtonState();
                redrawAllCanvases();
                if (startEditing) {
                    const li = app.annotationList.querySelector(`li[data-id='${ann.id}']`);
                    if (li) { li.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); makeListItemEditable(li, newIndex); }
                }
            }
            
            function updateListSelection() {
                const selectedIds = new Set(state.selectedIndices.map(i => state.annotations[i]?.id));
                app.annotationList.querySelectorAll('li').forEach(item => {
                    item.classList.toggle('selected', selectedIds.has(item.dataset.id));
                });
                redrawAllCanvases();
            }
            
            async function copyImageToClipboard(annotation) {
                const img = annotation.data.imageObject;
                if (!img || !('write' in navigator.clipboard)) {
                    throw new Error("Image object not found or Clipboard API not supported.");
                }
                
                const blob = await new Promise(resolve => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    canvas.toBlob(blob => resolve(blob), 'image/png');
                });

                if (!blob) throw new Error("Failed to convert image to blob.");
                
                await navigator.clipboard.write([ new ClipboardItem({ [blob.type]: blob }) ]);
            }
            
            function updateAnnotationList() {
                const listScrollTop = app.annotationList.scrollTop;
                app.annotationList.innerHTML = '';
                const searchTerm = app.searchInput.value.toLowerCase();
                
                let annotationsToDisplay = state.annotations;

                if (searchTerm) {
                    const annotationMap = new Map(state.annotations.map(ann => [ann.id, ann]));
                    const matchingAnnotations = state.annotations.filter(ann => {
                        const typeDisplay = ann.parentId ? 'reply' : (ann.type === 'comment' ? 'cmt' : ann.type);
                        return (ann.text || '').toLowerCase().includes(searchTerm) ||
                               (ann.user || '').toLowerCase().includes(searchTerm) ||
                               typeDisplay.toLowerCase().includes(searchTerm);
                    });

                    const idsToRender = new Set();
                    matchingAnnotations.forEach(ann => {
                        let current = ann;
                        while(current) {
                            if (idsToRender.has(current.id)) break;
                            idsToRender.add(current.id);
                            current = current.parentId ? annotationMap.get(current.parentId) : null;
                        }
                        
                        const queue = [ann.id];
                        while (queue.length > 0) {
                            const parentId = queue.shift();
                            state.annotations.forEach(child => {
                                if (child.parentId === parentId && !idsToRender.has(child.id)) {
                                    idsToRender.add(child.id);
                                    queue.push(child.id);
                                }
                            });
                        }
                    });
                    annotationsToDisplay = state.annotations.filter(ann => idsToRender.has(ann.id));
                }

                const renderAnnotation = (ann, index) => {
                    const li = document.createElement('li');
                    li.dataset.id = ann.id;
                    li.dataset.index = index;
                    li.classList.toggle('selected', state.selectedIndices.includes(index));
                    li.classList.toggle('completed', ann.completed);
                    li.classList.toggle('reply-item', !!ann.parentId);

                    let contentHtml = '';
                    if (ann.type === 'image') {
                        const img = ann.data.imageObject || imageCache.get(ann.data.base64);
                        if(img) contentHtml += `<img src="${img.src}" class="annotation-image" alt="Annotation Image">`;
                    }
                    if (ann.text) {
                        contentHtml += `<p class="content">${ann.text.replace(/\n/g, '<br>')}</p>`;
                    }

                    const title = ann.type === 'image' ? 'image' : 'text';
                    let headerToolsHtml = `
                        <button class="icon-btn" title="Xóa">
                           <svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                        </button>
                        <button class="icon-btn" title="Copy ${title}">
                            <svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                        </button>
                        <button class="icon-btn" title="Trả lời">
                            <svg viewBox="0 0 24 24"><path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/></svg>
                        </button>
                        <input type="checkbox" class="complete-checkbox" ${ann.completed ? 'checked' : ''}>`;

                    const typeDisplay = ann.parentId ? 'reply' : (ann.type === 'comment' ? 'cmt' : ann.type);
                    const userDisplay = ann.user ? ` - <strong>${ann.user}</strong>` : '';
                    li.innerHTML = `
                        <div class="header">
                            <span class="time">${index + 1} - ${formatTime(ann.time)}${userDisplay} - ${typeDisplay}</span>
                            <div class="header-tools">${headerToolsHtml}</div>
                        </div>
                        ${contentHtml}`;

                    li.addEventListener('click', e => {
                        if (e.target.closest('.icon-btn')) return;
                        const clickedIndex = parseInt(li.dataset.index, 10);
                        if (e.shiftKey && state.lastClickedIndex !== -1) {
                            const start = Math.min(state.lastClickedIndex, clickedIndex);
                            const end = Math.max(state.lastClickedIndex, clickedIndex);
                            state.selectedIndices = Array.from({length: end - start + 1}, (_, i) => start + i);
                        } else if (e.ctrlKey) {
                            const idxInSelection = state.selectedIndices.indexOf(clickedIndex);
                            if (idxInSelection > -1) { state.selectedIndices.splice(idxInSelection, 1); } else { state.selectedIndices.push(clickedIndex); }
                        } else { state.selectedIndices = [clickedIndex]; }
                        state.lastClickedIndex = clickedIndex;
                        seekTo(ann.time); 
                        updateListSelection();
                    });

                    li.addEventListener('dblclick', () => makeListItemEditable(li, index));
                    li.querySelector('.complete-checkbox').addEventListener('click', e => { e.stopPropagation(); ann.completed = e.target.checked; li.classList.toggle('completed', ann.completed); markAsChanged(); redrawAllCanvases(); });

                    const [deleteBtn, copyBtn, replyBtn] = li.querySelectorAll('.icon-btn');

                    deleteBtn.addEventListener('click', e => {
                        e.stopPropagation();
                        deleteAnnotationsByIndices([index]);
                    });

                    copyBtn.addEventListener('click', e => {
                        e.stopPropagation();
                        const showFeedback = (target, success) => {
                            const originalContent = target.innerHTML;
                            target.innerHTML = success ? '✓' : '✗';
                            setTimeout(() => { target.innerHTML = originalContent; }, 1500);
                        };
                        if (ann.type === 'image') {
                            copyImageToClipboard(ann).then(() => showFeedback(e.currentTarget, true)).catch(err => { console.error('Failed to copy image: ', err); showFeedback(e.currentTarget, false); });
                        } else {
                            navigator.clipboard.writeText(ann.text || '').then(() => showFeedback(e.currentTarget, true)).catch(err => { console.error('Failed to copy text: ', err); showFeedback(e.currentTarget, false); });
                        }
                    });
                    
                    replyBtn.addEventListener('click', e => {
                        e.stopPropagation();
                        addAnnotation({
                            type: 'comment', time: ann.time,
                            data: { x: ann.data.x, y: ann.data.y },
                            color: state.activeColor, text: '', completed: false,
                            parentId: ann.id
                        }, true);
                    });
                    return li;
                };
                
                const annotationTree = annotationsToDisplay.filter(ann => !ann.parentId);
                const replyMap = new Map();
                annotationsToDisplay.filter(ann => ann.parentId).forEach(reply => {
                    if (!replyMap.has(reply.parentId)) replyMap.set(reply.parentId, []);
                    replyMap.get(reply.parentId).push(reply);
                });

                const renderThread = (ann) => {
                    const index = state.annotations.indexOf(ann);
                    const li = renderAnnotation(ann, index);
                    app.annotationList.appendChild(li);
                    const children = replyMap.get(ann.id) || [];
                    children.forEach(renderThread);
                };

                annotationTree.forEach(renderThread);
                app.annotationList.scrollTop = listScrollTop;
            }

            function makeListItemEditable(li, index) {
                const ann = state.annotations[index];
                if(ann.type === 'image') return; 

                let contentEl = li.querySelector('.content');
                if (!contentEl) {
                    contentEl = document.createElement('p');
                    contentEl.className = 'content';
                    li.appendChild(contentEl);
                }
                if (contentEl.querySelector('textarea')) return;

                const oldText = ann.text || '';
                contentEl.innerHTML = `<textarea rows="1">${oldText}</textarea>`;
                const textarea = contentEl.querySelector('textarea');
                const autoSize = () => { textarea.style.height = 'auto'; textarea.style.height = `${textarea.scrollHeight}px`; };
                textarea.addEventListener('input', autoSize);
                setTimeout(() => { textarea.focus(); textarea.select(); autoSize(); }, 0);
                const save = () => { 
                    const newText = textarea.value;
                    if (newText !== oldText) { ann.text = newText; markAsChanged(); }
                    const currentSelectedIndexes = [...state.selectedIndices];
                    updateAnnotationList();
                    state.selectedIndices = currentSelectedIndexes;
                    updateListSelection();
                    redrawAllCanvases();
                };
                textarea.addEventListener('blur', save);
                textarea.addEventListener('keydown', e => { if (e.key === 'Escape') { e.stopPropagation(); textarea.removeEventListener('blur', save); updateAnnotationList();} if (e.ctrlKey && e.key === 'Enter') { e.stopPropagation(); textarea.blur(); } });
            }
            
            function deleteAnnotationsByIndices(indicesToDelete) {
                if (!indicesToDelete || indicesToDelete.length === 0) return;

                const idsToDelete = new Set();
                const queue = indicesToDelete.map(index => state.annotations[index]?.id).filter(id => id);
                
                queue.forEach(id => idsToDelete.add(id));
                
                let currentQueue = [...queue];
                while(currentQueue.length > 0) {
                    const parentId = currentQueue.shift();
                    const children = state.annotations.filter(ann => ann.parentId === parentId);
                    children.forEach(child => {
                        if (!idsToDelete.has(child.id)) {
                            idsToDelete.add(child.id);
                            currentQueue.push(child.id);
                        }
                    });
                }
                
                const deletedItems = state.annotations
                    .map((annotation, originalIndex) => ({ annotation, originalIndex }))
                    .filter(item => idsToDelete.has(item.annotation.id))
                    .sort((a,b) => a.originalIndex - b.originalIndex);

                if (deletedItems.length === 0) return;

                state.undoStack.push(deletedItems);
                state.redoStack = [];

                state.annotations = state.annotations.filter(ann => !idsToDelete.has(ann.id));
                state.selectedIndices = [];
                state.lastClickedIndex = -1;
                
                markAsChanged();
                updateAnnotationList(); 
                updateSaveButtonState();
                redrawAllCanvases();
            }

            function undoDelete() {
                if (state.undoStack.length === 0) return;
                const itemsToRestore = state.undoStack.pop();
                state.redoStack.push(itemsToRestore);
                itemsToRestore.forEach(item => state.annotations.splice(item.originalIndex, 0, item.annotation));
                markAsChanged();
                updateAnnotationList(); 
                updateSaveButtonState();
                redrawAllCanvases();
            }

            function redoDelete() {
                if (state.redoStack.length === 0) return;
                const itemsToDeleteFromRedo = state.redoStack.pop();
                state.undoStack.push(itemsToDeleteFromRedo);

                const idsToDelete = new Set(itemsToDeleteFromRedo.map(item => item.annotation.id));
                state.annotations = state.annotations.filter(ann => !idsToDelete.has(ann.id));
                
                markAsChanged();
                updateAnnotationList(); 
                updateSaveButtonState();
                redrawAllCanvases();
            }

            function redrawAllCanvases() {
                const { ctxMain: ctx, canvasMain: canvas, videoMain: video } = app;
                if (!video.videoWidth) return;
                
                const parentRect = canvas.parentElement.getBoundingClientRect();
                [app.canvasMain, app.canvasInteraction].forEach(c => {
                    if (c.width !== parentRect.width || c.height !== parentRect.height) {
                         c.width = parentRect.width; c.height = parentRect.height;
                    }
                });
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                state.annotations.forEach((ann, index) => {
                    if (Math.abs(ann.time - video.currentTime) < state.frameDuration * 2) {
                        if (ann.type === 'comment' && ann.parentId) return;
                        drawShape(ctx, ann, state.selectedIndices.includes(index));
                    }
                });

                if (state.selectedIndices.length === 1) {
                    const ann = state.annotations[state.selectedIndices[0]];
                    if (ann && ann.type !== 'comment' && !ann.parentId && Math.abs(ann.time - video.currentTime) < state.frameDuration * 2) {
                        drawHandles(ctx, ann);
                    }
                }
            }

            function getHitAnnotation(pos) { 
                let found = { index: -1, handle: null, cursor: null };
                const video = app.videoMain;
                if (!video.videoWidth) return found;
                const videoRect = getVideoRect(app.canvasInteraction, video);
                if (videoRect.width === 0) return found;

                for (let i = state.annotations.length - 1; i >= 0; i--) {
                    const ann = state.annotations[i];
                    if (Math.abs(video.currentTime - ann.time) > state.frameDuration * 2) continue;
                    
                    if (ann.type === 'comment' && ann.parentId) continue;

                    if (state.selectedIndices.includes(i) && ann.type !== 'comment') {
                        const handle = getHitHandle(pos, ann);
                        if(handle) { return { index: i, handle: handle.name, cursor: handle.cursor }; }
                    }

                    let hit = false;
                    if (ann.type === 'comment') {
                        const iconSize = 24; 
                        const anchorOffsetX = 2; 
                        const anchorOffsetY = 22; 
                        
                        const widthNorm = iconSize / videoRect.width;
                        const heightNorm = iconSize / videoRect.height;
                        const anchorOffsetXNorm = anchorOffsetX / videoRect.width;
                        const anchorOffsetYNorm = anchorOffsetY / videoRect.height;

                        const topLeftXNorm = ann.data.x - anchorOffsetXNorm;
                        const topLeftYNorm = ann.data.y - anchorOffsetYNorm;
                        
                        hit = (pos.x >= topLeftXNorm && pos.x <= topLeftXNorm + widthNorm &&
                               pos.y >= topLeftYNorm && pos.y <= topLeftYNorm + heightNorm);
                    } else {
                        const padding = 10 / video.videoWidth; 
                        const { p1, p2 } = ann.data; 
                        const bb = { x: Math.min(p1.x, p2.x) - padding, y: Math.min(p1.y, p2.y) - padding, w: Math.abs(p1.x - p2.x) + 2 * padding, h: Math.abs(p1.y - p2.y) + 2 * padding };
                        hit = (pos.x > bb.x && pos.x < bb.x + bb.w && pos.y > bb.y && pos.y < bb.y + bb.h);
                    }

                    if(hit) { return { index: i, handle: null, cursor: 'move' }; }
                }
                return found;
            }

            function drawShape(ctx, ann, isSelected, isPreview = false) {
                if (!ctx || !app.videoMain.videoWidth) return; 
                ctx.save();
                const videoRect = getVideoRect(ctx.canvas, app.videoMain);
                ctx.translate(videoRect.x, videoRect.y);
                
                const { type, data, color } = ann;
                ctx.strokeStyle = color;
                ctx.lineWidth = isSelected ? 4 : 2;
                if(isPreview) { ctx.setLineDash([6, 3]); ctx.lineWidth = 3; }
                
                const denorm = (p) => ({ x: p.x * videoRect.width, y: p.y * videoRect.height });
                
                ctx.beginPath();
                switch (type) {
                    case 'comment': {
                        const pos = denorm(data);
                        const size = 24; 
                        ctx.fillStyle = color;
                        
                        const path = new Path2D("M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z");
                        
                        ctx.save();
                        ctx.translate(pos.x, pos.y);
                        ctx.scale(size / 24, size / 24);
                        ctx.translate(-2, -22); 
                        
                        ctx.fill(path);
                        ctx.restore();

                        if (isSelected) { 
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; 
                            ctx.beginPath(); 
                            ctx.arc(pos.x, pos.y, 12, 0, 2 * Math.PI); 
                            ctx.fill(); 
                        }
                        break;
                    }
                    case 'image':
                        const img = ann.data.imageObject || imageCache.get(ann.data.base64);
                        if (img && img.complete && img.naturalHeight !== 0) {
                            const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2);
                            ctx.drawImage(img, p1_abs.x, p1_abs.y, p2_abs.x - p1_abs.x, p2_abs.y - p1_abs.y);
                            if (isSelected) { 
                                ctx.strokeStyle = '#00aaff';
                                ctx.strokeRect(p1_abs.x, p1_abs.y, p2_abs.x - p1_abs.x, p2_abs.y - p1_abs.y);
                            }
                        }
                        break;
                    case 'rect': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); ctx.rect(p1_abs.x, p1_abs.y, p2_abs.x - p1_abs.x, p2_abs.y - p1_abs.y); break; }
                    case 'circle': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); ctx.ellipse(p1_abs.x + (p2_abs.x-p1_abs.x)/2, p1_abs.y + (p2_abs.y-p1_abs.y)/2, Math.abs((p2_abs.x-p1_abs.x)/2), Math.abs((p2_abs.y-p1_abs.y)/2), 0, 0, 2 * Math.PI); break; }
                    case 'line': { const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2); ctx.moveTo(p1_abs.x, p1_abs.y); ctx.lineTo(p2_abs.x, p2_abs.y); break; }
                    case 'arrow': {
                        const p1_abs = denorm(data.p1); const p2_abs = denorm(data.p2);
                        const h = 15, dx = p2_abs.x - p1_abs.x, dy = p2_abs.y - p1_abs.y, a = Math.atan2(dy, dx);
                        ctx.moveTo(p1_abs.x, p1_abs.y); ctx.lineTo(p2_abs.x, p2_abs.y);
                        ctx.lineTo(p2_abs.x - h * Math.cos(a - Math.PI / 6), p2_abs.y - h * Math.sin(a - Math.PI / 6));
                        ctx.moveTo(p2_abs.x, p2_abs.y);
                        ctx.lineTo(p2_abs.x - h * Math.cos(a + Math.PI / 6), p2_abs.y - h * Math.sin(a + Math.PI / 6));
                        break;
                    }
                }
                if (type !== 'comment' && type !== 'image') ctx.stroke();
                ctx.restore();
            }

            function drawHandles(ctx, ann) {
                if (!app.videoMain.videoWidth) return;
                ctx.save();
                const videoRect = getVideoRect(ctx.canvas, app.videoMain);
                ctx.translate(videoRect.x, videoRect.y);

                const handles = getHandlesFor(ann);
                ctx.fillStyle = 'white'; 
                const handleSize = 10;
                handles.forEach(h => {
                     const x_abs = h.x * videoRect.width;
                     const y_abs = h.y * videoRect.height;
                     ctx.fillRect(x_abs - handleSize/2, y_abs - handleSize/2, handleSize, handleSize)
                });
                ctx.restore();
            }
            
            function moveAnnotation(index, dx, dy) { 
                const ann = state.annotations[index];
                if (ann.type === 'comment') { ann.data.x += dx; ann.data.y += dy; }
                else { ann.data.p1.x += dx; ann.data.p1.y += dy; ann.data.p2.x += dx; ann.data.p2.y += dy; }
            }

            function resizeAnnotation(index, handle, pos) { 
                const ann = state.annotations[index];
                
                if (ann.type === 'image' && ann.data.imageObject) {
                    const ratio = ann.data.imageObject.naturalWidth / ann.data.imageObject.naturalHeight;
                    if (!ratio) return;
                     const videoRatio = app.videoMain.videoWidth / app.videoMain.videoHeight;

                    const { p1, p2 } = ann.data;
                    const minX = Math.min(p1.x, p2.x), minY = Math.min(p1.y, p2.y);
                    const maxX = Math.max(p1.x, p2.x), maxY = Math.max(p1.y, p2.y);
                    
                    let newP1, newP2;
                    let newWidth, newHeight;

                    switch (handle) {
                        case 'br': 
                            newWidth = Math.max(0.01, pos.x - minX);
                            newHeight = (newWidth * videoRatio) / ratio;
                            newP1 = { x: minX, y: minY };
                            newP2 = { x: minX + newWidth, y: minY + newHeight };
                            break;
                        case 'tl': 
                            newWidth = Math.max(0.01, maxX - pos.x);
                            newHeight = (newWidth * videoRatio) / ratio;
                            newP2 = { x: maxX, y: maxY };
                            newP1 = { x: maxX - newWidth, y: maxY - newHeight };
                            break;
                        case 'tr': 
                            newWidth = Math.max(0.01, pos.x - minX);
                            newHeight = (newWidth * videoRatio) / ratio;
                            newP1 = { x: minX, y: maxY - newHeight };
                            newP2 = { x: minX + newWidth, y: maxY };
                            break;
                        case 'bl': 
                            newWidth = Math.max(0.01, maxX - pos.x);
                            newHeight = (newWidth * videoRatio) / ratio;
                            newP1 = { x: maxX - newWidth, y: minY };
                            newP2 = { x: maxX, y: minY + newHeight };
                            break;
                        default: return;
                    }
                    ann.data.p1 = newP1;
                    ann.data.p2 = newP2;

                } else {
                    const { p1, p2 } = ann.data;
                    const minX = Math.min(p1.x, p2.x), minY = Math.min(p1.y, p2.y), maxX = Math.max(p1.x, p2.x), maxY = Math.max(p1.y, p2.y);
                    switch (handle) {
                        case 'p1': ann.data.p1 = pos; break;
                        case 'p2': ann.data.p2 = pos; break;
                        case 'tl': ann.data.p1 = pos; ann.data.p2 = {x: maxX, y: maxY}; break;
                        case 'br': ann.data.p1 = {x: minX, y: minY}; ann.data.p2 = pos; break;
                        case 'tr': ann.data.p1 = {x: minX, y: pos.y}; ann.data.p2 = {x: pos.x, y: maxY}; break;
                        case 'bl': ann.data.p1 = {x: pos.x, y: minY}; ann.data.p2 = {x: maxX, y: pos.y}; break;
                    }
                }
            }

            const getHandlesFor = (ann) => { 
                const { p1, p2 } = ann.data;
                if (ann.type === 'line' || ann.type === 'arrow') return [{name: 'p1', x: p1.x, y: p1.y, cursor: 'pointer'}, {name: 'p2', x: p2.x, y: p2.y, cursor: 'pointer'}];
                const minX = Math.min(p1.x, p2.x), minY = Math.min(p1.y, p2.y); const maxX = Math.max(p1.x, p2.x), maxY = Math.max(p1.y, p2.y);
                return [ {name: 'tl', x: minX, y: minY, cursor: 'nwse-resize'}, {name: 'tr', x: maxX, y: minY, cursor: 'nesw-resize'}, {name: 'bl', x: minX, y: maxY, cursor: 'nesw-resize'}, {name: 'br', x: maxX, y: maxY, cursor: 'nwse-resize'} ];
            };

            const getHitHandle = (pos, ann) => { 
                const handleSize = 16 / app.videoMain.videoWidth; 
                return getHandlesFor(ann).find(h => 
                    pos.x > h.x - handleSize/2 && pos.x < h.x + handleSize/2 && 
                    pos.y > h.y - handleSize/2 && pos.y < h.y + handleSize/2
                ) || null;
            }
            
            const selectTool = tool => { state.currentTool = state.currentTool === tool ? null : tool; document.querySelectorAll('.tool-btn').forEach(b => b.classList.toggle('active', b.dataset.tool === state.currentTool)); app.canvasInteraction.style.cursor = state.currentTool ? 'crosshair' : 'default'; };
            const selectColor = btn => { state.activeColor = btn.dataset.color; document.getElementById('active-color-btn').style.backgroundColor = state.activeColor; document.getElementById('color-palette-popup').classList.add('hidden'); };
            const toggleColorPalette = () => document.getElementById('color-palette-popup').classList.toggle('hidden');
            
            function saveFrame() {
                if (!app.videoMain.src) return;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = app.videoMain.videoWidth; tempCanvas.height = app.videoMain.videoHeight;
                tempCanvas.getContext('2d').drawImage(app.videoMain, 0, 0, tempCanvas.width, tempCanvas.height);
                const a = document.createElement('a'); a.href = tempCanvas.toDataURL('image/png'); a.download = `frame_${formatTime(app.videoMain.currentTime, true).replace(/:/g, '-')}.png`; a.click();
            }
            const formatTime = (secs, forFilename = false) => { const s = Math.floor(secs % 60); const m = Math.floor((secs / 60) % 60); const d = forFilename ? '-' : ':'; return `${String(m).padStart(2,'0')}${d}${String(s).padStart(2,'0')}`; };
            
            const getMousePos = (e) => { 
                if (!app.videoMain.videoWidth) return { x: 0, y: 0 };
                const canvasRect = app.canvasInteraction.getBoundingClientRect();
                const screenX = e.clientX - canvasRect.left;
                const screenY = e.clientY - canvasRect.top;
                
                const videoRect = getVideoRect(app.canvasInteraction, app.videoMain);
                if (videoRect.width === 0) return { x: 0, y: 0 };
                
                const videoLocalX = screenX - videoRect.x;
                const videoLocalY = screenY - videoRect.y;

                return { 
                    x: Math.max(0, Math.min(1, videoLocalX / videoRect.width)), 
                    y: Math.max(0, Math.min(1, videoLocalY / videoRect.height)) 
                };
            };

            function getVideoRect(canvas, video) {
                if (!video.videoWidth) return { x: 0, y: 0, width: 0, height: 0 };
                const videoRatio = video.videoWidth / video.videoHeight;
                const canvasRatio = canvas.width / canvas.height;
                let width, height;
                if (videoRatio > canvasRatio) {
                    width = canvas.width;
                    height = canvas.width / videoRatio;
                } else {
                    height = canvas.height;
                    width = canvas.height * videoRatio;
                }
                return { x: (canvas.width - width) / 2, y: (canvas.height - height) / 2, width, height };
            }

            function makeTimeEditable() {
                const originalTime = app.timeDisplay.textContent;
                app.timeDisplay.innerHTML = `<input type="text" value="${originalTime}">`;
                const input = app.timeDisplay.querySelector('input');
                input.focus(); input.select();
                const save = () => {
                    const rawValue = input.value.replace(/[^0-9]/g, '');
                    if (rawValue) {
                        let minutes = 0;
                        let seconds = 0;
                        if (rawValue.length <= 2) {
                            seconds = parseInt(rawValue, 10);
                        } else {
                            minutes = parseInt(rawValue.slice(0, -2), 10);
                            seconds = parseInt(rawValue.slice(-2), 10);
                        }
                        const totalSeconds = (minutes * 60) + seconds;
                        seekTo(totalSeconds);
                    }
                    app.timeDisplay.textContent = formatTime(app.videoMain.currentTime);
                };
                input.addEventListener('blur', save);
                input.addEventListener('keydown', e => { if (e.key === 'Enter') input.blur(); });
            }


            init();
        });
    </script>
</body>
</html>
